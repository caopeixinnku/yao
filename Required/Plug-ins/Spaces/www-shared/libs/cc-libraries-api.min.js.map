{"version":3,"file":"cc-libraries-api.min.js","sources":["components/almond/almond.js","components/dcx-js/src/AdobeDCXUtil.js","components/uuid/uuid.js","components/dcx-js/src/AdobeDCXError.js","components/dcx-js/src/components/uuid/uuid.js","components/dcx-js/src/AdobeNetworkHTTPService.js","components/dcx-js/src/AdobeDCXNode.js","components/dcx-js/src/AdobeDCXComponent.js","components/dcx-js/src/AdobeDCXFS.js","components/dcx-js/src/AdobeDCXBranchCore.js","components/dcx-js/src/AdobeDCXElement.js","components/dcx-js/src/AdobeDCXBranch.js","components/dcx-js/src/AdobeDCXPushJournal.js","components/dcx-js/src/AdobeDCXLocalStorage.js","components/dcx-js/src/AdobeDCXComposite.js","components/dcx-js/src/AdobeStorageSession.js","components/dcx-js/src/AdobeDCXCompositeXfer.js","components/dcx-js/src/AdobeDCX.js","AdobeLibraryServices.js","AdobeLibraryError.js","AdobeLibraryConfig.js","utils/AdobeLibraryMimeTypeUtils.js","utils/AdobeLibraryManifestUtils.js","utils/AdobeLibraryFileUtils.js","utils/AdobeLibraryErrorUtils.js","utils/AdobeLibrarySyncUtils.js","AdobeLibraryRepresentation.js","AdobeLibraryAnalytics.js","utils/AdobeLibraryLock.js","utils/AdobeLibraryAsyncJoin.js","utils/AdobeLibraryRenditionUtils.js","utils/AdobeLibraryFeatureUtils.js","utils/AdobeLibraryListenerManager.js","AdobeLibraryElement.js","AdobeLibraryCategory.js","AdobeLibraryComposite.js","AdobeLibrarySyncManager.js","AdobeLibraryCollection.js","AdobeLibraryPublicCollection.js","AdobeLibraryCollectionManager.js","AdobeLibraryMessageChannel.js","AdobeLibraryWebSocket.js","AdobeLibraryStorageInterfaceFS.js","AdobeLibraryStorageInterface.js","AdobeLibraryExternalUtils.js","AdobeLibraryExternalAnalyticsUtils.js","main.js"],"names":["requirejs","require","define","undef","hasProp","obj","prop","hasOwn","call","normalize","name","baseName","nameParts","nameSegment","mapValue","foundMap","lastIndex","foundI","foundStarMap","starI","i","j","part","baseParts","split","map","config","starMap","charAt","slice","length","nodeIdCompat","jsSuffixRegExp","test","replace","concat","splice","join","indexOf","substring","makeRequire","relName","forceSync","req","apply","aps","arguments","makeNormalize","makeLoad","depName","value","defined","callDep","waiting","args","defining","main","Error","splitPrefix","prefix","index","makeConfig","makeMap","handlers","Object","prototype","hasOwnProperty","plugin","parts","f","n","pr","p","exports","e","module","id","uri","deps","callback","cjsModule","ret","usingExports","callbackType","load","undefined","alt","setTimeout","cfg","_defined","amd","jQuery","parse","s","buf","offset","ii","toLowerCase","oct","_hexToByte","unparse","bth","_byteToHex","v1","options","b","clockseq","_clockseq","msecs","Date","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","node","_nodeId","v4","BufferClass","rnds","random","rng","_rng","_global","this","_rb","randomBytes","crypto","getRandomValues","_rnds8","Uint8Array","_rnds","Array","r","Math","Buffer","toString","substr","_seedBytes","uuid","_previousRoot","noConflict","AdobeDCXError","code","message","underlyingError","stack","INVALID_JSON","READ_ONLY","INVALID_PARAMS","INVALID_DATA","DUPLICATE_VALUE","NO_LOCAL_STORAGE","INVALID_STATE","DELETED_COMPOSITE","UNEXPECTED_RESPONSE","NETWORK_ERROR","COMPONENT_DOWNLOAD_ERROR","COMPONENT_UPLOAD_ERROR","UPDATE_CONFLICT","NO_COMPOSITE","ALREADY_EXISTS","SERVICE_IS_INACTIVE","EXCEEDS_QUOTA","NOT_IMPLEMENTED","RETRYABLE_SERVER_ERROR","TIMED_OUT","UNEXPECTED","TERMINATED_INPUTSTREAM","WRONG_ENDPOINT","OUT_OF_SPACE","nodeRequire","generateUuid","x","merge","res","parentDirectory","path","pathComponents","pop","filePathComponents","fileName","nameComponents","extension","directory","appendPathElements","elements","numArgs","element","push","pathRegEx","isValidPath","components","count","component","noOp","consumeStream","stream","data","on","flatCopy","result","keys","key","deepCopy","JSON","stringify","objectsEqual","obj1","obj2","propertiesToIgnore","checkedProperties","val1","val2","type1","type2","uriParsePattern","RegExp","parseURI","url","matches","match","scheme","authority","query","fragment","endPointOf","href","uriItems","defaultPortNumber","ensureRelativeHrefStartsWithSlash","parseHeaderPattern","whiteSpaceFilterPattern","parseHeaders","allHeadersAsText","field","headers","allHeaderLines","line","charCodeOfFirstCharacter","charCodeAt","m","exec","timeStamp","roundDownToFullSeconds","ts","AdobeDCXNode","readOnly","isRoot","_setData","_data","_readOnly","_isRoot","dcxUtil","ROOT_PATH","defineProperties","get","set","_owner","_setDirty","type","relationship","rel","_setPathOfNode","_parentPath","parentPath","absolutePath","getLink","_links","setLink","link","links","removeLink","reservedKeysOfRoot","children","manifest-format-version","state","local","reservedKeys","getCustomKeys","customKeys","c","getValue","setValue","removeValue","copy","newData","isEqualTo","nodePropertiesToIgnore","componentPropertiesToIgnore","_isEqual","nodeData1","nodeData2","array1","array2","count1","count2","component1","component2","err","_verify","AdobeDCXComponent","UploadResults","compositeId","records","UploadRecord","etag","version","md5","STATES","unmodified","modified","pendingDelete","committedDelete","_UploadResults","_UploadRecord","_core","_setPathOfComponent","width","height","_fs","canUseFileSystem","_setFS","fs","ensureDirectoryExists","checkMkdirResult","error","existsCallback","exists","mkdir","getTempFilePathAt","directoryPath","recursivelyGetTempFilePath","tempPath","deleteFile","unlink","readFile","encoding","writeFile","writeFileAtomically","tempFilePath","rename","createWriteStream","createReadStream","move","newPath","touch","utimes","info","stat","directoryListing","requestCount","asyncError","listing","getInfo","readdir","files","deleteDirectory","asynchError","numItemsLeft","finalDelete","rmdir","oneDown","deleteItem","itemPath","names","_copyFile","targetPath","tempFile","sourceFile","pipe","copyFile","AdobeDCXBranchCore","owner","_localStorage","updateStorageForCopiedComponent","originalComponent","copiedComponent","isSameComposite","isSameEndpoint","canChangeId","localStorage","localData","sourceLocalData","targetCore","sourceCore","retainsIdentity","sourceHref","_getSourceHrefOfComponent","existingComponentWithSameId","getComponentWithId","s2scIsPossible","s2scIsDesired","s2scIsRequired","_copyComponentMapping","_getHrefOfComponent","_setSourceHrefOfComponent","AdobeDCXFS","rootNode","getChildWithAbsolutePath","hasLocalStorage","isDirty","_isDirty","changeCount","change","getChildWithId","_allNodes","item","_absolutePaths","getChildrenOf","parentNode","isArray","nodeData","addChild","nodeId","newParent","newChild","removeChild","found","_nodeDataOfParentOfNode","parentNodeData","_removeNodeFromCachesRecursively","moveChild","_nodeIdIsDescendantOf","copyChild","newId","_copyChild","replaceChild","allComponents","_allComponents","getComponentWithAbsolutePath","getComponentsOf","componentData","addComponent","source","compositeHref","_getBranchOf","compositeEndpoint","sourceEndpoint","storageObject","_local","newComponent","self","insertComponentCallback","absPath","_normalizedAbsolutePathForItem","removeComponentAsset","ingestComponentAsset","addComponentWithUploadResults","uploadResults","recordKeys","uploadRecord","componentId","updateComponent","updateComponentCallback","updateComponentWithUploadResults","removeComponent","_nodeDataOfParentOfComponent","moveComponent","copyComponent","_copyComponent","replaceComponent","assetOfComponent","componentAssetPath","branch","lookup","_componentSourceHrefLookup","_copySourceHrefsFrom","otherCore","otherLookup","myComponents","numComponents","myLookup","_isSameComposite","_stringify","stripOutLocalData","pretty","remoteData","allNodes","absPaths","buildDOMandCachesRecursively","thisNodeData","createIfNecessary","_recursiveReset","componentCallback","childData","_recursivelyGetAllComponentsOfChild","currentNodeData","_determineAbsolutePathChangesRecursively","currentNode","currentAbsolutePath","updates","newAbsPath","update","newAbsolutePaths","preserveCompositeState","_hasSameEndpoint","targetHref","targetEndpoint","replaceExisting","sourceLocalStorage","useLocalStorage","copyComponentCallback","componentFilePath","_copyComponentModel","newSourceLocalData","sourceBranch","existingComponent","parentId","itemWithSamePath","newLocalData","sourceComponents","_copyChildModel","finalizeCopy","numComponentsToGo","copyComplete","filePath","y","newNode","existingNode","newAllNodes","newAllComponents","recursivelyRemoveNodeFromLookups","core","absolutePaths","recursivelyAddNodeToLookups","child","originalComponentId","_verifyIntegrity","shouldBeComplete","logger","errors","startedLog","logError","assert","condition","itemsEncountered","itemEncountered","absPathArray","recurse","keysLeft","componentIds","assetPath","existsSync","sourceHrefMap","comp","AdobeDCXElement","_updateLocalDataFromBranch","compositePath","copyLocalStorageData","AdobeDCXBranch","MANIFEST_FORMAT_VERSION","originalManifestFormatVersion","_pendingElements","removeLocalStorageAssetIdRecursively","localStorageAssetId","convertDataFrom5To6","convertDataIfNecessary","_newBranchAsCopyOfCore","coreToCopy","_resetIdentity","resetComponent","origComponent","origHref","_collaborationType","collaborationType","manifestEtag","compositeState","isBound","pendingElements","getElementWithId","_createElement","getElementWithAbsolutePath","addElement","updateElement","elementNode","_deleteElement","abandonElement","newElement","registerInMemoryBranchOrElement","unregisterInMemoryBranchOrElement","_reset","retainId","_resetBinding","AdobeDCXPushJournal","composite","push-journal-format-version","JOURNAL_FORMAT_VERSION","composite-href","uploaded-components","_filePath","_waitingCallbacks","_commitInProgress","_needAnotherCommit","readJournal","journal","compositeHasBeenCreated","hasBeenCreated","compositeHasBeenDeleted","hasBeenDeleted","isEmpty","isComplete","recordUploadedComponent","localStorageFileName","record","idsOfAllUploadedComponents","getRecordForUploadedComponent","removeRecordForUploadedComponent","applyToBranch","preserveDirtyState","branchWasDirty","branchHasChangedSincePush","componentAssetName","commitChanges","doCommit","callbacks","componentRecords","String","AdobeDCXLocalStorage","preserveFileExtensions","_compositePath","_preserveFileExtensions","_inMemoryBranchesAndElements","_inflightComponents","currentManifestPath","currentBaseManifestPath","pulledManifestPath","pulledBaseManifestPath","pushedManifestPath","resolvePulledBranch","_deleteJournal","acceptPushedBranch","discardPulledBranch","discardPushedBranch","discardBaseBranch","branchOrElement","pushJournalPath","illegalName","_componentPathFromName","_newFileNameForComponent","copyOrMoveDone","_setComponentName","mapping","sourceStorageObject","target","targetStorageObject","targetComponents","sourceMapping","targetMapping","targetComponent","sourceComponent","assetName","removeUnusedLocalFiles","lastCurrentTimeStamp","referencedAssetNamesLookup","oldestManifestTimeStamp","componentListing","numRequests","doDeleteFile","_deleteComponentAsset","doDelete","toDelete","fileInfo","mtime","_gatherComponentAssetNames","manifestCount","assetNamesLookup","oldestTimeStamp","tempPathForComponent","deleteTempFiles","clientDataPath","sourceId","targetId","manifestPaths","assetNames","addFromData","processManifest","manifestPath","AdobeDCXComposite","_options","_setPath","_href","_name","_type","_id","_current","_autoRemoveUnusedLocalFiles","xhrBaseBranchSupport","_baseBranchData","_pushedBranchData","_pulledBranchData","COLLABORATION","PRIVATE","SHARED_BY_USER","SHARED_WITH_USER","newCompositeAsCopyOf","compositeOrBranchOrElement","current","_path","autoRemoveUnusedLocalFiles","clientDataStoragePath","loadCurrentFromLocalStorage","_loadBranch","_currentBranchCommittedAtDate","tempAssetPath","removeLocalStorage","loadBaseBranch","loadPulledBranch","loadPushedBranch","resolvePullWithBranch","acceptPush","pushJournal","committedCurrent","finalize","_pushJournal","pending","resetBinding","_discardEveryBranchButCurrent","resetIdentity","branchesToDiscard","FileContent","filename","StreamProvider","AdobeNetworkHTTPService","authCallback","_requestQueue","_requestsOutstanding","_rejectedAuths","_authCallback","_isActive","_waitingForAuthentication","_currentAuthId","_https","https_","_XMLHttpRequest","XMLHttpRequest_","_maxOutstanding","dcxFs","global","window","XMLHttpRequest","MAXDELAY","isActive","wasActive","_authValue","_checkQueue","crossOriginCredentials","_withCredentials","maxOutstanding","_forceXhr","xhr","setAdditionalHeaders","additionalHeaders","_additionalHeaders","setAdditionalNodeOptions","additionalOptions","_additionalNodeOptions","setApiKey","apiKey","_apiKey","timeout","_timeout","setAuthToken","token","resume","setRequestHooks","before","after","_beforeHook","_afterHook","invoke","method","body","responseType","Blob","requestDesc","reuse","reuseRequestDesc","_doRequest","callCallback","response","responseStream","end","pos","clientRequest","timedOut","checkResponse","fileWritten","ended","waitFinish","statusCode","unshift","_authFail","progress","chunk","chunks","once","ArrayBuffer","onReadyStateChange","len","reportedProgress","readyState","status","getAllResponseHeaders","size","streamData","abort","noSoonerThen","Authorization","_allowAuthTokenToBeSentInsecurely_DONT_USE_THIS_IN_PRODUCTION","authId","parsedUrl","opts","console","log","request","bytesSent","bytesReported","unreported","doWrite","write","fileStream","getStream","dataStream","getStreamAsync","Int8Array","buffer","open","withCredentials","onreadystatechange","header","setRequestHeader","ontimeout","send","badAuthId","outstanding","forEach","queue","_checkQueueTimerId","clearTimeout","_checkQueueTimerWhen","when","now","maxWhen","candidateRequestIndex","candidate","next","abortAllWithToken","wrapError","noReWrap","networkError","unexpectedResponse","AdobeStorageSession","httpService","server","_service","_server","_endPoint","SYNC_ASYNC_DEFAULT_DELAY","ASYNC_DEFAULT_DELAY","DEFAULT_POLL_DELAY","ifMatchHeader","ifNoneMatchHeader","adobeDCXManifestType","isValidHref","endPoint","getCollection","respHandler","responseText","json","nextStart","href2","_resolveUrl","getAsset","etagOrHeaders","getComponent","getComponentHref","getAssetAsType","onComplete","getSyncGroups","getSyncGroup","groupName","getCompositeManifest","headRequest","createCompositeDirectory","overwrite","doCreateComposite","Content-Type","X-Update","compositeFullHref","groupHref","deleteCompositeDirectory","If-Match","_handle202Response","leaveSharedComposite","uploadComponent","isNew","isSharedComposite","cancelToken","uploadAssetForComponentId","componentType","doUpload","responseData","_constructComponentHref","copyAssetToComponentId","assetHref","doCopy","isRetry","respone","relativeAssetHref","_makeRelativeUrl","Link","doCopyCallback","updateManifest","manifestData","manifestHref","getBranchManifestHref","getHrefForComposite","syncgroup","getCompositeManifestHref","componentVersion","_parseAsyncResponse","asyncResponse","endOfLine","parseInt","statusText","endOfHeaders","search","allHeaders","bodyStartsAt","_pollForAsyncResponse","pollHref","pollFrequencyInSeconds","retryAfter","defaultSecondsToWaitForRetry","parsedResponse","XferContext","storageSession","cleanup","_storageSession","_callback","_cleanup","_componentsPending","bytesTransfered","bytesTotal","onProgress","_reportProgress","incr","createCompositeDirectoryIfNecessary","overwriteExisting","session","doneWithError","_compositeCreationCallbacks","createComponentUploadRecord","createComponentCopyRecord","internalUploadComponent","internalCopyComponent","ALL_COMPONENTS","MINIMUM_COMPONENTS","NO_COMPONENTS","_callCallback","_xferComplete","_aborted","pullComposite","_pullComposite","pullMinimumComposite","pullCompositeManifestOnly","downloadComponents","getBranchOf","pullContext","_referenceBranch","_pullComponents","pushComposite","pushContext","_journal","_composite","_overwriteExisting","compositeIsNew","_compositeIsNew","_pushComposite","uploadNewComponent","copyAssetForNewComponent","getURLForComponent","componentsToDownload","finalizePull","pulledBranch","branchLoaded","existingPulledBranch","componentDone","failedComponents","componentError","doLoadComponent","parentDir","_pullComponent","loadIfNoLocalAsset","refComponent","Number","reportFailureCheckingForDeletedManifest","headRequestError","originalChangeCount","manifestSizeEstimate","_deleteComposite","_pushComponents","setComponentUploadState","pendingComponents","uploadOneComponent","componentIsNew","stats","storageName","journalRecord","copyOneComponent","componentState","dataLength","byteLength","context","results","AdobeDCX","fileSystemService","_compositeOptions","AdobeDCXUtil","AdobeDCXCompositeXfer","newEmptyComposite","newComposite","newCompositeFromLocalStorage","newCompositeWithHref","createHTTPService","createStorageSession","endpoint","compositeXfer","AdobeLibraryServices","requireType","_initDCX","dcx","_log","getDisplayName","_getDisplayName","hasFileSystem","setFileSystem","getVulcanInterface","vulcanInterfaceType","VulcanInterface","getVulcanMessage","vulcanMessageType","VulcanMessage","hasCEPVulcan","getPathSeparator","getFileNameFromPath","AdobeLibraryError","libraryId","_message","INVALID_PARAMETER","NOT_SUPPORTED","REQUIRES_FILESYSTEM","DELETED_LOCALLY","NOT_ALLOWED","FILE_TOO_LARGE","EXCEEDS_MAX_LIBRARY_SIZE","CORRUPTED_LIBRARY","RENDITION_NOT_AVAILABLE","FS_ERROR","LOGGED_OUT","TRANSFER_ERROR","TRANSFER_ABORTED","ACCESS_DENIED","URL_VALIDATION_FAILED","AdobeLibraryConfig","configurableParams","VERSION","MAX_ELEMENTS","MAX_COMPONENT_SIZE","VALID_RELATIONS","VALID_SYNC_POLICIES","ELEMENT_TYPE_FILTERS","DL_NAMESPACE","DL_PREFIX","VERSION_KEY","CATEGORY_KEY","RELATIONSHIP_KEY","WIDTH_KEY","HEIGHT_KEY","LENGTH_KEY","IS_FULL_SIZE_KEY","MODIFIED_KEY","CREATED_KEY","LINK_TYPE_KEY","LINK_URL_KEY","REPRESENTATION_ORDER_KEY","COMPOSITE_TYPE","LINK_REPRESENTATION_TYPE","ELEMENTS_NAME","CATEGORIES_NAME","ANALYTICS_ELEMENT_UPDATE_THRESHOLD","PUBLIC_USER_ID","DEFAULT_CLOUD_ID","STORAGE_ASSETS_PATH","LIBRARY_SYNC_GROUP","PUBLIC_STORAGE_ASSETS_PATH","PUBLIC_LIBRARY_SYNC_GROUP","STORAGE_API_KEY","USER_AGENT_HEADER","SYNCING_ENABLED","DEFAULT_MAX_SYNC_INTERVAL","RETRY_FAIL_MAX_SYNC_INTERVAL","MAX_SYNC_INTERVAL","POLL_INTERVAL","AUTO_START_POLLING","RENDITION_SIZES","FULL_RENDITION_CONFIG","BACKOFF_INTERVALS","ERROR_RETRY_INTERVALS","NETWORK_TIMEOUT","RETRY_RANDOM_SECONDS","RENDITION_MAX_RETRIES","DEFAULT_RENDITION_RETRY_INTERVAL","RENDITION_RETRY_INTERVAL","DEFAULT_RENDITION_404_BACKOFF","RENDITION_404_BACKOFF","LOCAL_RENDITION_MAX_RETRIES","LOCAL_RENDITION_RETRY_INTERVAL","MAX_UPDATE_CONFLICTS","WHITELISTED_DOMAINS","ADOBE_AUTHENTICATED_DOMAINS","SYNC_POLICY","RENDITION_CACHE_FILE","RENDITION_CACHE_PLACEHOLDER","SHARED_LOCAL_STORAGE","SHARED_LOCAL_STORAGE_VERSION","SHARED_LOCAL_STORAGE_MIN_CLIENT_VERSION","SHARED_LOCAL_STORAGE_MAX_CLIENT_VERSION","VULCAN_PREFIX","VULCAN_STARTUP_MESSAGE","VULCAN_SHUTDOWN_REQUEST","VULCAN_QUERY_REQUEST","VULCAN_QUERY_RESPONSE","VULCAN_LIBRARY_CHANGED_LOCAL_TYPE","VULCAN_LIBRARY_CHANGED_REMOTE_TYPE","VULCAN_LIBRARY_DELETED_TYPE","VULCAN_COLLECTIONS_LOADED_TYPE","VULCAN_COLLECTIONS_UNLOADED_TYPE","setParameter","max","extensionForUnresolvedContentType","contentType","contentTypeForUnresolvedExtension","AdobeLibraryMimeTypeUtils","mimeTypeMap","application/andrew-inset","application/applixware","application/atom+xml","application/atomcat+xml","application/atomsvc+xml","application/ccxml+xml","application/cdmi-capability","application/cdmi-container","application/cdmi-domain","application/cdmi-object","application/cdmi-queue","application/cu-seeme","application/davmount+xml","application/docbook+xml","application/dssc+der","application/dssc+xml","application/ecmascript","application/emma+xml","application/epub+zip","application/exi","application/font-tdpfr","application/gml+xml","application/gpx+xml","application/gxf","application/hyperstudio","application/illustrator","application/inkml+xml","application/ipfix","application/java-archive","application/java-serialized-object","application/java-vm","application/javascript","application/json","application/jsonml+json","application/lost+xml","application/mac-binhex40","application/mac-compactpro","application/mads+xml","application/marc","application/marcxml+xml","application/mathematica","application/mathml+xml","application/mbox","application/mediaservercontrol+xml","application/metalink+xml","application/metalink4+xml","application/mets+xml","application/mods+xml","application/mp21","application/mp4","application/msword","application/mxf","application/octet-stream","application/oda","application/oebps-package+xml","application/ogg","application/omdoc+xml","application/onenote","application/oxps","application/patch-ops-error+xml","application/pdf","application/pgp-encrypted","application/pgp-signature","application/photoshop","application/photoshop.large","application/pics-rules","application/pkcs10","application/pkcs7-mime","application/pkcs7-signature","application/pkcs8","application/pkix-attr-cert","application/pkix-cert","application/pkix-crl","application/pkix-pkipath","application/pkixcmp","application/pls+xml","application/postscript","application/prs.cww","application/pskc+xml","application/rdf+xml","application/reginfo+xml","application/relax-ng-compact-syntax","application/resource-lists+xml","application/resource-lists-diff+xml","application/rls-services+xml","application/rpki-ghostbusters","application/rpki-manifest","application/rpki-roa","application/rsd+xml","application/rss+xml","application/rtf","application/sbml+xml","application/scvp-cv-request","application/scvp-cv-response","application/scvp-vp-request","application/scvp-vp-response","application/sdp","application/set-payment-initiation","application/set-registration-initiation","application/shf+xml","application/smil+xml","application/sparql-query","application/sparql-results+xml","application/srgs","application/srgs+xml","application/sru+xml","application/ssdl+xml","application/ssml+xml","application/tei+xml","application/thraud+xml","application/timestamped-data","application/vnd.3gpp.pic-bw-large","application/vnd.3gpp.pic-bw-small","application/vnd.3gpp.pic-bw-var","application/vnd.3gpp2.tcap","application/vnd.3m.post-it-notes","application/vnd.accpac.simply.aso","application/vnd.accpac.simply.imp","application/vnd.acucobol","application/vnd.acucorp","application/vnd.adobe.air-application-installer-package+zip","application/vnd.adobe.characterstyle+json","application/vnd.adobe.characterstyle+snippet","application/vnd.adobe.charts+zip","application/vnd.adobe.color+json","application/vnd.adobe.colortheme+json","application/vnd.adobe.cube+txt","application/vnd.adobe.formscentral.fcdt","application/vnd.adobe.fxp","application/vnd.adobe.indesign-idms","application/vnd.adobe.layerstyle","application/vnd.adobe.look+xml","application/vnd.adobe.muse-collection","application/vnd.adobe.paragraphstyle+json","application/vnd.adobe.paragraphstyle+snippet","application/vnd.adobe.ribbon.brush+zip","application/vnd.adobe.scatter.brush+zip","application/vnd.adobe.vector.brush+zip","application/vnd.adobe.xdp+xml","application/vnd.adobe.xfdf","application/vnd.ahead.space","application/vnd.airzip.filesecure.azf","application/vnd.airzip.filesecure.azs","application/vnd.amazon.ebook","application/vnd.americandynamics.acc","application/vnd.amiga.ami","application/vnd.android.package-archive","application/vnd.anser-web-certificate-issue-initiation","application/vnd.anser-web-funds-transfer-initiation","application/vnd.antix.game-component","application/vnd.apple.installer+xml","application/vnd.apple.mpegurl","application/vnd.aristanetworks.swi","application/vnd.astraea-software.iota","application/vnd.audiograph","application/vnd.blueice.multipass","application/vnd.bmi","application/vnd.businessobjects","application/vnd.chemdraw+xml","application/vnd.chipnuts.karaoke-mmd","application/vnd.cinderella","application/vnd.claymore","application/vnd.cloanto.rp9","application/vnd.clonk.c4group","application/vnd.cluetrust.cartomobile-config","application/vnd.cluetrust.cartomobile-config-pkg","application/vnd.commonspace","application/vnd.contact.cmsg","application/vnd.cosmocaller","application/vnd.crick.clicker","application/vnd.crick.clicker.keyboard","application/vnd.crick.clicker.palette","application/vnd.crick.clicker.template","application/vnd.crick.clicker.wordbank","application/vnd.criticaltools.wbs+xml","application/vnd.ctc-posml","application/vnd.cups-ppd","application/vnd.curl.car","application/vnd.curl.pcurl","application/vnd.dart","application/vnd.data-vision.rdz","application/vnd.dece.data","application/vnd.dece.ttml+xml","application/vnd.dece.unspecified","application/vnd.dece.zip","application/vnd.denovo.fcselayout-link","application/vnd.dna","application/vnd.dolby.mlp","application/vnd.dpgraph","application/vnd.dreamfactory","application/vnd.ds-keypoint","application/vnd.dvb.ait","application/vnd.dvb.service","application/vnd.dynageo","application/vnd.ecowin.chart","application/vnd.enliven","application/vnd.epson.esf","application/vnd.epson.msf","application/vnd.epson.quickanime","application/vnd.epson.salt","application/vnd.epson.ssf","application/vnd.eszigno3+xml","application/vnd.ezpix-album","application/vnd.ezpix-package","application/vnd.fdf","application/vnd.fdsn.mseed","application/vnd.fdsn.seed","application/vnd.flographit","application/vnd.fluxtime.clip","application/vnd.framemaker","application/vnd.frogans.fnc","application/vnd.frogans.ltf","application/vnd.fsc.weblaunch","application/vnd.fujitsu.oasys","application/vnd.fujitsu.oasys2","application/vnd.fujitsu.oasys3","application/vnd.fujitsu.oasysgp","application/vnd.fujitsu.oasysprs","application/vnd.fujixerox.ddd","application/vnd.fujixerox.docuworks","application/vnd.fujixerox.docuworks.binder","application/vnd.fuzzysheet","application/vnd.genomatix.tuxedo","application/vnd.geogebra.file","application/vnd.geogebra.tool","application/vnd.geometry-explorer","application/vnd.geonext","application/vnd.geoplan","application/vnd.geospace","application/vnd.gmx","application/vnd.google-earth.kml+xml","application/vnd.google-earth.kmz","application/vnd.grafeq","application/vnd.groove-account","application/vnd.groove-help","application/vnd.groove-identity-message","application/vnd.groove-injector","application/vnd.groove-tool-message","application/vnd.groove-tool-template","application/vnd.groove-vcard","application/vnd.hal+xml","application/vnd.handheld-entertainment+xml","application/vnd.hbci","application/vnd.hhe.lesson-player","application/vnd.hp-hpgl","application/vnd.hp-hpid","application/vnd.hp-hps","application/vnd.hp-jlyt","application/vnd.hp-pcl","application/vnd.hp-pclxl","application/vnd.ibm.minipay","application/vnd.ibm.modcap","application/vnd.ibm.rights-management","application/vnd.ibm.secure-container","application/vnd.iccprofile","application/vnd.igloader","application/vnd.immervision-ivp","application/vnd.immervision-ivu","application/vnd.insors.igm","application/vnd.intercon.formnet","application/vnd.intergeo","application/vnd.intu.qbo","application/vnd.intu.qfx","application/vnd.ipunplugged.rcprofile","application/vnd.irepository.package+xml","application/vnd.is-xpr","application/vnd.isac.fcs","application/vnd.jam","application/vnd.jcp.javame.midlet-rms","application/vnd.jisp","application/vnd.joost.joda-archive","application/vnd.kahootz","application/vnd.kde.karbon","application/vnd.kde.kchart","application/vnd.kde.kformula","application/vnd.kde.kivio","application/vnd.kde.kontour","application/vnd.kde.kpresenter","application/vnd.kde.kspread","application/vnd.kde.kword","application/vnd.kenameaapp","application/vnd.kidspiration","application/vnd.kinar","application/vnd.koan","application/vnd.kodak-descriptor","application/vnd.las.las+xml","application/vnd.llamagraphics.life-balance.desktop","application/vnd.llamagraphics.life-balance.exchange+xml","application/vnd.lotus-1-2-3","application/vnd.lotus-approach","application/vnd.lotus-freelance","application/vnd.lotus-notes","application/vnd.lotus-organizer","application/vnd.lotus-screencam","application/vnd.lotus-wordpro","application/vnd.macports.portpkg","application/vnd.mcd","application/vnd.medcalcdata","application/vnd.mediastation.cdkey","application/vnd.mfer","application/vnd.mfmp","application/vnd.micrografx.flo","application/vnd.micrografx.igx","application/vnd.mif","application/vnd.mobius.daf","application/vnd.mobius.dis","application/vnd.mobius.mbk","application/vnd.mobius.mqy","application/vnd.mobius.msl","application/vnd.mobius.plc","application/vnd.mobius.txf","application/vnd.mophun.application","application/vnd.mophun.certificate","application/vnd.mozilla.xul+xml","application/vnd.ms-artgalry","application/vnd.ms-cab-compressed","application/vnd.ms-excel","application/vnd.ms-excel.addin.macroenabled.12","application/vnd.ms-excel.sheet.binary.macroenabled.12","application/vnd.ms-excel.sheet.macroenabled.12","application/vnd.ms-excel.template.macroenabled.12","application/vnd.ms-fontobject","application/vnd.ms-htmlhelp","application/vnd.ms-ims","application/vnd.ms-lrm","application/vnd.ms-officetheme","application/vnd.ms-pki.seccat","application/vnd.ms-pki.stl","application/vnd.ms-powerpoint","application/vnd.ms-powerpoint.addin.macroenabled.12","application/vnd.ms-powerpoint.presentation.macroenabled.12","application/vnd.ms-powerpoint.slide.macroenabled.12","application/vnd.ms-powerpoint.slideshow.macroenabled.12","application/vnd.ms-powerpoint.template.macroenabled.12","application/vnd.ms-project","application/vnd.ms-word.document.macroenabled.12","application/vnd.ms-word.template.macroenabled.12","application/vnd.ms-works","application/vnd.ms-wpl","application/vnd.ms-xpsdocument","application/vnd.mseq","application/vnd.musician","application/vnd.muvee.style","application/vnd.mynfc","application/vnd.neurolanguage.nlu","application/vnd.nitf","application/vnd.noblenet-directory","application/vnd.noblenet-sealer","application/vnd.noblenet-web","application/vnd.nokia.n-gage.data","application/vnd.nokia.radio-preset","application/vnd.nokia.radio-presets","application/vnd.novadigm.edm","application/vnd.novadigm.edx","application/vnd.novadigm.ext","application/vnd.oasis.opendocument.chart","application/vnd.oasis.opendocument.chart-template","application/vnd.oasis.opendocument.database","application/vnd.oasis.opendocument.formula","application/vnd.oasis.opendocument.formula-template","application/vnd.oasis.opendocument.graphics","application/vnd.oasis.opendocument.graphics-template","application/vnd.oasis.opendocument.image","application/vnd.oasis.opendocument.image-template","application/vnd.oasis.opendocument.presentation","application/vnd.oasis.opendocument.presentation-template","application/vnd.oasis.opendocument.spreadsheet","application/vnd.oasis.opendocument.spreadsheet-template","application/vnd.oasis.opendocument.text","application/vnd.oasis.opendocument.text-master","application/vnd.oasis.opendocument.text-template","application/vnd.oasis.opendocument.text-web","application/vnd.olpc-sugar","application/vnd.oma.dd2+xml","application/vnd.openofficeorg.extension","application/vnd.openxmlformats-officedocument.presentationml.presentation","application/vnd.openxmlformats-officedocument.presentationml.slide","application/vnd.openxmlformats-officedocument.presentationml.slideshow","application/vnd.openxmlformats-officedocument.presentationml.template","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet","application/vnd.openxmlformats-officedocument.spreadsheetml.template","application/vnd.openxmlformats-officedocument.wordprocessingml.document","application/vnd.openxmlformats-officedocument.wordprocessingml.template","application/vnd.osgeo.mapguide.package","application/vnd.osgi.dp","application/vnd.osgi.subsystem","application/vnd.palm","application/vnd.pawaafile","application/vnd.pg.format","application/vnd.pg.osasli","application/vnd.picsel","application/vnd.pmi.widget","application/vnd.pocketlearn","application/vnd.powerbuilder6","application/vnd.previewsystems.box","application/vnd.proteus.magazine","application/vnd.publishare-delta-tree","application/vnd.pvi.ptid1","application/vnd.quark.quarkxpress","application/vnd.realvnc.bed","application/vnd.recordare.musicxml","application/vnd.recordare.musicxml+xml","application/vnd.rig.cryptonote","application/vnd.rim.cod","application/vnd.rn-realmedia","application/vnd.rn-realmedia-vbr","application/vnd.route66.link66+xml","application/vnd.sailingtracker.track","application/vnd.seemail","application/vnd.sema","application/vnd.semd","application/vnd.semf","application/vnd.shana.informed.formdata","application/vnd.shana.informed.formtemplate","application/vnd.shana.informed.interchange","application/vnd.shana.informed.package","application/vnd.simtech-mindmapper","application/vnd.smaf","application/vnd.smart.teacher","application/vnd.solent.sdkm+xml","application/vnd.spotfire.dxp","application/vnd.spotfire.sfs","application/vnd.stardivision.calc","application/vnd.stardivision.draw","application/vnd.stardivision.impress","application/vnd.stardivision.math","application/vnd.stardivision.writer","application/vnd.stardivision.writer-global","application/vnd.stepmania.package","application/vnd.stepmania.stepchart","application/vnd.sun.xml.calc","application/vnd.sun.xml.calc.template","application/vnd.sun.xml.draw","application/vnd.sun.xml.draw.template","application/vnd.sun.xml.impress","application/vnd.sun.xml.impress.template","application/vnd.sun.xml.math","application/vnd.sun.xml.writer","application/vnd.sun.xml.writer.global","application/vnd.sun.xml.writer.template","application/vnd.sus-calendar","application/vnd.svd","application/vnd.symbian.install","application/vnd.syncml+xml","application/vnd.syncml.dm+wbxml","application/vnd.syncml.dm+xml","application/vnd.tao.intent-module-archive","application/vnd.tcpdump.pcap","application/vnd.tmobile-livetv","application/vnd.trid.tpt","application/vnd.triscape.mxs","application/vnd.trueapp","application/vnd.ufdl","application/vnd.uiq.theme","application/vnd.umajin","application/vnd.unity","application/vnd.uoml+xml","application/vnd.vcx","application/vnd.visio","application/vnd.visionary","application/vnd.vsf","application/vnd.wap.wbxml","application/vnd.wap.wmlc","application/vnd.wap.wmlscriptc","application/vnd.webturbo","application/vnd.wolfram.player","application/vnd.wordperfect","application/vnd.wqd","application/vnd.wt.stf","application/vnd.xara","application/vnd.xfdl","application/vnd.yamaha.hv-dic","application/vnd.yamaha.hv-script","application/vnd.yamaha.hv-voice","application/vnd.yamaha.openscoreformat","application/vnd.yamaha.openscoreformat.osfpvg+xml","application/vnd.yamaha.smaf-audio","application/vnd.yamaha.smaf-phrase","application/vnd.yellowriver-custom-menu","application/vnd.zul","application/vnd.zzazz.deck+xml","application/voicexml+xml","application/widget","application/winhlp","application/wsdl+xml","application/wspolicy+xml","application/x-7z-compressed","application/x-abiword","application/x-ace-compressed","application/x-apple-diskimage","application/x-authorware-bin","application/x-authorware-map","application/x-authorware-seg","application/x-bcpio","application/x-bittorrent","application/x-blorb","application/x-bzip","application/x-bzip2","application/x-cbr","application/x-cdlink","application/x-cfs-compressed","application/x-chat","application/x-chess-pgn","application/x-conference","application/x-cpio","application/x-csh","application/x-debian-package","application/x-dgc-compressed","application/x-director","application/x-doom","application/x-dtbncx+xml","application/x-dtbook+xml","application/x-dtbresource+xml","application/x-dvi","application/x-envoy","application/x-eva","application/x-font-bdf","application/x-font-ghostscript","application/x-font-linux-psf","application/x-font-otf","application/x-font-pcf","application/x-font-snf","application/x-font-ttf","application/x-font-type1","application/font-woff","application/x-freearc","application/x-futuresplash","application/x-gca-compressed","application/x-glulx","application/x-gnumeric","application/x-gramps-xml","application/x-gtar","application/x-hdf","application/x-install-instructions","application/x-iso9660-image","application/x-java-jnlp-file","application/x-latex","application/x-lzh-compressed","application/x-mie","application/x-mobipocket-ebook","application/x-ms-application","application/x-ms-shortcut","application/x-ms-wmd","application/x-ms-wmz","application/x-ms-xbap","application/x-msaccess","application/x-msbinder","application/x-mscardfile","application/x-msclip","application/x-msdownload","application/x-msmediaview","application/x-msmetafile","application/x-msmoney","application/x-mspublisher","application/x-msschedule","application/x-msterminal","application/x-mswrite","application/x-netcdf","application/x-nzb","application/x-pkcs12","application/x-pkcs7-certificates","application/x-pkcs7-certreqresp","application/x-rar-compressed","application/x-research-info-systems","application/x-sh","application/x-shar","application/x-shockwave-flash","application/x-silverlight-app","application/x-sql","application/x-stuffit","application/x-stuffitx","application/x-subrip","application/x-sv4cpio","application/x-sv4crc","application/x-t3vm-image","application/x-tads","application/x-tar","application/x-tcl","application/x-tex","application/x-tex-tfm","application/x-texinfo","application/x-tgif","application/x-ustar","application/x-wais-source","application/x-x509-ca-cert","application/x-xfig","application/x-xliff+xml","application/x-xpinstall","application/x-xz","application/x-zmachine","application/xaml+xml","application/xcap-diff+xml","application/xenc+xml","application/xhtml+xml","application/xml","application/xml-dtd","application/xop+xml","application/xproc+xml","application/xslt+xml","application/xspf+xml","application/xv+xml","application/yang","application/yin+xml","application/zip","audio/adpcm","audio/basic","audio/midi","audio/mp4","audio/mpeg","audio/ogg","audio/s3m","audio/silk","audio/vnd.dece.audio","audio/vnd.digital-winds","audio/vnd.dra","audio/vnd.dts","audio/vnd.dts.hd","audio/vnd.lucent.voice","audio/vnd.ms-playready.media.pya","audio/vnd.nuera.ecelp4800","audio/vnd.nuera.ecelp7470","audio/vnd.nuera.ecelp9600","audio/vnd.rip","audio/webm","audio/x-aac","audio/x-aiff","audio/x-caf","audio/x-flac","audio/x-matroska","audio/x-mpegurl","audio/x-ms-wax","audio/x-ms-wma","audio/x-pn-realaudio","audio/x-pn-realaudio-plugin","audio/x-wav","audio/xm","chemical/x-cdx","chemical/x-cif","chemical/x-cmdf","chemical/x-cml","chemical/x-csml","chemical/x-xyz","image/bmp","image/cgm","image/g3fax","image/gif","image/ief","image/jpeg","image/jpg","image/ktx","image/png","image/prs.btif","image/sgi","image/svg+xml","image/tiff","image/vnd.adobe.photoshop","image/vnd.adobe.shape+svg","image/vnd.dece.graphic","image/vnd.dvb.subtitle","image/vnd.djvu","image/vnd.dwg","image/vnd.dxf","image/vnd.fastbidsheet","image/vnd.fpx","image/vnd.fst","image/vnd.fujixerox.edmics-mmr","image/vnd.fujixerox.edmics-rlc","image/vnd.ms-modi","image/vnd.ms-photo","image/vnd.net-fpx","image/vnd.wap.wbmp","image/vnd.xiff","image/webp","image/x-3ds","image/x-adobe-photoshop-brush","image/x-cmu-raster","image/x-cmx","image/x-freehand","image/x-icon","image/x-mrsid-image","image/x-pcx","image/x-pict","image/x-portable-anymap","image/x-portable-bitmap","image/x-portable-graymap","image/x-portable-pixmap","image/x-rgb","image/x-tga","image/x-xbitmap","image/x-xpixmap","image/x-xwindowdump","message/rfc822","model/iges","model/mesh","model/vnd.collada+xml","model/vnd.dwf","model/vnd.gdl","model/vnd.gtw","model/vnd.mts","model/vnd.vtu","model/vrml","model/x3d+binary","model/x3d+vrml","model/x3d+xml","text/cache-manifest","text/calendar","text/css","text/csv","text/html","text/n3","text/plain","text/prs.lines.tag","text/richtext","text/sgml","text/tab-separated-values","text/troff","text/turtle","text/uri-list","text/vcard","text/vnd.curl","text/vnd.curl.dcurl","text/vnd.curl.scurl","text/vnd.curl.mcurl","text/vnd.dvb.subtitle","text/vnd.fly","text/vnd.fmi.flexstor","text/vnd.graphviz","text/vnd.in3d.3dml","text/vnd.in3d.spot","text/vnd.sun.j2me.app-descriptor","text/vnd.wap.wml","text/vnd.wap.wmlscript","text/x-asm","text/x-c","text/x-fortran","text/x-java-source","text/x-opml","text/x-pascal","text/x-nfo","text/x-setext","text/x-sfv","text/x-uuencode","text/x-vcalendar","text/x-vcard","video/3gpp","video/3gpp2","video/h261","video/h263","video/h264","video/jpeg","video/jpm","video/mj2","video/mp4","video/mpeg","video/ogg","video/quicktime","video/vnd.dece.hd","video/vnd.dece.mobile","video/vnd.dece.pd","video/vnd.dece.sd","video/vnd.dece.video","video/vnd.dvb.file","video/vnd.fvt","video/vnd.mpegurl","video/vnd.ms-playready.media.pyv","video/vnd.uvvu.mp4","video/vnd.vivo","video/webm","video/x-f4v","video/x-fli","video/x-flv","video/x-m4v","video/x-matroska","video/x-mng","video/x-ms-asf","video/x-ms-vob","video/x-ms-wm","video/x-ms-wmv","video/x-ms-wmx","video/x-ms-wvx","video/x-msvideo","video/x-sgi-movie","video/x-smv","x-conference/x-cooltalk","extensionMap","mimeType","extensions","getExtensions","getMimeTypes","AdobeLibraryManifestUtils","SUPERTYPE_MAP","isCompatibleType","requestedType","actualType","validateLibraryId","isPublic","validateLibrary","dcxComposite","areManifestsEqual","manifest1","manifest2","data1","data2","ignore","getDCXKey","namespace","getCustomDCXData","dcxElement","customData","splitKey","isNamespacedKey","isLibraryKey","shift","copyCustomDCXData","dcxElement1","dcxElement2","order","checkDeletedState","object","deletedLocally","checkEncoding","supportedEncodings","supported","sortRepresentations","representations","changed","r1","r2","_getOrder","removeMissingComponents","numFixed","failed","getRepresentationById","library","foundRepresentation","some","representation","removeMissingLocalComponents","representationsToRemove","_dcxBranch","beginOperation","removeRepresentation","endOperation","collaborationStateToDCX","collaboration","collaborationStateFromDCX","dcxCollaboration","getElementReference","storageHost","elementId","AdobeLibraryFileUtils","getTempPath","stripTempSuffix","ensurePathExists","recursiveEnsurePath","dirs","pathToTest","pathSep","continuation","hadError","normaliseTempFileName","getFileExtension","fileNameOrPath","dotIndex","lastIndexOf","recursiveDeleteDirectory","items","finishDeleteItem","firstError","isDirectory","moveLibrary","oldLibraryId","oldCompositePath","_collection","_getCompositeDir","newCompositePath","oldRenditionCachePath","_getRenditionCacheDir","newRenditionCachePath","_dcxComposite","readLibraryDirectory","collection","tempDir","_getTempDir","doesRootDirExist","deleteLibraryFromDisk","renditionPath","AdobeLibraryErrorUtils","getErrorStatusCode","getSyncError","newError","getCommitError","additionalMessage","explanation","getErrorPriority","errorsInPriorityOrder","priority","errorToString","str","isErrorCode","errorCode","AdobeLibrarySyncUtils","getBackoffTicks","numBackoffs","intervals","min","getRetryAfterHeader","retryAfterHeader","retryTime","retryDate","valueOf","retrySeconds","retryRandom","floor","getLocationHeader","locationHeader","location","Location","getContentTypeHeader","semiColonIndex","isUnrecoverableClientError","checkDomain","domain","domainSuffixList","domainSuffix","isAdobeDomain","validateURL","urlItems","isWhitelisted","AdobeLibraryRepresentation","dcxNode","dcxComponent","_element","_dcxNode","_dcxComponent","_deletedLocally","_pendingDownloadCallbacks","_markDeletedLocally","isDeleted","_toJSON","_componentPath","_getComponentPath","_getDCXElement","_setComponentInBrowser","content","that","syncManager","_library","_syncManager","_commit","_setComponentFromPath","dcxPath","storageInterface","notifyStartWrite","_setComponent","finishWritingFile","componentPath","tempRootPath","_getCurrentComponentPath","noRetry","isExternalLink","_getExternalLinkPath","_networkLock","obtain","release","_setSyncState","downloadRepresentation","_setRenditionCache","notifyDownloadRendition","_lock","_getCachedExternalLinkPath","returnPlaceholder","cachedError","cachedPath","_lookupRenditionPath","downloadExternalLink","callPendingCallbacks","onDownloadComplete","setRenditionCache","startTime","getAssetFromURL","errorStatus","tempFilePathWithExtension","_testExternalLink","doHeadRequestOfURL","jasmineToString","writable","isFullSize","contentLength","statSync","dcxKey","getValues","newValue","updateContent","updateContentFromPath","moveFile","updateContentFromURL","createLink","getContentPath","getCachedContentPath","getContent","getSharedCloudContent","getContentURL","getSharedCloudContentURL","getAuthenticatedContentURL","appendAccessTokenToURL","testExternalLink","getCachedExternalLinkError","getElementType","getLibraryProperties","properties","libraryID","libraryElementCount","_elements","libraryShared","getElementTrackingData","primary","getPrimaryRepresentation","trackingdata","getElementProperties","elementID","elementType","trackingData","getRepresentationProperties","representationType","isReportingEnabled","analytics","reportError","lastUpdatedElement","lastUpdatedElementOn","reportCreateLibrary","reportEvent","reportDeleteLibrary","reportCreateElement","reportUpdateElement","onlyInfoChanged","updateType","reportUseElement","opType","details","reportCheckoutElement","reportDeleteElement","reportCopyElement","oldElement","oldLibraryID","oldElementID","reportMoveElement","reportCollisionElement","reportCreateRepresentation","reportDeleteRepresentation","reportCreateLink","reportShareElementLink","reportShareLibraryLink","reportUnexpectedState","logs","AdobeLibraryLock","_isLocked","_pendingContinuations","thisObject","cont","abortPendingOperations","continuations","isLocked","hasPendingRequest","AdobeLibraryAsyncJoin","_operations","_isRunning","addOperation","operation","argsArray","run","reportErrorFunction","hasResults","finishedCallback","hasReturned","lastError","completed","numOperations","reduce","a","op","AdobeLibraryRenditionUtils","PNG_RENDITION_SUPPORTED","application/x-indesign","application/vnd.adobe.psremix","application/vnd.adobe.pstouch","application/vnd.adobe.ideas","application/vnd.adobe.ase","image/pjpeg","image/x-ms-bmp","image/x-png","image/jp2","image/psd","application/x-photoshop","image/raw","image/dng","image/x-adobe-dng","video/mp2t","application/vnd.adobe.brushes.brush+ucf","application/vnd.adobe.collage","application/vnd.adobe.proto","application/msexcel","application/mspowerpoint","application/vnd.ms-publisher","text/rtf","gcRenditionCacheItem","gcRenditionCache","renditionCache","referencedFiles","renditions","elementRenditions","_pendingRenditionCacheItems","renditionCachePath","asyncJoin","normalFileName","readRenditionCacheData","cacheData","writeRenditionCacheData","destPath","copyRenditionCache","oldRenditionCache","oldRoot","canComputeRenditionFromMimeType","canComputeRendition","hasComponent","shouldPrefetchFullRendition","fullRenditionConfig","fullConfig","shouldGenerateFull","types","noMatchingRepresentations","every","shouldPrefetchExternalLink","prefetchConfig","EXTERNAL_LINK_PREFETCH","prefetchRenditions","sizeMap","sizes","getRenditionPath","addToRenditionSizeConfig","newRenditionSizes","currentDefaultSizes","newDefaultSizes","newSizes","addToFullRenditionConfig","newFullSizeConfig","conditions","newConditions","newCondition","addToPendingSetRenditionCache","indicesToRemove","AdobeLibraryFeatureUtils","supportsClearRenditionCache","serviceInfo","getServiceInfo","serviceVersion","apiVersion","AdobeLibraryListenerManager","restrictedTypes","_restrictedTypes","_listeners","_checkType","allowed","add","remove","listeners","removeAll","notify","hasListeners","cb","AdobeLibraryElement","_renditionCache","_listenerManager","_setDCXNode","AdobeLibraryAnalytics","keepRenditionCache","_representations","nodeRepresentations","componentRepresentations","categoryId","_categories","category","_category","_clearRenditionCache","_displayName","_removeAllListeners","sort","_addRepresentation","insertAtStart","_removeRepresentation","_doCreateRepresentation","oldOrder","lastRepresentation","cachedFile","_getNewRenditionPath","rootPath","_updateModifiedTime","modifiedTime","_updateCreatedTime","createdTime","errorsOnly","sendMessage","sendClearMessage","infoOnly","_commitRenditionCache","_wrapOperation","retValue","innerRetValue","displayName","tags","constructor","isStringArray","tag","_removeElementFromFilter","_addElementToFilter","created","addChangeListener","removeChangeListener","createRepresentation","rep","createHigherFidelityPrimaryRepresentation","removeAllRepresentations","_getRenditionCandidate","renditionCandidate","rSize","rComparisonSize","isPrimary","isRendition","canReplaceRenditionCandidate","renditionCandidateComparisonSize","POSITIVE_INFINITY","getRenditionUrl","_waitForCommit","getSharedCloudRenditionUrl","getSharedCloudRendition","downloadedFilePath","newFileName","getReference","_storageHost","AdobeLibraryCategory","AdobeLibraryComposite","_writable","_filterCache","_transactionCount","_pendingCommit","_onCommitCallbacks","_renditionCacheLock","_syncState","_deletedFromServer","_waitForSyncToFinishCallbacks","_errors","_pushFailedDueToQuota","_numUpdateConflicts","dcxChildren","_dcxElementsNode","_dcxCategoriesNode","categoryNodes","elementNodes","_dcxBaseBranch","categories","_getRenditionCache","_loadRenditionCache","_setCollaboration","_saveRenditionCache","_doCommit","doPush","_clearSyncErrors","_push","_resetPollBackoff","doCommitCallbacks","checkError","_reportCommitError","commitManifest","_notifyChange","commitWithoutPush","leaveModificationUnchanged","_ensureOrder","arrayName","item1","item2","item2Fixed","array","dcxParent","index1","index2","_getFilterKey","isFilteredType","doSort","_ensureFilterOrderForElement","e1","e2","_doCreateElement","_doRemoveElement","removeDCXNode","_doCopyDCXElement","copyToLibrary","deleteAfterCopy","copiedNode","copiedElement","finishedCopyRenditionCache","_doCopyElement","isUniqueId","elem","syncState","_updateSyncState","_checkSyncFinishedAndNotify","_isSyncing","_waitForSyncToFinish","_isDeletedError","isUnauthorised","_mergeAndSwitchToBranch","baseBranch","continueWithBaseBranch","isLocalMerge","pulledLibraryModified","maxLibraryModified","pulledBranchElementsNode","pulledBranchCategoriesNode","pulledBranchChildren","handledElements","pendingNotifications","pendingDeleteElements","pendingAsyncOperations","currentModified","pulledNode","pulledModified","baseNode","baseModified","updatedNode","newCopiedNode","newCopiedElement","originalPulledBranchData","_pull","didPull","_reportSyncError","_doRebindToServer","_pushWithParameters","doCallback","didPush","_retryTimeoutId","_pushPending","dcxPushingBranch","_sync","_abortPushOrPull","abortPushOrPull","_deleteFromServer","forceDelete","_deletingFromServerInProgress","onFinished","_deletedFromDisk","pushDeletedComposite","resetFunction","oldId","_libraryIdMap","prepareCompositeForPush","pushOnly","didPushOrPull","tryPush","_publicId","deletedFromServer","quotaExceeded","syncProgress","_syncProgressMap","createElement","removeElement","moveElementAfter","afterElement","moveElementBefore","beforeElement","copyElement","newLibrary","moveElement","createCategory","removeCategory","shouldDeleteElements","replacementCategory","doRemoveCategory","elementsToDelete","categoryHasElements","replacementValid","moveCategoryAfter","afterCategory","moveCategoryBefore","beforeCategory","getFilteredElements","sync","rebindToServer","getElementById","foundElement","AdobeLibrarySyncManager","_isPublic","IS_PUBLIC","STORAGE_HOSTNAME","_storageAssetsPath","_syncGroup","_XHR","XHR","_getAccessToken","getAccessToken","_httpServices","_storageService","_createStorageSession","_renditionStorageService","_temporaryStorageServices","_lastSyncGroupState","_hasSetAuthToken","_authToken","_inProgressSyncMap","_updateAuthToken","_getNodeTunnelOptions","NODE_TUNNEL_OPTIONS","processType","process","env","tunnel","CCLIBRARIES_CHARLES_PORT","agent","httpsOverHttp","proxy","host","port","rejectUnauthorized","CCLIBRARIES_HTTPS_PROXY","CCLIBRARIES_HTTPS_PROXY_PORT","proxyAuth","PROXY_AUTH","_getCommonRequestHeaders","_setAuthToken","accessToken","_getAuthToken","_authHandler","bind","_getStorageHost","_createTemporaryStorageSession","_getTemporaryStorageSession","getServerComposites","lastEtag","getSyncGroupPath","syncGroup","oldCompositeEtags","compositeEtags","newCompositeEtags","composites","compositeInfo","serverComposites","isUnmodified","clearSyncGroupCache","doHeadRequest","hasCompositeChangedOnServer","localEtag","manifestOnly","pullFunction","_updateProgress","duration","headErr","headResponse","libraryStillOnServer","fixedBranch","bytesLoaded","updateConflictError","_getStorageRoot","getCompositePath","getComponentPath","_getSharedCloudRenditionUrl","includeQueryParameters","_getAssetAsType","numRetries","retry","responseHeaders","_lastRendition404","currentTime","timeSinceLast404","Accept","storageService","newURL","updateAccessToken","isLoggedIn","AdobeLibraryCollection","_rootDir","ROOT_DIR","_userId","USER_ID","_cloudId","CLOUD_ID","_cloudInfo","CLOUD_INFO","_libraries","_initialSyncInProgress","_syncErrors","_pendingDeletes","_loaded","_syncing","_lastSyncTime","_pendingSyncs","_backoffTicks","_numBackoffs","_numRetries","collectionOnly","_load","libraries","loadLibrary","finishedLoadingLibrary","_removeFromPendingDeletes","_handlePendingDeletes","finishOperation","_doesLibraryExist","_syncNewLibrary","_syncNewLibraries","_loadingHint","newCompositeList","_syncExistingLibraries","isUnmodifiedOnServer","finishedSync","hasChanged","_dosync","didSomething","newErrors","_lastCommitError","_updateRetryState","getPrimarySyncError","_retryTime","_syncWithParameters","isSyncing","isLibrarySyncing","newState","_syncProgress","oldSyncState","_ensureDefaultLibrary","libraryProgressChanged","libraryLoaded","libraryTotal","newLibraryProgress","round","totalSyncing","totalKnown","loaded","total","progressMap","progressRatio","newProgress","_setInitialSyncState","initialSync","loadingHint","_getBaseDir","sanitisedUserId","compositeDir","renditionCacheDir","finishedSyncing","initialSyncInProgress","numMaterialLibraries","DEFAULT_LIBRARY_NAME","createLibrary","_doRemoveLibrary","commitError","syncErrors","isPolling","_pollTimerId","userId","cloudId","cloudInfo","addDeepChangeListener","removeDeepChangeListener","removeLibrary","removeDeletedLibraries","removeDeletedLibrary","librariesToIgnore","exclude","hasLibrariesToRemove","shouldDelete","ignoreLibrary","isPollSync","addSyncListener","removeSyncListener","primaryError","lastPriority","getNewLibrarySyncProgress","_newLibraryProgress","newLibrarySyncProgress","addCommitErrorListener","removeCommitErrorListener","startPolling","interval","setInterval","stopPolling","clearInterval","getDefaultLibrary","defaultLibrary","getLibraryById","foundLibrary","getTempDir","AdobeLibraryPublicCollection","_newLibrariesLoading","loadingCallbacks","loadPublicLibrary","unloadLibrary","unloadPublicLibrary","unloadDeletedLibraries","AdobeLibraryCollectionManager","_collections","getLibraryCollection","getPublicLibraryCollection","addLibraryCollection","removeLibraryCollection","removeAllLibraryCollections","getLoadedCollections","addLoadedCollectionsListener","removeLoadedCollectionsListener","AdobeLibraryMessageChannel","socket","_socket","_socketListenerManager","_pendingWriteState","_pendingWriteDependencyMap","_init","getRequestType","getResponseType","getPendingWriteKey","_addSocketListener","_logReceive","event","addListener","_removeSocketListeners","removeListener","_logSend","_logCallback","setPendingWriteState","setPendingWriteDependency","userId1","cloudId1","libraryId1","userId2","cloudId2","libraryId2","key1","key2","clearPendingWriteState","clearedDependencies","depKey","getPendingWriteState","excludeSelfState","isPending","setLogCallback","addCallListener","removeCallListener","requestID","onResponse","onOpen","onClose","onError","shutdown","close","AdobeLibraryWebSocket","WebSocket","onopen","_onSocketOpen","onclose","_onSocketClose","onmessage","_onSocketMessage","onerror","_onSocketError","evt","wrapCallback","AdobeLibraryStorageInterfaceFS","_storageInterface","FS_API","renameSync","ftruncate","ftruncateSync","truncate","truncateSync","chown","chownSync","fchown","fchownSync","lchown","lchownSync","chmod","chmodSync","fchmod","fchmodSync","lchmod","lchmodSync","lstat","fstat","lstatSync","fstatSync","linkSync","symlink","symlinkSync","readlink","readlinkSync","realpath","realpathSync","unlinkSync","rmdirSync","mkdirSync","readdirSync","closeSync","openSync","utimesSync","futimes","futimesSync","fsync","fsyncSync","writeSync","read","readSync","readFileSync","writeFileSync","appendFile","appendFileSync","watchFile","unwatchFile","watch","_fsCall","requestData","_channel","_pipeCall","writeStream","readStream","AdobeLibraryStorageInterface","collectionManager","_collectionManager","_acceptPushedBranchListeners","_downloadRenditionListeners","_rootListeners","_baseBranches","_pendingSetRenditionCache","_connect","_getBase","base","_setBase","_getServicePort","responsePayload","requestType","responseHandler","removeMessageListener","getPayload","addMessageListener","setPayload","dispatchMessage","vulcanCall","_connectToPort","_isConnected","_onEnvironmentInfo","_onCollectionAdded","_onCollectionRemoved","_onSyncState","_onLibraryChange","_onRenditionCacheChange","_onLibraryDeleted","_sendConfiguration","_onDisconnect","CLIENT_DESCRIPTION","SHARED_LOCAL_STORAGE_ANALYTICS","_serviceInfo","whitelistedDomains","libraryCollection","rootDir","loadExistingLibrary","manifest","_getLibraryCollection","libraryStates","updateExistingLibrary","_deleteLibrary","isConnected","reconnect","updateRequired","codeVersion","buildNumber","environment","syncingEnabled","updateConfiguration","currentManifest","pendingSetRenditionCache","success","newFile","setRenditionCallback","onAcceptPushedBranch","removeOnAcceptPushedBranchListeners","_addLibrary","createNewLibrary","baseManifest","updated","onDownloadRendition","removeOnDownloadRenditionListeners","_downloadRenditionCacheListeners","dependentLibraries","dependencies","depLibrary","AdobeLibraryExternalUtils","mimeTypeToExtensions","extensionToMimeTypes","canGenerateRenditionFromMimeType","AdobeLibraryExternalAnalyticsUtils","addLoadCallback","isLoading","loadingState","notifyLoadCallbacks","CCLibraries","configure","setOption","option","disallowedKeys","getLoadedCollectionById","getLoadedPublicCollectionById","getRootDir","unloadLibraryCollection","loadLibraryCollection","finishedLoading","rootDirExists","WAIT_FOR","onChange","loadPublicLibraryCollection","publicLibraryCollection","isSyncingEnabled","enableSyncing","disableSyncing","resolveElementReference","elementRef","regex","utils","analyticsUtils"],"mappings":"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","sourcesContent":["/**\n * @license almond 0.2.9 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                name = baseParts.concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"components/almond/almond\", function(){});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, nodeRequire */\n\n/**\n * @private\n */\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\nif (typeof nodeRequire !== 'function') { var nodeRequire = require; }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCXUtil',['require','exports','module','./components/uuid/uuid'],function (require, exports, module) {\n    'use strict';\n    \n    var generateUuid;\n    /*begin-node-only*/\n    // Support loading uuid module in either environment. We try loading it with the\n    // regular require first (XHR) and then fall back to nodeRequire.\n    try {\n        generateUuid = require('./components/uuid/uuid');\n    } catch (x) {\n        generateUuid = nodeRequire('uuid');\n    }\n    /*end-node-only*/\n    /*begin-web-only//\n        generateUuid = require('uuid');\n    //end-web-only*/\n    \n    /**\n     * Merges the objects in the argument list, modifying and returning the first.\n     * To merge into a new object, pass {} as the first parameter.\n     * Only arguments (except the first) that are dictionaries are merged, so passing\n     * 'undefined' as a parameter has no effect.\n     * @private\n     * @param   {Object} res The object to merge.\n     * @returns {Object} The merged object.\n     */\n    exports.merge = function (res) {\n        var i, name;\n        for (i = 1; i < arguments.length; ++i) {\n            var obj = arguments[i];\n            // Might add mode cases here, but the significat thing to note is that\n            // arguments that are undefined are ignored.\n            if (typeof obj === 'object') {\n                for (name in obj) {\n                    if (obj.hasOwnProperty(name)) {\n                        res[name] = obj[name];\n                    }\n                }\n            }\n        }\n        return res;\n    };\n    \n    /**\n     * Returns the path of the parent directory of the given path string or null.\n     * @private\n     * @param   {String} path The path to return the parent directory for.\n     * @returns {String} path of the parent directory of path or null.\n     */\n    exports.parentDirectory = function (path) {\n        var pathComponents = path.split('/');\n        pathComponents.pop();\n        return pathComponents.join('/');\n    };\n    \n    /**\n     * Returns the directory, filename, base file name and extension of the file at path.\n     * @private\n     * @param   {String} path The path to disect.\n     * @returns {Object}      An object in the form of { directory: \"path/to/file\", fileName: \"fileNameWithExtension\",\n     *                        baseName: \"fileNameWithoutExtension\", extension: \"extension\" || null }\n     */\n    exports.filePathComponents = function (path) {\n        var pathComponents = path.split('/');\n        var fileName = pathComponents.pop();\n        var nameComponents = fileName.split('.');\n        var extension = nameComponents.length > 1 ? nameComponents.pop() : null;\n        \n        return { directory: pathComponents.join('/'), fileName: fileName,\n                baseName: nameComponents.join('.'), extension: extension };\n    };\n    \n    /**\n     * Appends path elements, adding a slash between non-null components if they do not already start or end in a slash.\n     * NOTE: appending a '/' will ensure the path ends in a slash.\n     * @private\n     * @returns {the} appended path.\n     */\n    exports.appendPathElements = function () {\n        var elements = [];\n        var i, numArgs = arguments.length;\n        for (i = 0; i < numArgs; i++) {\n            var element = arguments[i];\n            if (typeof element === 'string' && element !== '') {\n                if (i !== 0 || element.length === 1) {\n                    // Remove any leading slash on elements after the first\n                    if (element.charAt(0) === '/') {\n                        element = element.slice(1);\n                    }\n                }\n                if (i !== (numArgs - 1)) {\n                    // Remove any trailing slash on elements other than the last one\n                    if (element.charAt(element.length - 1) === '/') {\n                        element = element.slice(0, element.length - 1);\n                    }\n                }\n                elements.push(element);\n            }\n        }\n        \n        return elements.join('/');\n    };\n    \n    /*jslint regexp: true*/\n    var pathRegEx = /^[^\\u0000-\\u001F\\u0022\\u002A\\u003A\\u003C\\u003E\\u003F\\u005C\\u007F]*[^\\u0000-\\u001F\\u0022\\u002A\\u002E\\u003A\\u003C\\u003E\\u003F\\u005C\\u007F]{1}$/;\n    /*jslint regexp: false*/\n    \n    /**\n     * Returns true if the given path is a valid path for a component or node.\n     * \n     * A path is valid if all of its components (derived by splitting it with the forward\n     * slash / as a separator) fulfill these criteria:\n     * - it must be 1 to 255 characters long\n     * - it must not end with a . (dot)\n     * - it must not contain any of the following characters\n     * o U+0022 \" QUOTATION MARK\n     * o U+002A * ASTERISK\n     * o U+002F / SOLIDUS\n     * o U+003A : COLON\n     * o U+003C < LESS-THAN SIGN\n     * o U+003E > GREATER-THAN SIGN\n     * o U+003F ? QUESTION MARK\n     * o U+005C \\ REVERSE SOLIDUS\n     * o The C0 controls, U+0000 through U+001F and U+007F\n     * @private\n     * @param   {String}  path\n     * @returns {Boolean}\n     */\n    exports.isValidPath = function (path) {\n        try {\n            if (path.length > 65535) {\n                return false;\n            }\n            var components = path.split('/');\n            if (!components || components.length === 0) {\n                return false;\n            }\n            var i, count = components.length;\n            for (i = 0; i < count; i++) {\n                var component = components[i];\n                if (component.length > 255 || !pathRegEx.test(components[i])) {\n                    return false;\n                }\n            }\n            \n            return true;\n        } catch (x) {\n            return false;\n        }\n        \n    };\n    \n    /**\n     * Does nothing, returns nothing\n     * @private\n     */\n    var noOp = exports.noOp = function () {\n    };\n    \n    /**\n     * Consume and discard the data from a stream.\n     * @private\n     * @param {Object}   stream   the stream to drain.\n     * @param {Function} callback if not undefined, called when stream is consumed\n     * @param {Function} data     if not undefined, called with received data\n     */\n    exports.consumeStream = function (stream, callback, data) {\n        stream.on('data', data || noOp);\n        stream.on('end', callback || noOp);\n    };\n    \n    /**\n     * Creates and returns a flat copy of the object passed in. This means that the returned object\n     * has the same keys and for each key exactly the same value as the original. This can be used\n     * to create copies of lookup tables.\n     * @private\n     * @param   {Object} obj\n     * @returns {Object}\n     */\n    exports.flatCopy = function (obj) {\n        var result = {};\n        var keys = Object.keys(obj);\n        var i, count = keys.length;\n        for (i = 0; i < count; i++) {\n            var key = keys[i];\n            result[key] = obj[key];\n        }\n        return result;\n    };\n    \n    /**\n     * Creates and returns a deep copy of the object utilizing JSON.\n     * @private\n     * @param   {Object}   obj\n     * @returns {Object}\n     */\n    exports.deepCopy = function (obj) {\n        return JSON.parse(JSON.stringify(obj));\n    };\n    \n    /**\n     * Does a deep compare of two objects.\n     * @private\n     * @param   {Object}  obj1               One object.\n     * @param   {Object}  obj2               The other object.\n     * @param   {Object}  propertiesToIgnore Optional. Object with properties that should not be compared.\n     * @returns {Boolean}\n     */\n    exports.objectsEqual = function (obj1, obj2, propertiesToIgnore) {\n        var checkedProperties = {};\n        var key, keys = Object.keys(obj1);\n        var i, count = keys.length;\n        \n        // Compare all properties of obj1 with the same property of obj2\n        for (i = 0; i < count; i++) {\n            key = keys[i];\n            if (!propertiesToIgnore || !propertiesToIgnore[key]) {\n                var val1 = obj1[key], val2 = obj2[key];\n                var type1 = typeof val1, type2 = typeof val2;\n                \n                if (type1 !== type2) {\n                    return false;\n                }\n                if (type1 === 'object') {\n                    if (!exports.objectsEqual(val1, val2, propertiesToIgnore)) {\n                        return false;\n                    }\n                } else if (val1 !== val2) {\n                    return false;\n                }\n            }\n            checkedProperties[key] = true;\n        }\n        \n        keys = Object.keys(obj2);\n        count = keys.length;\n        // Now check to see whether there are any properties in obj2 that were not in obj1\n        for (i = 0; i < count; i++) {\n            key = keys[i];\n            if (!checkedProperties[key]) {\n                return false;\n            }\n        }\n        \n        return true;\n    };\n   \n    // Source for uriParsePattern: http://www.ietf.org/rfc/rfc3986.txt (see Appendix B)\n    var uriParsePattern = new RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    /**\n     * Extract the path (query and fragment) from a URL.\n     * @private\n     * @param   {String} url the url\n     * @returns {Object}    { scheme, authority, path, query, fragment }\n     */\n    exports.parseURI = function (url) {\n        var matches =  url.match(uriParsePattern);\n        return {\n            scheme: matches[2],\n            authority: matches[4],\n            path: matches[5],\n            query: matches[7],\n            fragment: matches[9]\n        };\n    };\n    \n    // Parses the given href and returns a string that can be used to compare the endpoint\n    // of the uri with that of other uris by appending the well-known port number if the\n    // authority doesn't specify a port number. That way http://foo.bar is equal to http://foo.bar:80.\n    // Returns undefined if the uri doesn't specify a scheme or authority.\n    exports.endPointOf = function (href) {\n        var uriItems = exports.parseURI(href);\n        \n        var scheme = uriItems.scheme;\n        var authority = uriItems.authority;\n        var defaultPortNumber = scheme === 'https' ? 443 : (scheme === 'http' ? 80 : -1);\n        \n        var result;\n        \n        if (scheme && authority) {\n            result = (scheme + '://' + authority).toLowerCase();\n            if (defaultPortNumber >= 0 && authority.indexOf(':') < 0) {\n                result = result + ':' + defaultPortNumber;\n            }\n        }\n        \n        return result;\n    };\n   \n    /**\n     * Ensure that the href begins with a slash if it is a relative href\n     * @private\n     * @param   {String} href the href\n     * @returns {String}    the href\n     */\n    exports.ensureRelativeHrefStartsWithSlash = function (href) {\n        if (href) {\n            var uriItems = exports.parseURI(href);\n            var scheme = uriItems.scheme;\n            var authority = uriItems.authority;\n\n            if (!scheme && !authority) {\n                if (href.charAt(0) !== '/') {\n                    href = '/' + href;\n                }\n            }\n        }\n        return href;\n    };\n    \n    /*jslint regexp: true*/\n    var parseHeaderPattern = /^([^:]+):(.*)$/;\n    var whiteSpaceFilterPattern = /^\\s+|\\s+$/g;\n    /*jslint regexp: false*/\n    /**\n     * Parses the http headers in allHeadersAsText as per http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html and returns\n     * a dictionary with the lower-cased header fields as keys and the header values as values.\n     * @private\n     * @param   {String} allHeadersAsText \n     * @returns {Object}\n     */\n    exports.parseHeaders = function (allHeadersAsText) {\n        var i, headers = {};\n        var allHeaderLines = allHeadersAsText.split(/\\r?\\n/);\n        var field, value;\n        for (i = 0; i < allHeaderLines.length; ++i) {\n            var line = allHeaderLines[i];\n            if (line.length > 0) {\n                var charCodeOfFirstCharacter = line.charCodeAt(0);\n                \n                if (field && (charCodeOfFirstCharacter === 9 || charCodeOfFirstCharacter === 32)) {\n                    // If a line starts with a tab or a space then it is a continuation of a previous header\n                    headers[field] = headers[field] + ' ' + line.replace(whiteSpaceFilterPattern, '');\n                } else {\n                    // A new header\n                    var m = parseHeaderPattern.exec(line);\n                    if (m && m.length > 1) {\n                        field = m[1].toLowerCase();\n                        value = m[2] || '';\n                        value = value.replace(whiteSpaceFilterPattern, '');\n                        if (headers[field]) {\n                            headers[field] = headers[field] + ',' + value;\n                        } else {\n                            headers[field] = value;\n                        }\n                    }\n                }\n            }\n        }\n        return headers;\n    };\n    \n    /**\n     * Returns a time stamp in the form of the number of milliseconds since 1 January 1970 00:00:00 UTC.\n     * @param   {Boolean} roundDownToFullSeconds Whether to limit the resolutio to full seconds. Can be\n     *                                         useful if you want to use the timestamp to compare it\n     *                                         with the modification time stamps of files, which are\n     *                                         also limited to full seconds.\n     * @returns {Number}  The number of milliseconds since 1 January 1970 00:00:00 UTC.\n     */\n    exports.timeStamp = function (roundDownToFullSeconds) {\n        var ts = new Date().getTime();\n        if (roundDownToFullSeconds) {\n            ts = ts - (ts % 1000);\n        }\n        return ts;\n    };\n\n    exports.generateUuid = generateUuid;\n\n    return exports;\n});\n\n","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng;\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  //\n  // Moderately fast, high quality\n  if (typeof(require) == 'function') {\n    try {\n      var _rb = require('crypto').randomBytes;\n      _rng = _rb && function() {return _rb(16);};\n    } catch(e) {}\n  }\n\n  if (!_rng && _global.crypto && crypto.getRandomValues) {\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n    //\n    // Moderately fast, high quality\n    var _rnds8 = new Uint8Array(16);\n    _rng = function whatwgRNG() {\n      crypto.getRandomValues(_rnds8);\n      return _rnds8;\n    };\n  }\n\n  if (!_rng) {\n    // Math.random()-based (RNG)\n    //\n    // If all else fails, use Math.random().  It's fast, but is of unspecified\n    // quality.\n    var  _rnds = new Array(16);\n    _rng = function() {\n      for (var i = 0, r; i < 16; i++) {\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n      }\n\n      return _rnds;\n    };\n  }\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define('components/uuid/uuid',[],function() {return uuid;});\n  } else if (typeof(module) != 'undefined' && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else {\n    // Publish as global (in browsers)\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _global.uuid = uuid;\n  }\n}).call(this);\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* AdobeDCXError is a subclass of Error which defines the DCX specific errors.\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXError\n*/\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeDCXError',['require','exports','module'],function (require, exports, module) {\n    'use strict';\n\n    /**\n     * @constructor\n     * @alias module:AdobeDCXError\n     * @param {String} code            The error code string.\n     * @param {Str}    message         A string describing the error.\n     * @param {Error}  underlyingError Optional underlying error.\n     */\n    function AdobeDCXError(code, message, underlyingError) {\n        Error.call(this);\n        this.code = code;\n        this.message = '[' + code + '] ' + message;\n        this.underlyingError = underlyingError;\n    }\n    \n    AdobeDCXError.prototype = new Error();\n    AdobeDCXError.prototype.name = 'AdobeDCXError';\n    delete AdobeDCXError.prototype.stack;\n\n\n    //******************************************************************************\n    // Error Codes\n    //******************************************************************************\n    \n    /** Parsing JSON data has failed. */\n    AdobeDCXError.INVALID_JSON = 'INVALID_JSON';\n    /** Trying to modify an immutable object or property. */\n    AdobeDCXError.READ_ONLY = 'READ_ONLY';\n    /** The parameters passed to a function are not as expected. */\n    AdobeDCXError.INVALID_PARAMS = '';\n    /** Data is invalid. Usually this means that a document read from disk or from an http request is bad. */\n    AdobeDCXError.INVALID_DATA = 'INVALID_DATA';\n    /** Uniqueness constraint violated. */\n    AdobeDCXError.DUPLICATE_VALUE = 'DUPLICATE_VALUE';\n    /** Trying to invoke functionality that requires access to local storage when that access is not possible. */\n    AdobeDCXError.NO_LOCAL_STORAGE = 'NO_LOCAL_STORAGE';\n    /** An object is not in the expected state. */\n    AdobeDCXError.INVALID_STATE = 'INVALID_STATE';\n    /** Invalid operation on a deleted composite. */\n    AdobeDCXError.DELETED_COMPOSITE = 'DELETED_COMPOSITE';\n    /** Unexpected Response */\n    AdobeDCXError.UNEXPECTED_RESPONSE = 'UNEXPECTED_RESPONSE';\n    /** Network error */\n    AdobeDCXError.NETWORK_ERROR = 'NETWORK_ERROR';\n    /** Component(s) download failure -- see error.failedComponents for more details */\n    AdobeDCXError.COMPONENT_DOWNLOAD_ERROR = 'COMPONENT_DOWNLOAD_ERROR';\n    /** Component(s) upload failure -- see error.failedComponents for more details */\n    AdobeDCXError.COMPONENT_UPLOAD_ERROR = 'COMPONENT_UPLOAD_ERROR';\n    /** Update Conflict */\n    AdobeDCXError.UPDATE_CONFLICT = 'UPDATE_CONFLICT';\n    /** No composite. Possibly deleted. */\n    AdobeDCXError.NO_COMPOSITE = 'NO_COMPOSITE';\n    /** Respouce already Exists. */\n    AdobeDCXError.ALREADY_EXISTS = 'ALREADY_EXISTS';\n    /** HTTP session is in inactive state. */\n    AdobeDCXError.SERVICE_IS_INACTIVE = 'SERVICE_IS_INACTIVE';\n    /** Exceeds quota */\n    AdobeDCXError.EXCEEDS_QUOTA = 'EXCEEDS_QUOTA';\n    /** Unimplemented server request */\n    AdobeDCXError.NOT_IMPLEMENTED = 'NOT_IMPLEMENTED';\n    /** Retryable server error */\n    AdobeDCXError.RETRYABLE_SERVER_ERROR = 'RETRYABLE_SERVER_ERROR';\n    /** Timed-out request */\n    AdobeDCXError.TIMED_OUT = 'TIMED_OUT';\n    /** Unexpected failure, usually a problem acquiring a local resource such as a file */\n    AdobeDCXError.UNEXPECTED = 'UNEXPECTED';\n    /** Input stream terminated abnormaly */\n    AdobeDCXError.TERMINATED_INPUTSTREAM = 'TERMINATED_INPUTSTREAM';\n    /** Trying to access an asset from a different endpoint */\n    AdobeDCXError.WRONG_ENDPOINT = 'WRONG_ENDPOINT';\n    /** A file operation failed because the disk is full */\n    AdobeDCXError.OUT_OF_SPACE = 'ENOSPC';\n    // We use the POSIX error code returned by the file system so that we do not have to wrap/translate. \n    // If you change this make sure to add the proper wrapping/translation.\n    return AdobeDCXError;\n});\n","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng;\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  //\n  // Moderately fast, high quality\n  if (typeof(require) == 'function') {\n    try {\n      var _rb = require('crypto').randomBytes;\n      _rng = _rb && function() {return _rb(16);};\n    } catch(e) {}\n  }\n\n  if (!_rng && _global.crypto && crypto.getRandomValues) {\n    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n    //\n    // Moderately fast, high quality\n    var _rnds8 = new Uint8Array(16);\n    _rng = function whatwgRNG() {\n      crypto.getRandomValues(_rnds8);\n      return _rnds8;\n    };\n  }\n\n  if (!_rng) {\n    // Math.random()-based (RNG)\n    //\n    // If all else fails, use Math.random().  It's fast, but is of unspecified\n    // quality.\n    var  _rnds = new Array(16);\n    _rng = function() {\n      for (var i = 0, r; i < 16; i++) {\n        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n      }\n\n      return _rnds;\n    };\n  }\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define('components/dcx-js/src/components/uuid/uuid',[],function() {return uuid;});\n  } else if (typeof(module) != 'undefined' && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else {\n    // Publish as global (in browsers)\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _global.uuid = uuid;\n  }\n}).call(this);\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define, window, console, nodeRequire, Int8Array, ArrayBuffer, Blob */\n\n/**\n@class AdobeNetworkHTTPService\n\nManages an HTTPS session, handling authentication and retries.\n**/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\nif (typeof nodeRequire !== 'function') { var nodeRequire = require; }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeNetworkHTTPService',['require','exports','module','./AdobeDCXUtil','./AdobeDCXError','./AdobeDCXFS'],function (require, exports, module) {\n    'use strict';\n\n    var dcxUtil = require('./AdobeDCXUtil');\n    var AdobeDCXError = require('./AdobeDCXError');\n    var dcxFs = require('./AdobeDCXFS');\n\n    var XMLHttpRequest_;\n    var https_;\n    var url;\n    /*begin-node-only*/\n    if (typeof global !== 'undefined' && global.Buffer) { // tricky to know if we're in node because of all the redefines above\n        // Use Node https if running under node\n        https_ = nodeRequire('https');\n        url = nodeRequire('url');\n    } else {\n    /*end-node-only*/\n        // Use XHR\n        XMLHttpRequest_ = window.XMLHttpRequest;\n    /*begin-node-only*/\n    }\n    /*end-node-only*/\n\n    var merge = dcxUtil.merge;\n\n    var MAXDELAY = 5 * 60 * 1000; // 5 Minutes = The maximum time we allow a request to be delayed using the noSoonerThen property\n\n    function FileContent(filename) {\n        this.filename = filename;\n    }\n\n    /**\n     * @constructor\n     *\n     * Constructs a stream provider data source.\n     *\n     * The StreamProvider subclass or instance must implement either:\n     * getStream() that returns a node InputStream or\n     * getStreamAsync(callback) where\n     * callback(error, stream) is called back with either an error or an InputStream\n     */\n    function StreamProvider() {\n    }\n\n    /**\n     * @constructor\n     *\n     * Constructs a network service instance.\n     * @param {Function} [authCallback] Called when authentication fails. This callback is only called\n     *                                  once per expired/invalid token/cookie. The service will queue up\n     *                                  any further requests. <p>The client must obtain and set a new\n     *                                  authentication token or cookie and then call resume()</p>\n     *                                  <p>If not provided then the service will not try to manage\n     *                                  authentication.</p>\n     *                                  <p>Signature: authCallback(httpService)</p>\n     */\n    function AdobeNetworkHTTPService(authCallback) {\n        this._requestQueue = [];\n        this._requestsOutstanding = [];\n        this._rejectedAuths = [];   // to ensure one and ony one notification per auth token\n\n        this._authCallback = authCallback;\n        this._isActive = true;\n        this._waitingForAuthentication = false;\n\n        // This is being tagged onto requests to help avoid calling the auth callback multiple\n        // times. It changes every time the auth token gets modified or the service gets resumed.\n        this._currentAuthId = dcxUtil.generateUuid();\n\n        this._https = https_;\n        this._XMLHttpRequest = XMLHttpRequest_;\n        this._maxOutstanding = 5;\n    }\n\n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n\n    Object.defineProperties(AdobeNetworkHTTPService.prototype, {\n        /**\n         * An inactive service will error out with a AdobeDCXError.SERVICE_IS_INACTIVE error\n         * whenever a request is being made. Clients can set isActive to false when the user\n         * has explicitly logged out.\n         * @default true\n         * @type {Boolean}\n         */\n        isActive: {\n            get: function () {\n                return this._isActive;\n            },\n            set: function (value) {\n                var wasActive = this._isActive;\n                if (wasActive !== value) {\n                    this._isActive = value;\n                    if (!value) {\n                        this._authValue = undefined;\n                        this._checkQueue();\n                    }\n                }\n            }\n        },\n        /**\n         * If true then XHR instances will have the withCredentials property set which means that user\n         * credentials (stored in a cookie) will be used in cross origin requests.\n         * @type {Boolean}\n         */\n        crossOriginCredentials: {\n            get: function () {\n                return this._withCredentials;\n            },\n            set: function (value) {\n                this._withCredentials = value;\n            }\n        },\n        /**\n         * The maximum number of outstanding requests over this HTTP Service instance.\n         * The default value is 5, to stay below browser connection limits, but the limit\n         * can be increased if you have special circumstances that warrant it.\n         * Remember that there is no use in exceeding the bandwith capacity of your client\n         * or of the host, and that in error cases it's better to have half of your\n         * uploads complete than all of your uploads half complete.\n          */\n        maxOutstanding: {\n            get: function () {\n                return this._maxOutstanding;\n            },\n            set: function (value) {\n                this._maxOutstanding = value;\n                // increasing the value might allow queued requests to be sent now.\n                this._checkQueue();\n            }\n        }\n    });\n\n    // force use of xhr (generally for testing)\n    AdobeNetworkHTTPService.prototype._forceXhr = function (xhr) {\n        this._https = undefined;\n        this._XMLHttpRequest = xhr || XMLHttpRequest_ || nodeRequire('xhr2');\n    };\n\n    AdobeNetworkHTTPService.FileContent = FileContent;\n    AdobeNetworkHTTPService.StreamProvider = StreamProvider;\n\n    /**\n    Sets additional headers.\n\n    @param additionalHeaders An object containing key-value pairs for each additional header to supply.\n    */\n    AdobeNetworkHTTPService.prototype.setAdditionalHeaders = function (additionalHeaders) {\n        this._additionalHeaders = additionalHeaders || {};\n    };\n\n    /**\n    Sets additional options.\n\n    @param additionalOptions An object containing additional options to supply with each http request (in Node only).\n    */\n    AdobeNetworkHTTPService.prototype.setAdditionalNodeOptions = function (additionalOptions) {\n        this._additionalNodeOptions = additionalOptions;\n    };\n\n    /**\n    Sets the API key.\n\n    @param apiKey The apikey (string) to supply with each request.\n    */\n    AdobeNetworkHTTPService.prototype.setApiKey = function (apiKey) {\n        this._apiKey = apiKey;\n    };\n\n    /**\n    Sets the timeout value for requests.\n\n    @param timeout timeout value in ms or undefined if no timeout\n    */\n    AdobeNetworkHTTPService.prototype.setTimeout = function (timeout) {\n        this._timeout = timeout;\n    };\n\n    /**\n     * Sets the authentication token and resumes the service.\n     * @param {String} token The authentication token\n     */\n    AdobeNetworkHTTPService.prototype.setAuthToken = function (token) {\n        if (!token) {\n            this._authValue = undefined;\n            this._currentAuthId = dcxUtil.generateUuid();\n        } else {\n            this._authValue = 'Bearer ' + token;\n            this.resume();\n        }\n    };\n\n    /**\n     * Call this when you do not use an auth token for authentication and you need to let the\n     * service know that you have renewed the authentication cookie so that the service can\n     * resume to make requests.\n     */\n    AdobeNetworkHTTPService.prototype.resume = function () {\n        this._currentAuthId = dcxUtil.generateUuid();\n        this._waitingForAuthentication = false;\n        this._checkQueue();\n    };\n\n    /**\n     Sets callbacks before and after invocation hook.\n     (For testing)\n\n     @param before a hook to call before each http request is issued. Signature: before(req).\n     @param after  a hook to be called after each http request is initiated: Signature: after(req, xhr).\n     */\n\n    AdobeNetworkHTTPService.prototype.setRequestHooks = function (before, after) {\n        this._beforeHook = before;\n        this._afterHook = after;\n    };\n\n    /**\n     Issue a request.\n\n     By default, the request is a GET. The body param specifies the data, if any. The xhr object can't be returned synchronously\n     since the request may be queued or requeued.\n\n     @return               A request descriptor. Clients can attach a progress handler by setting the \"progress\"\n        property to a function progress(incr) that is passed the amount of data received in each chunk.\n     @params method        HTTP method\n     @params href          the URL\n     @params headers       headers\n     @param options        as in node's http.request call.\n     @param body           request body (string: filename, Buffer/ArrayBufferView/Blob: data, undefined/null: none)\n     @param options        Optional object capturing additional request options: { [responseType: type,] [noSoonerThen: time,] [reuseRequestDesc: requestDesc] }.\n                           Values for responseType are 'blob', 'text', 'buffer', 'arraybuffer', FileContent('filename'), StreamProvider, undefined\n                           noSoonerThen takes a JavaScript time value (e.g. Date.now())\n                           reuseRequestDesc is an inactive request descriptor previously obtained by a call to this method\n     @param callback       called when the response arrives. Signature: callback(error, xhr)\n     */\n    AdobeNetworkHTTPService.prototype.invoke = function (method, href, headers, body, options, callback) {\n        options = options || {};\n        var responseType = options.responseType;\n        if (responseType instanceof FileContent) {\n            if (!dcxFs.canUseFileSystem) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"No filesystem access\");\n            }\n        } else if (responseType === 'buffer') {\n            if (typeof Buffer !== 'function') {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"No Buffer class\");\n            }\n        } else if (responseType === 'blob') {\n            if (typeof Blob !== 'function') {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"No Blob class\");\n            }\n        } else if (responseType && responseType !== 'text' && responseType !== 'json' && responseType !== 'arraybuffer') {\n            // Note: StreamProvider falls through to here as an unsupported response type\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Unsupported response type\");\n        }\n\n        headers = merge({}, headers, this._additionalHeaders);\n        if (this._apiKey) {\n            headers['x-api-key'] = this._apiKey;\n        }\n\n        // Create the request descriptor\n        var requestDesc = {method: method, href: href, headers: headers, callback: callback, body: body, options: options};\n\n        // Check to see whether we are asked to reuse a previous request descriptor\n        var reuse = options.reuseRequestDesc;\n        if (reuse) {\n            // Ensure that the request descriptor is no longer in use:\n            if ((this._requestQueue.indexOf(reuse) >= 0) || (this._requestsOutstanding.indexOf(reuse) >= 0)) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Request descriptor still in use.\");\n            }\n\n            requestDesc = dcxUtil.merge(reuse, requestDesc);\n        }\n\n        this._doRequest(requestDesc);\n        return requestDesc;\n    };\n\n    /*\n     Internal routine to issue or queue the given request descriptor\n     */\n    AdobeNetworkHTTPService.prototype._doRequest = function (requestDesc) {\n        var self = this, xhr, reportedProgress = 0;\n        var responseStream, chunks = [];\n        var body = requestDesc.body;\n        var responseType = requestDesc.options.responseType;\n        var clientRequest;\n\n        // This function must get called at least once for every request when the request has\n        // either succeeded or failed.\n        // Calls the callback for the request, cleans up and checks the queue for the next request.\n        // Ensures that the callback for any given request is only called once.\n        function callCallback(error, response) {\n\n            if (responseStream) {\n                // We do not want to leak a file handle\n                responseStream.end();\n            }\n            var pos = self._requestsOutstanding.indexOf(requestDesc);\n            if (pos >= 0) {\n                self._requestsOutstanding.splice(pos, 1); // remove item\n            }\n            var callback = requestDesc.callback;\n            if (callback) {\n                requestDesc.callback = undefined;\n                if (error) {\n                    error.clientRequest = requestDesc.clientRequest;\n                    error.xhr = requestDesc.xhr;\n                }\n                if (error && error.code !== AdobeDCXError.SERVICE_IS_INACTIVE && !self._isActive) {\n                    error = new AdobeDCXError(AdobeDCXError.SERVICE_IS_INACTIVE, \"Service is now inactive\", error);\n                } else if (requestDesc.timedOut) {\n                    error = new AdobeDCXError(AdobeDCXError.TIMED_OUT, \"timed out request\", error);\n                }\n                callback(error, response);\n            }\n            if (self._isActive) {\n                self._checkQueue();\n            }\n        }\n\n        if (!this._isActive) {\n            return callCallback(new AdobeDCXError(AdobeDCXError.SERVICE_IS_INACTIVE, \"Network request in inactive state\"));\n        }\n\n        function checkResponse(response) {\n            var waitFinish = false;\n            var ended = false;\n            function fileWritten() {\n                // This covers the case of getting both 'close' and 'finish' events as well as incomplete responses\n                if (ended) {\n                    return;\n                }\n                ended = true;\n                responseStream = undefined;\n                return callCallback(undefined, response);\n            }\n            var pos = self._requestsOutstanding.indexOf(requestDesc);\n            if (pos < 0) {\n                self._checkQueue();\n                return;  // aborted\n            }\n            requestDesc.response = response;\n            if (response.statusCode === 401 && self._authCallback) {\n                self._requestsOutstanding.splice(pos, 1); // remove item\n                self._requestQueue.unshift(requestDesc);  // Back to the front of the queue\n                self._authFail(requestDesc);\n                // must nevertheless consume the response data\n                dcxUtil.consumeStream(response);\n            } else {\n                // TODO: retry logic for certain 5xx responses\n                var progress = requestDesc.progress;\n                if (response.statusCode === 200 || response.statusCode === 201 || response.statusCode === 202) {\n                    response.on('data', function (chunk) {\n                        if (chunk.length && progress) {\n                            progress(chunk.length);\n                        }\n                        if (!responseStream) {\n                            chunks.push(chunk);\n                        }\n                    });\n                    if (self._https && responseType instanceof FileContent) {\n                        responseStream = dcxFs.createWriteStream(responseType.filename);\n                        response.pipe(responseStream);\n                        waitFinish = true;\n                    }\n                } else {\n                    dcxUtil.consumeStream(response);\n                }\n                response.once('end', function () {\n                    var pos = self._requestsOutstanding.indexOf(requestDesc);\n                    if (pos < 0) {\n                        return; // aborted\n                    }\n                    self._requestsOutstanding.splice(pos, 1); // remove item\n                    self._checkQueue();\n                    if (waitFinish) { // We need to wait until the output stream is flushed and closed.\n                        return;\n                    }\n                    if (ended) {\n                        return;\n                    }\n                    ended = true;\n                    response.response = Buffer.concat(chunks);\n                    if (responseType === 'arraybuffer') {\n                        response.response = new ArrayBuffer(response.response);\n                    } else if (responseType === 'text') {\n                        response.response = response.response.toString();\n                    }\n                    return callCallback(undefined, response);\n                });\n                response.once('close', function () {\n                    if (ended) {\n                        return;\n                    }\n                    ended = true;\n                    return callCallback(new AdobeDCXError(AdobeDCXError.NETWORK_ERROR, \"incomplete response\"));\n                });\n                if (waitFinish) {\n                    responseStream.once('finish', fileWritten);\n                    responseStream.once('close', fileWritten); // for Node 0.8\n                }\n            }\n        }\n\n        function onReadyStateChange() {\n            var progress = requestDesc.progress;\n            if (progress && xhr.response) {\n                var len = xhr.response.length;\n                progress(len - reportedProgress);\n                reportedProgress = len;\n            }\n            if (xhr.readyState !== 4) { // 4 means DONE\n                return;\n            }\n            if (xhr.status === 0) {\n                return callCallback(new AdobeDCXError(AdobeDCXError.UNEXPECTED, \"XHR failure\"));\n            }\n            var pos = self._requestsOutstanding.indexOf(requestDesc);\n            if (pos < 0) {\n                self._checkQueue();\n                return;  // aborted\n            }\n            self._requestsOutstanding.splice(pos, 1);\n            if (xhr.status === 401 && self._authCallback) {\n                self._requestQueue.unshift(requestDesc);  // Back to the front of the queue\n                self._authFail(requestDesc);\n                self._checkQueue();\n            } else {\n                // TODO: retry logic for certain 5xx responses\n                requestDesc.xhr = xhr;\n                requestDesc.response = xhr;\n                xhr.statusCode = xhr.status;\n\n                // create header dictionary\n                xhr.headers = dcxUtil.parseHeaders(xhr.getAllResponseHeaders());\n\n                if (responseType instanceof FileContent) {\n                    var buf = xhr.response.response;\n                    dcxFs.writeFileAtomically(responseType.filename, buf, undefined, function (err) {\n                        if (err) {\n                            return callCallback(new AdobeDCXError(AdobeDCXError.UNEXPECTED, \"Can't create file\", err, xhr));\n                        }\n                        return callCallback(undefined, xhr);\n                    });\n                    return;\n                }\n\n                // XHR has no incremental progress for uploads; handle it now\n                if (progress && body) {\n                    progress(body.length || body.size);\n                }\n\n                return callCallback(undefined, xhr);\n            }\n        }\n\n        function streamData(stream) {\n            stream.pipe(clientRequest);\n            stream.on('error', function (error) {\n                // Notice that the code we are calling here is protected against getting called\n                // multiple times. I.e. only the first error triggers the abort and the callback.\n                self.abort(requestDesc);\n                return callCallback(new AdobeDCXError(AdobeDCXError.TERMINATED_INPUTSTREAM, \"Input stream terminated abnormally\", error));\n            });\n        }\n\n        if (this._waitingForAuthentication || this._requestsOutstanding.length >= this._maxOutstanding || requestDesc.options.noSoonerThen) {\n            this._requestQueue.push(requestDesc);\n            if (!this._waitingForAuthentication) {\n                this._checkQueue();\n            }\n        } else {\n            // We have a way of turning off the Authorization header, e.g. for redirects\n            var headers = requestDesc.headers;\n            if (headers.Authorization === null) {\n                delete headers.Authorization;\n            } else {\n                // Extremely important: never send an auth token over an unencrypted session!\n                if (!this._allowAuthTokenToBeSentInsecurely_DONT_USE_THIS_IN_PRODUCTION && requestDesc.href.indexOf('https:') !== 0) {\n                    return callCallback(new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Must not send auth token over unsecured connection\"));\n                }\n                if (this._authValue) {\n                    headers.Authorization = this._authValue;\n                }\n            }\n\n            if (this._currentAuthId) {\n                requestDesc.authId = this._currentAuthId;\n            }\n            if (this._beforeHook) {\n                this._beforeHook(requestDesc);\n            }\n\n            headers['X-Request-Id'] = dcxUtil.generateUuid();\n\n            if (this._https) {\n                this._requestsOutstanding.push(requestDesc);\n\n                var parsedUrl =  url.parse(requestDesc.href);\n                var opts = merge({}, this._additionalNodeOptions, parsedUrl);\n                opts.method = requestDesc.method || 'GET';\n                opts.headers = headers;\n\n                console.log(opts.method + ' ' + requestDesc.href);\n                clientRequest = this._https.request(opts, checkResponse);\n                requestDesc.clientRequest = clientRequest;\n                clientRequest.once('error', callCallback);\n                if (self._timeout) {\n                    clientRequest.setTimeout(self._timeout, function () {\n                        requestDesc.timedOut = true;\n                        clientRequest.abort();\n                    });\n                }\n\n                requestDesc.bytesSent = 0;\n                requestDesc.bytesReported = 0;\n\n                clientRequest.once('end', function () {\n                    if (requestDesc.progress) {\n                        // Node does not always call the write callback so that we can't assume\n                        // that we have reported all progress yet.\n                        var unreported = requestDesc.bytesSent - requestDesc.bytesReported;\n                        if (unreported > 0) {\n                            requestDesc.progress(unreported);\n                            requestDesc.bytesReported += unreported;\n                        }\n                    }\n                });\n\n                var doWrite = clientRequest.write;\n                clientRequest.write = function (chunk) {\n                    var length = chunk && chunk.length;\n\n                    if (length) {\n                        requestDesc.bytesSent += length;\n                    }\n                    return doWrite.call(clientRequest, chunk, function () {\n                        if (requestDesc.progress && chunk) {\n                            requestDesc.progress(length);\n                            requestDesc.bytesReported += length;\n                        }\n                    });\n                };\n\n                if (body instanceof FileContent) {\n                    var fileStream = dcxFs.createReadStream(body.filename);\n                    streamData(fileStream);\n                } else if (body instanceof StreamProvider) {\n                    if (body.getStream) {\n                        var dataStream = body.getStream();\n                        streamData(dataStream);\n                    } else if (body.getStreamAsync) {\n                        body.getStreamAsync(function (error, stream) {\n                            if (error) {\n                                self.abort(requestDesc);\n                                return callCallback(new AdobeDCXError(AdobeDCXError.TERMINATED_INPUTSTREAM, \"Error creating input stream\", error));\n                            }\n                            streamData(stream);\n                        });\n                    }\n                } else if (body instanceof Buffer) {\n                    clientRequest.write(body);\n                    clientRequest.end();\n                } else if (body instanceof ArrayBuffer) {\n                    clientRequest.write(new Buffer(new Int8Array(body)));\n                    clientRequest.end();\n                } else if (typeof body === 'string') {\n                    clientRequest.write(new Buffer(body, 'utf8'));\n                    clientRequest.end();\n                } else if (!body) {\n                    clientRequest.end();\n                } else {\n                    return callCallback(new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Invalid data type\"));\n                }\n\n                if (this._afterHook) {\n                    this._afterHook(requestDesc, clientRequest);\n                }\n            } else {\n                // convert to xhr-compatible data\n                if (body instanceof FileContent) {\n                    if (!dcxFs.canUseFileSystem) {\n                        return callCallback(new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Can't use FileContent without filesystem support\"));\n                    }\n                    dcxFs.readFile(body.filename, {}, function (err, buffer) {\n                        if (err) {\n                            return callCallback(err);\n                        }\n                        requestDesc.body = buffer;\n                        self._doRequest(requestDesc);\n                    });\n                    return;\n                }\n                if (typeof Buffer === 'function' && body instanceof Buffer) {\n                    requestDesc.body = body = new Int8Array(body);\n                }\n                this._requestsOutstanding.push(requestDesc);\n\n                xhr = new this._XMLHttpRequest();\n                xhr.open(requestDesc.method, requestDesc.href, /*async*/true);\n\n                if (this._withCredentials) {\n                    xhr.withCredentials = true;\n                }\n\n                if (responseType) {\n                    if (responseType instanceof FileContent) {\n                        xhr.responseType = 'buffer';\n                    } else {\n                        xhr.responseType = responseType;\n                    }\n                }\n\n                xhr.onreadystatechange = onReadyStateChange;\n\n                var header;\n                for (header in headers) {\n                    if (headers.hasOwnProperty(header)) {\n                        xhr.setRequestHeader(header, headers[header]);\n                    }\n                }\n                requestDesc.xhr = xhr;\n                if (self._timeout) {\n                    xhr.timeout = self._timeout;\n                    xhr.ontimeout = function () {\n                        requestDesc.timedOut = true;\n                        xhr.abort();\n                    };\n                }\n                if (body) {\n                    xhr.send(body);\n                } else {\n                    xhr.send();\n                }\n                if (this._afterHook) {\n                    this._afterHook(requestDesc, xhr);\n                }\n            }\n        }\n    };\n\n    /*\n    Internal routine to deal with authentication failure\n     */\n    AdobeNetworkHTTPService.prototype._authFail = function (requestDesc) {\n        if (this._authCallback) {\n            var badAuthId = requestDesc.authId;\n            if (this._rejectedAuths.indexOf(badAuthId) !== -1) {\n                return; // already notified about this failure\n            }\n            this._authValue = null;\n            this._waitingForAuthentication = true;\n            // Note that this won't work quite perfectly if _maxOutstanding is reduced\n            // while rejected auths are pending. But that isn't an expected use case and it's\n            // not a big deal if an authentication failure is re-notified.\n            if (this._rejectedAuths.unshift(badAuthId) > this._maxOutstanding) {\n                this._rejectedAuths.length = this._maxOutstanding;\n            }\n            this._authCallback(this);\n        }\n    };\n\n    /*\n     Internal routine to check the process the pending request queue\n     */\n    AdobeNetworkHTTPService.prototype._checkQueue = function () {\n        if (!this._isActive) {\n            // Cancel outstanding requests\n            var outstanding = this._requestsOutstanding;\n            this._requestsOutstanding = [];\n            outstanding.forEach(function (requestDesc) {\n                if (requestDesc.xhr) {\n                    requestDesc.xhr.abort();\n                }\n                if (requestDesc.clientRequest) {\n                    requestDesc.clientRequest.abort();\n                }\n                var callback = requestDesc.callback;\n                if (callback) {\n                    requestDesc.callback = undefined;\n                    var error = new AdobeDCXError(AdobeDCXError.SERVICE_IS_INACTIVE, \"Network request in inactive state\");\n                    callback(error);\n                }\n            });\n            // Cancel queued requests\n            var queue = this._requestQueue;\n            this._requestQueue = [];\n            queue.forEach(function (requestDesc) {\n                var error = new AdobeDCXError(AdobeDCXError.SERVICE_IS_INACTIVE, \"Network request in inactive state\");\n                var callback = requestDesc.callback;\n                if (callback) {\n                    requestDesc.callback = undefined;\n                    callback(error);\n                }\n            });\n            if (this._checkQueueTimerId) {\n                // Need to cancel existing timer\n                clearTimeout(this._checkQueueTimerId);\n                this._checkQueueTimerId = undefined;\n                this._checkQueueTimerWhen = undefined;\n            }\n            return;\n        }\n\n        // Iterate over the request queue repeatedly until we have reached the maximum number of requests, exhausted\n        // the request queue of executeable request or lost our auth token.\n        var when, now = Date.now();\n        var maxWhen = now + MAXDELAY;\n        var candidateRequestIndex = 0; // We start looking at the first request in our queue and increment this variable whenever we have to skip a request.\n        while (true) {\n            if (this._waitingForAuthentication || this._requestsOutstanding.length >= this._maxOutstanding || candidateRequestIndex >= this._requestQueue.length) {\n                break;\n            }\n            var candidate = this._requestQueue[candidateRequestIndex];\n            when = candidate.options.noSoonerThen || now;\n            // Protect against very long delays\n            if (when && when > maxWhen) {\n                when = candidate.options.noSoonerThen = maxWhen;\n            }\n            if (when <= now) {\n                // Remove the request from the queue\n                this._requestQueue.splice(candidateRequestIndex, 1);\n                candidate.options.noSoonerThen = undefined; // Important: Remove the time stamp so that we don't end up here again\n                this._doRequest(candidate);\n            } else {\n                // This request is not yet ready. We need to skip ahead to the next request\n                candidateRequestIndex++;\n            }\n        }\n\n        if (!this._waitingForAuthentication && this._requestsOutstanding.length < this._maxOutstanding && this._requestQueue.length > 0) {\n            // We have requests in the queue that are not yet ready to execute but we haven't yet filled our request pipeline.\n            // We find the next request that needs to be executed and schedule a timer for it.\n            var next, i, c = this._requestQueue.length;\n            for (i = 0; i < c; i++) {\n                when = this._requestQueue[i].options.noSoonerThen;\n                // Protect against very long delays\n                if (when && when > maxWhen) {\n                    when = this._requestQueue[i].options.noSoonerThen = maxWhen;\n                }\n                if (when) {\n                    next = next ? (next < when ? next : when) : when;\n                }\n            }\n            if (next && (!this._checkQueueTimerWhen || this._checkQueueTimerWhen > next)) {\n                if (this._checkQueueTimerId) {\n                    // Need to cancel existing timer\n                    clearTimeout(this._checkQueueTimerId);\n                }\n                this._checkQueueTimerWhen = next;\n                var self = this;\n                // Start a timer for the next cal to checkQueue\n                this._checkQueueTimerId = setTimeout(function () {\n                    self._checkQueueTimerWhen = undefined;\n                    self._checkQueueTimerId = undefined;\n                    self._checkQueue();\n                }, next - now);\n            }\n        }\n    };\n\n    AdobeNetworkHTTPService.prototype.abort = function (requestDesc) {\n        var pos = this._requestQueue.indexOf(requestDesc);\n        if (pos >= 0) {\n            this._requestQueue.splice(pos, 1);\n            return;\n        }\n        pos = this._requestsOutstanding.indexOf(requestDesc);\n        if (pos >= 0) {\n            this._requestsOutstanding.splice(pos, 1);\n            if (requestDesc.xhr) {\n                requestDesc.xhr.abort();\n            }\n            if (requestDesc.clientRequest) {\n                requestDesc.clientRequest.abort();\n            }\n            this._checkQueue();\n        }\n    };\n\n    AdobeNetworkHTTPService.prototype.abortAllWithToken = function (token) {\n        if (!token) {   // Oh no you don't!\n            return;\n        }\n        var i;\n        for (i = 0; i < this._requestQueue.length; ++i) {\n            if (this._requestQueue[i].token === token) {\n                this._requestQueue.splice(i, 1);\n                --i;\n            }\n        }\n        for (i = 0; i < this._requestsOutstanding.length; ++i) {\n            if (this._requestsOutstanding[i].token === token) {\n                var requestDesc = this._requestsOutstanding[i];\n                this._requestsOutstanding.splice(i, 1);\n                --i;\n                if (requestDesc.xhr) {\n                    requestDesc.xhr.abort();\n                }\n                if (requestDesc.clientRequest) {\n                    requestDesc.clientRequest.abort();\n                }\n            }\n        }\n        this._checkQueue();\n    };\n\n    return AdobeNetworkHTTPService;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* An AdobeDCXNode represents a node of a DCX manifest.\n*\n* <p>The constructor for AdobeDCXNode is private. Refer to {@link module:AdobeDCXBranch} to \n* learn how to access existing nodes or create new ones.\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXNode\n*/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCXNode',['require','exports','module','./AdobeDCXError','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError'),\n        dcxUtil = require('./AdobeDCXUtil');\n\n    /**\n     * @constructor\n     * @private\n     * @alias module:AdobeDCXNode\n     * @param {Object}  data     \n     * @param {Boolean}  readOnly\n     * @param {Boolean} isRoot\n     */\n    function AdobeDCXNode(data, readOnly, isRoot) {\n        if (data) {\n            this._setData(data);\n        } else {\n            this._data = {};\n        }\n        this._readOnly = readOnly;\n        this._isRoot = isRoot;\n    }\n    \n    var ROOT_PATH = '/';\n    AdobeDCXNode.ROOT_PATH = ROOT_PATH;\n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXNode.prototype, {\n        /**\n         * The id of the node. Must be a unique among the nodes of the composite.\n         * \n         * <p>Cannot be changed for a node that is part of a branch or element.</p>\n         * @type {String}\n         */\n        id: {\n            get: function () {\n                return this._data.id;\n            },\n            set: function (id) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (this._owner) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot change the id of a node that is part of a branch or element.');\n                } else if (typeof id !== 'string' || id === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a non-empty string.');\n                } else {\n                    this._data.id = id;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The name of the node.\n         * \n         * @type {String}\n         */\n        name: {\n            get: function () {\n                return this._data.name;\n            },\n            set: function (name) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof name !== 'string' && typeof name !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.name = name;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The type of the node.\n         * \n         * @type {String}\n         */\n        type: {\n            get: function () {\n                return this._data.type;\n            },\n            set: function (type) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof type !== 'string' && typeof type !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.type = type;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The relationship of the node to its parent node.\n         * \n         * @type {String}\n         */\n        relationship: {\n            get: function () {\n                return this._data.rel;\n            },\n            set: function (relationship) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof relationship !== 'string' && typeof relationship !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.rel = relationship;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The path property of the node.\n         * \n         * @type {String}\n         */\n        path: {\n            get: function () {\n                return this._isRoot ? ROOT_PATH : this._data.path;\n            },\n            set: function (path) {\n                if (path !== this.path) {\n                    if (this._readOnly) {\n                        throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                    } else if (this._isRoot) {\n                        throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot change the path of the root node.');\n                    } else if (path && !dcxUtil.isValidPath(path)) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a valid path or undefined.');\n                    } else {\n                        if (this._owner) {\n                            // We need to call the parent branch/element to update the path and handle\n                            // all neccessary updates to absolute paths\n                            this._owner._setPathOfNode(this, path || undefined);\n                        } else {\n                            this._data.path = path || undefined;\n                            this._parentPath = '';\n                        }\n                        this._setDirty();\n                    }\n                }\n            }\n        },\n        /**\n         * The absolute path of the parent of the node.\n         * \n         * @readonly\n         * @type {String}\n         */\n        parentPath: {\n            get: function () {\n                return this._parentPath;\n            },\n            set: function (path) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'parentPath is read-only.');\n            }\n        },\n        /**\n         * The absolute path of the node.\n         * \n         * @readonly\n         * @type {String}\n         */\n        absolutePath: {\n            get: function () {\n                var path = this.path;\n                if (this._isRoot) {\n                    return path;\n                }\n                return path && this._owner ? dcxUtil.appendPathElements(this._parentPath, path) : undefined;\n            },\n            set: function (path) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'absolutePath is read-only.');\n            }\n        },\n        /**\n         * Whether this node is the root of its branch or element.\n         * \n         * @readonly\n         * @type {Boolean}\n         */\n        isRoot: {\n            get: function () {\n                return this._isRoot;\n            },\n            set: function (isRoot) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'isRoot is read-only.');\n            }\n        }\n    });\n    \n    \n    //******************************************************************************\n    // Links\n    //******************************************************************************\n    \n    /**\n     * Returns the link with the given relationship as a JS object or undefined if the node\n     * doesn't have such a link.\n     * @param   {String} relationship The relationship of the link to the node.\n     * @returns {Object} The link with the given relationship as a JS object or undefined if \n     *                   the node doesn't have such a link.\n     */\n    AdobeDCXNode.prototype.getLink = function (relationship) {\n        if (typeof relationship !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"relationship\" must be a string');\n        }\n        return this._data._links ? this._data._links[relationship] : undefined;\n    };\n    \n    /**\n     * Sets the link with the given relationship to the given object.\n     * @param {Object} link         A JS object representing the link.\n     * @param {String} relationship The relationship of the link to the node.\n     *                              \n     */\n    AdobeDCXNode.prototype.setLink = function (link, relationship) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof link !== 'object') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"link\" must be an object.');\n        }\n        if (typeof relationship !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"relationship\" must be a string');\n        }\n        \n        var links = this._data._links;\n        if (!links) {\n            links = this._data._links = {};\n        }\n        \n        links[relationship] = link;\n        this._setDirty();\n    };\n    \n    /**\n     * Removes the link with the given relationship.\n     * @param {String} relationship The relationship of the link to the node.\n     *                                \n     */\n    AdobeDCXNode.prototype.removeLink = function (relationship) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof relationship !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"relationship\" must be a string');\n        }\n        \n        var links = this._data._links;\n        if (links) {\n            delete links[relationship];\n            if (Object.keys(links).length < 1) {\n                delete this._data._links;\n            }\n            this._setDirty();\n        }\n    };\n    \n    // TODO: implement getter for absolute index\n    \n    //******************************************************************************\n    // Custom Properties\n    //******************************************************************************\n    \n    \n    var reservedKeysOfRoot = { 'components': true, 'children': true, 'manifest-format-version': true,\n                        'id': true, 'name': true, 'type': true, 'state': true, 'local': true };\n    var reservedKeys = { 'components': true, 'children': true, 'rel': true, 'path': true,\n                        'id': true, 'name': true, 'type': true };\n    \n    /**\n     * Returns an array of non-standard keys that are present at this node.\n     * @returns {Array} An array of all non-standard property keys.\n     */\n    AdobeDCXNode.prototype.getCustomKeys = function () {\n        var customKeys = [];\n        var keys = Object.keys(this._data);\n        var i, c = keys.length;\n        for (i = 0; i < c; i++) {\n            var key = keys[i];\n            if (this._isRoot ? !reservedKeysOfRoot[key] : !reservedKeys[key]) {\n                customKeys.push(key);\n            }\n        }\n        return customKeys;\n    };\n    \n    /**\n     * Returns the object or value for the given key.\n     * @param   {String} key The custom key to look up.\n     * @returns {*} The value or object for the key.\n     */\n    AdobeDCXNode.prototype.getValue = function (key) {\n        if (typeof key !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"key\" must be a string');\n        }\n        if (key === 'children' || key === 'components') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Illegal key');\n        }\n        \n        return this._data[key];\n    };\n    \n    /**\n     * Returns the object or value for the given key.\n     * @param {String}   key   The custom key to set the value for.\n     * @param {*} The value or object.\n     */\n    AdobeDCXNode.prototype.setValue = function (key, value) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof key !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"key\" must be a string');\n        }\n        if (key === 'children' || key === 'components') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Illegal key');\n        }\n        \n        this._data[key] = value;\n        this._setDirty();\n    };\n    \n    /**\n     * Removes the object or value for the given key.\n     * @param {String} key The custom key to remove.\n     */\n    AdobeDCXNode.prototype.removeValue = function (key) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof key !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"key\" must be a string');\n        }\n        if (key === 'children' || key === 'components') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Illegal key');\n        }\n        \n        delete this._data[key];\n        this._setDirty();\n    };\n    \n    \n    //******************************************************************************\n    // Miscellaneous\n    //******************************************************************************\n    \n    /**\n     * Creates and returns a deep copy of the node sans any of its components or children.\n     * @returns {AdobeDCXNode} The copy.\n     */\n    AdobeDCXNode.prototype.copy = function () {\n        var copy = null;\n        var children = this._data.children;\n        var components = this._data.components;\n        try {\n            if (children) {\n                delete this._data.children;\n            }\n            if (components) {\n                delete this._data.components;\n            }\n            var newData = JSON.parse(JSON.stringify(this._data));\n            copy = new AdobeDCXNode(newData);\n        } finally {\n            if (children) {\n                this._data.children = children;\n            }\n            if (components) {\n                this._data.components = components;\n            }\n        }\n        return copy;\n    };\n\n    /**\n     * Returns false if any of the properties of the given node is different from the properties\n     * of this node. Recurses both data structures.\n     * @param   {AdobeDCXNode} node                          The node to compare with.\n     * @param   {Array}        [nodePropertiesToIgnore]      Optional. An object having the properties \n     *                                                       that should not be compared for node.\n     * @param   {Array}        [componentPropertiesToIgnore] Optional. An object having the properties \n     *                                                       that should not be compared for components.\n     * @returns {Boolean}\n     */\n    AdobeDCXNode.prototype.isEqualTo = function (node, nodePropertiesToIgnore, componentPropertiesToIgnore) {\n        return this._isEqual(this._data, node._data, dcxUtil.merge({ children: true, components: true }, nodePropertiesToIgnore), componentPropertiesToIgnore);\n    };\n    \n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n\n    /**\n     * Internal. Compares nodeData\n     * @private\n     * @param   {Object}  nodeData1                   \n     * @param   {Object}  nodeData2                   \n     * @param   {Object}  nodePropertiesToIgnore      \n     * @param   {Object}  componentPropertiesToIgnore \n     * @returns {Boolean}\n     */\n    AdobeDCXNode.prototype._isEqual = function (nodeData1, nodeData2, nodePropertiesToIgnore, componentPropertiesToIgnore) {\n        var i, array1, array2, count1, count2;\n        \n        if (!dcxUtil.objectsEqual(nodeData1, nodeData2, nodePropertiesToIgnore)) {\n            return false;\n        }\n        \n        // compare components\n        array1 = nodeData1.components;\n        array2 = nodeData2.components;\n        count1 = array1 ? array1.length : 0;\n        count2 = array2 ? array2.length : 0;\n        \n        if (count1 !== count2) {\n            return false;\n        }\n        if (count1) {\n            var component1, component2, j;\n            for (i = 0; i < count1; i++) {\n                // The components list is not ordered so we need to find the component by id\n                component1 = array1[i];\n                component2 = null;\n                for (j = 0; j < count1; j++) {\n                    if (component1.id === array2[j].id) {\n                        component2 = array2[j];\n                        break;\n                    }\n                }\n                if (!component2) {\n                    return false;\n                }\n                if (!dcxUtil.objectsEqual(component1, component2, componentPropertiesToIgnore)) {\n                    return false;\n                }\n            }\n        }\n        \n        // compare children\n        array1 = nodeData1.children;\n        array2 = nodeData2.children;\n        count1 = array1 ? array1.length : 0;\n        count2 = array2 ? array2.length : 0;\n        \n        if (count1 !== count2) {\n            return false;\n        }\n        if (count1) {\n            for (i = 0; i < count1; i++) {\n                if (!this._isEqual(array1[i], array2[i], nodePropertiesToIgnore, componentPropertiesToIgnore)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    };\n    \n    /**\n     * Verifies and sets the new data. Throws if invalid data.\n     * @private\n     * @param   {Object} data \n     * @returns {Error}\n     */\n    AdobeDCXNode.prototype._setData = function (data) {\n        \n        var err = this._verify(data);\n        if (err === null) {\n            this._data = data;\n            return this;\n        }\n        throw err;\n    };\n    \n    /**\n     * Returns an error if the passed in data is not a valid node. Returns null if everything is OK.\n     * @private\n     * @param   {Object} data \n     * @returns {Error} \n     */\n    AdobeDCXNode.prototype._verify = function (data) {\n        if (typeof data.id !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Node is missing an id of type string\");\n        }\n        \n        return null;\n    };\n    \n    /**\n     * Sets the dirty flag on the node's branch or element (if set)\n     * @private\n     */\n    AdobeDCXNode.prototype._setDirty = function () {\n        if (this._owner) {\n            this._owner._setDirty();\n        }\n    };\n    \n    return AdobeDCXNode;\n});\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* An AdobeDCXComponent represents a component of a DCX manifest.\n*\n* <p>The constructor for AdobeDCXComponent is private. Refer to {@link module:AdobeDCXBranch} to \n* learn how to access existing components or create new ones.\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXComponent\n*/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCXComponent',['require','exports','module','./AdobeDCXError','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError'),\n        dcxUtil = require('./AdobeDCXUtil');\n\n    /**\n     * The constructor for AdobeDCXComponent is private. Component instances are getting instantiated \n     * on an as needed-bases.\n     * @private\n     * @alias module:AdobeDCXComponent\n     * @param {Object}  data     \n     * @param {Boolean} readOnly \n     */\n    function AdobeDCXComponent(data, readOnly) {\n        if (data) {\n            this._setData(data);\n        } else {\n            this._data = {};\n        }\n        this._readOnly = readOnly;\n    }\n    \n    var STATES = {\n        unmodified: 'unmodified',\n        modified: 'modified',\n        pendingDelete: 'pendingDelete',\n        committedDelete: 'committedDelete'\n    };\n    AdobeDCXComponent.STATES = STATES;\n    \n    /** Holds the results of one or more successful component uploads. */\n    function UploadResults(id) {\n        this.compositeId = id;\n        this.records = {}; // map: originalComponentId : UploadRecord\n    }\n    AdobeDCXComponent._UploadResults = UploadResults;\n        \n    /** Holds the results of an individual successful component upload. \n    Used as value in the results map of UploadResults. */\n    function UploadRecord(id, etag, version, md5, length, type) {\n        this.id = id;\n        this.etag = etag;\n        this.version = version;\n        this.md5 = md5;\n        this.length = length;\n        this.type = type;\n    }\n    AdobeDCXComponent._UploadRecord = UploadRecord;\n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXComponent.prototype, {\n        /**\n         * The id of the component. Must be a unique among the components of the composite.\n         * \n         * <p>Cannot be changed for a component that is part of a branch.</p>\n         * @type {String}\n         */\n        id: {\n            get: function () {\n                return this._data.id;\n            },\n            set: function (id) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (this._owner) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot change the id of a component that is part of a branch or element.');\n                } else if (typeof id !== 'string' || id === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a non-empty string.');\n                } else {\n                    this._data.id = id;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The name of the component.\n         * \n         * @type {String}\n         */\n        name: {\n            get: function () {\n                return this._data.name;\n            },\n            set: function (name) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof name !== 'string' && typeof name !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.name = name;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The type of the component.\n         * \n         * @type {String}\n         */\n        type: {\n            get: function () {\n                return this._data.type;\n            },\n            set: function (type) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof type !== 'string' || type === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a non-empty string.');\n                } else {\n                    this._data.type = type;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The path of the component.\n         * \n         * @type {String}\n         */\n        path: {\n            get: function () {\n                return this._data.path;\n            },\n            set: function (path) {\n                if (this._data.path !== path) {\n                    if (this._readOnly) {\n                        throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                    } else if (!dcxUtil.isValidPath(path)) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a valid path.');\n                    } else {\n                        if (this._owner) {\n                            // We need to call the owner to update the path and handle\n                            // all neccessary updates to absolute paths\n                            this._owner._core._setPathOfComponent(this, path);\n                        } else {\n                            this._data.path = path;\n                            this._parentPath = '';\n                        }\n                        this._setDirty();\n                    }\n                }\n            }\n        },\n        /**\n         * The absolute path of the parent of the component.\n         * \n         * @readonly\n         * @type {String}\n         */\n        parentPath: {\n            get: function () {\n                return this._parentPath;\n            },\n            set: function (path) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'parentPath is read-only.');\n            }\n        },\n        /**\n         * The absolute path of the component.\n         * \n         * @readonly\n         * @type {String}\n         */\n        absolutePath: {\n            get: function () {\n                return (this._data.path && this._owner) ? dcxUtil.appendPathElements(this._parentPath, this._data.path) : undefined;\n            },\n            set: function (path) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'absolutePath is read-only.');\n            }\n        },\n        /**\n         * The relationship of the component to its parent node and its sibling components.\n         * \n         * @type {String}\n         */\n        relationship: {\n            get: function () {\n                return this._data.rel;\n            },\n            set: function (relationship) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof relationship !== 'string' && typeof relationship !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.rel = relationship;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The edit state of the component.\n         * \n         * @readonly\n         * @private\n         * @type {String}\n         */\n        state: {\n            get: function () {\n                return this._data.state;\n            },\n            set: function (state) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof state !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else if (!STATES.hasOwnProperty(state)) {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS,\n                                            'State must be \"modified\", \"unmodified\", \"pendingDelete\", or \"committedDelete\".');\n                } else {\n                    this._data.state = state;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The etag of the component.\n         * \n         * @readonly\n         * @private\n         * @type {String}\n         */\n        etag: {\n            get: function () {\n                return this._data.etag;\n            },\n            set: function (etag) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof etag !== 'string' && typeof etag !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.etag = etag;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The md5 of the component.\n         * \n         * @readonly\n         * @private\n         * @type {String}\n         */\n        md5: {\n            get: function () {\n                return this._data.md5;\n            },\n            set: function (md5) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof md5 !== 'string' && typeof md5 !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.md5 = md5;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The version of the component.\n         * \n         * @readonly\n         * @private\n         * @type {String}\n         */\n        version: {\n            get: function () {\n                return this._data.version;\n            },\n            set: function (version) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof version !== 'undefined' && typeof version !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    this._data.version = version;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The content length of the component.\n         * \n         * @readonly\n         * @type {Integer}\n         */\n        length: {\n            get: function () {\n                return this._data.length;\n            },\n            set: function (length) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof length !== 'number' && typeof length !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a number or undefined.');\n                } else {\n                    this._data.length = length;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The width property of the component.\n         * \n         * @type {Integer}\n         */\n        width: {\n            get: function () {\n                return this._data.width;\n            },\n            set: function (width) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof width !== 'number' && typeof width !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a number or undefined.');\n                } else {\n                    this._data.width = width;\n                    this._setDirty();\n                }\n            }\n        },\n        /**\n         * The height property of the component.\n         * \n         * @type {Integer}\n         */\n        height: {\n            get: function () {\n                return this._data.height;\n            },\n            set: function (height) {\n                if (this._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof height !== 'number' && typeof height !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a number or undefined.');\n                } else {\n                    this._data.height = height;\n                    this._setDirty();\n                }\n            }\n        }\n    });\n    \n    \n    //******************************************************************************\n    // Custom Properties\n    //******************************************************************************\n    \n    \n    var reservedKeys = { 'name': true, 'id': true, 'state': true, 'path': true,\n                        'rel': true, 'type': true, 'etag': true,\n                        'length': true, 'version': true, 'md5': true,\n                        'width': true, 'height': true };\n    \n    /**\n     * Returns an array of custom keys that are present at this component. Custom keys are manifest\n     * properties that are not considered standard DCX properties.\n     * @returns {Array}\n     */\n    AdobeDCXComponent.prototype.getCustomKeys = function () {\n        var customKeys = [];\n        var keys = Object.keys(this._data);\n        var i, c = keys.length;\n        for (i = 0; i < c; i++) {\n            var key = keys[i];\n            if (!reservedKeys[key]) {\n                customKeys.push(key);\n            }\n        }\n        return customKeys;\n    };\n    \n    /**\n     * Returns the object or value for the given custom key.\n     * @param   {String} key The custom key to look up.\n     * @returns {*}\n     */\n    AdobeDCXComponent.prototype.getValue = function (key) {\n        if (typeof key !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"key\" must be a string');\n        }\n        \n        return this._data[key];\n    };\n    \n    /**\n     * Sets the object or value for the given custom key.\n     * @param {String} key   The custom key to set the value for.\n     * @param {*}      value The value to set.\n     */\n    AdobeDCXComponent.prototype.setValue = function (key, value) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof key !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"key\" must be a string');\n        }\n        \n        this._data[key] = value;\n        this._setDirty();\n    };\n    \n    /**\n     * Removes the object or value for the given custom key.\n     * @param {String} key The custom key to remove.\n     */\n    AdobeDCXComponent.prototype.removeValue = function (key) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof key !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"key\" must be a string');\n        }\n        \n        delete this._data[key];\n        this._setDirty();\n    };\n    \n    \n    //******************************************************************************\n    // Links\n    //******************************************************************************\n    \n    /**\n     * Returns the link with the given relationship as a JS object or undefined if the component\n     * doesn't have such a link.\n     * @param   {String} relationship The relationship of the link to the component.\n     * @returns {Object} The link object with the given relationship as a JS object or undefined if \n     *                   the component doesn't have such a link.\n     */\n    AdobeDCXComponent.prototype.getLink = function (relationship) {\n        if (typeof relationship !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"relationship\" must be a string');\n        }\n        return this._data._links ? this._data._links[relationship] : undefined;\n    };\n    \n    /**\n     * Sets the link with the given relationship to the given object.\n     * @param {Object} link         A JS object representing the link.\n     * @param {String} relationship The relationship of the link to the component.\n     *                              \n     */\n    AdobeDCXComponent.prototype.setLink = function (link, relationship) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof link !== 'object') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"link\" must be an object.');\n        }\n        if (typeof relationship !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"relationship\" must be a string');\n        }\n        \n        var links = this._data._links;\n        if (!links) {\n            links = this._data._links = {};\n        }\n        \n        links[relationship] = link;\n        this._setDirty();\n    };\n    \n    /**\n     * Removes the link with the given relationship.\n     * @param {String} relationship The relationship of the link to the component.\n     *                                \n     */\n    AdobeDCXComponent.prototype.removeLink = function (relationship) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (typeof relationship !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"relationship\" must be a string');\n        }\n        \n        var links = this._data._links;\n        if (links) {\n            delete links[relationship];\n            if (Object.keys(links).length < 1) {\n                delete this._data._links;\n            }\n            this._setDirty();\n        }\n    };\n    \n    \n    //******************************************************************************\n    // Miscellaneous\n    //******************************************************************************\n    \n    /**\n     * Returns false if any of the properties of the given component is different from the properties\n     * of this component. Recurses both data structures.\n     *\n     * @example\n     * if (!component.isEqualTo(otherComponent, { unimportantProperty: true })) {\n     *      // The components have different properties\n     * }\n     * @param   {AdobeDCXComponent} component            The component to compare with.\n     * @param   {Object}            [propertiesToIgnore] An object having the properties that should \n     *                                                 not be compared.\n     * @returns {Boolean}\n     */\n    AdobeDCXComponent.prototype.isEqualTo = function (component, propertiesToIgnore) {\n        return dcxUtil.objectsEqual(this._data, component._data, propertiesToIgnore);\n    };\n    \n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n    \n    /**\n     * Verifies and sets the new data. Throws if invalid data.\n     * @private\n     * @param   {Object}   data \n     * @returns {AdobeDCXComponent} \n     */\n    AdobeDCXComponent.prototype._setData = function (data) {\n        \n        var err = this._verify(data);\n        if (err === null) {\n            this._data = data;\n            return this;\n        }\n        throw err;\n    };\n    \n    /**\n     * Sets the dirty flag on the node's branch (if set)\n     * @private\n     */\n    AdobeDCXComponent.prototype._setDirty = function () {\n        if (this._owner) {\n            this._owner._setDirty();\n        }\n    };\n    \n    /**\n     * Returns an error if the passed in data is not a valid component. Returns null if everything is OK.\n     * @private\n     * @param   {Object} data \n     * @returns {Error}  \n     */\n    AdobeDCXComponent.prototype._verify = function (data) {\n        if (typeof data.id !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Component is missing an id of type string\");\n        }\n        \n        return null;\n    };\n    \n    return AdobeDCXComponent;\n});\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n * Internal wrapper for higher-level file system functionality\n * @private\n */\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeDCXFS',['require','exports','module','./AdobeDCXError','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeDCXError = require('./AdobeDCXError');\n    var dcxUtil = require('./AdobeDCXUtil');\n    var _fs;\n    \n    exports.canUseFileSystem = false;\n    \n    /**\n     * Sets the fs object.\n     * @private\n     * @param {Object} fs An object implementing the v0.8.22 interface of nodejs' fs. See: http://nodejs.org/docs/v0.8.22/api/fs.html\n     */\n    exports._setFS = function (fs) {\n        _fs = fs;\n        exports.canUseFileSystem = fs ? true : false;\n    };\n    \n    /**\n     * Ensures that the directory at path exists. Creating it and its parent directories if necessary.\n     * @private\n     * @param {String}   path     The path for the directory.\n     * @param {Function} callback Gets called when the function completes. Signature: function (error)\n     */\n    exports.ensureDirectoryExists = function (path, callback) {\n        var checkMkdirResult = function (error) {\n            if (error && error.code === 'EEXIST') {\n                callback();\n            } else {\n                callback(error);\n            }\n        };\n        var existsCallback = function (exists) {\n            if (exists) {\n                callback();\n            } else {\n                // first ensure that the parent path exists\n                var parentPath = dcxUtil.parentDirectory(path);\n                if (parentPath) {\n                    exports.ensureDirectoryExists(parentPath, function (error) {\n                        if (error) {\n                            callback(error);\n                        } else {\n                            _fs.mkdir(path, checkMkdirResult);\n                        }\n                    });\n                } else {\n                    _fs.mkdir(path, checkMkdirResult);\n                }\n            }\n        };\n        if (path) {\n            _fs.exists(path, existsCallback);\n        } else {\n            existsCallback(true);\n        }\n    };\n    \n    /**\n     * Returns a temp file path at the given directoryPath that is guaranteed not to exist.\n     * @private\n     * @param {String}   directoryPath The path for the directory (must end with /).\n     * @param {Function} callback      Gets called when the function completes. Signature: function (tempPath)\n     */\n    exports.getTempFilePathAt = function (directoryPath, callback) {\n        var recursivelyGetTempFilePath = function () {\n            var tempPath = directoryPath + dcxUtil.generateUuid();\n            exports.exists(tempPath, function (exists) {\n                if (exists) {\n                    recursivelyGetTempFilePath();\n                } else {\n                    callback(tempPath);\n                }\n            });\n        };\n        \n        recursivelyGetTempFilePath();\n    };\n    \n    /**\n     * Determines if the item at path exists.\n     * @private\n     * @param {String}   path     The file or directory to check existence of.\n     * @param {Function} callback Gets called on completion. Signature: function (exists)\n     */\n    exports.exists = function (path, callback) {\n        _fs.exists(path, callback);\n    };\n    \n    /**\n     * Deletes the file at path if it exists.\n     * @private\n     * @param {String}   path     The file to delete.\n     * @param {Function} callback Gets called on completion. Signature: function (error)\n     */\n    exports.deleteFile = function (path, callback) {\n        _fs.unlink(path, function (error) {\n            if (!error || error.code === 'ENOENT') {\n                // Ignore the error if the file didn't exist.\n                callback();\n            } else {\n                callback(error);\n            }\n        });\n    };\n    \n    /**\n     * Reads the contents of the file at path.\n     * @private\n     * @param {String}   path     The file to read.\n     * @param {String}   encoding Optional. If provided it is used to decode the data and turn it into a string.\n     * @param {Function} callback\n     */\n    exports.readFile = function (path, encoding, callback) {\n        _fs.readFile(path, encoding, callback);\n    };\n    \n    /**\n     * Writes the provided data to the file at path, creating the file and any parent directories if necessary.\n     * @private\n     * @param {String}   path     The file to write to.\n     * @param {String}   data     The data to write.\n     * @param {String}   encoding Optional. If provided it is used to encode the data.\n     * @param {Function} callback \n     */\n    exports.writeFile = function (path, data, encoding, callback) {\n        var parentPath = dcxUtil.parentDirectory(path);\n        exports.ensureDirectoryExists(parentPath, function (error) {\n            if (error) {\n                callback(error);\n            } else {\n                _fs.writeFile(path, data, encoding, callback);\n            }\n        });\n    };\n    \n    /**\n     * Writes the provided data to the file at path, creating the file and any parent directories \n     * if necessary. Writes to a temp file first and moves it into place on success.\n     * @private\n     * @param {String}   path     The file to write to.\n     * @param {String}   data     The data to write.\n     * @param {String}   encoding Optional. If provided it is used to encode the data.\n     * @param {Function} callback \n     */\n    exports.writeFileAtomically = function (path, data, encoding, callback) {\n        \n        var parentPath = dcxUtil.parentDirectory(path);\n        exports.ensureDirectoryExists(parentPath, function (error) {\n            if (error) {\n                callback(error);\n            } else {\n                exports.getTempFilePathAt(parentPath + '/', function (tempFilePath) {\n                    _fs.writeFile(tempFilePath, data, encoding, function (error) {\n                        if (error) {\n                            callback(error);\n                        } else {\n                            // Notice: According to the documentation of node fs rename is an\n                            // asynchronous implementation of rename(2). That in turn is suppposed\n                            // to handle replacements atomically:\n                            // \"If newpath already exists, it will be atomically replaced ..., so \n                            // that there is no point at which another process attempting to access \n                            // newpath will find it missing.\"\n                            _fs.rename(tempFilePath, path, callback);\n                        }\n                    });\n                });\n            }\n        });\n    };\n    \n    /**\n     * Returns a writeable stream.\n     * @private\n     * @param   {String} path    The file to write.\n     * @param   {Object} options See node's fs.createWriteStream\n     * @returns {Object} \n     */\n    exports.createWriteStream = function (path, options) {\n        return _fs.createWriteStream(path, options);\n    };\n    \n    /**\n     * Returns a readable stream.\n     * @private\n     * @param   {String} path    The file to write.\n     * @param   {Object} options See node's fs.createReadStream\n     * @returns {Object} \n     */\n    exports.createReadStream = function (path, options) {\n        return _fs.createReadStream(path, options);\n    };\n    \n    /**\n     * Moves the file or directory at path to newPath. Overwrites any existing file at newPath.\n     * Creates any necessary parent directories. Both paths must be on the same volume.\n     * @private\n     * @param {String}   path     The file or directory to move.\n     * @param {String}   newPath  The new path of the file or directory.\n     * @param {Boolean}  touch    Whether to update the mod date of the file.\n     * @param {Function} callback Gets called on completion. Signature: function (error)\n     */\n    exports.move = function (path, newPath, touch, callback) {\n        var parentPath = dcxUtil.parentDirectory(newPath);\n        exports.ensureDirectoryExists(parentPath, function (error) {\n            if (error) {\n                callback(error);\n            } else {\n                if (touch) {\n                    // As per spec node.js' utimes() should accept a Date object, however the\n                    // older node version used in the panels doesn't. So we just pass in a Unix\n                    // time stamps as per http://stackoverflow.com/questions/20876407/what-format-is-used-for-nodejs-fs-utimes\n                    var timeStamp = new Date().getTime() / 1000;\n                    _fs.utimes(path, timeStamp, timeStamp, function (error) {\n                        if (error) {\n                            callback(error);\n                        } else {\n                            _fs.rename(path, newPath, callback);\n                        }\n                    });\n                    \n                } else {\n                    _fs.rename(path, newPath, callback);\n                }\n            }\n        });\n    };\n    \n    /**\n     * Gets info for a file or directory.\n     * @private\n     * @param {String}   path     The file or directory to get info for.\n     * @param {Function} callback Gets called on completion. Signature: function (error, info)\n     *                            See http://nodejs.org/docs/v0.8.22/api/fs.html#fs_class_fs_stats\n     */\n    exports.info = function (path, callback) {\n        _fs.stat(path, callback);\n    };\n    \n    /**\n     * Gets the list of items in a directory along with info for each item.\n     * @private\n     * @param {String}   path     The file or directory to get info for.\n     * @param {Function} callback Gets called on completion. Signature: function (error, listing). listing is an array of objects\n     *                            in the form name: fileName, info: fileInfo. See http://nodejs.org/docs/v0.8.22/api/fs.html#fs_class_fs_stats\n     */\n    exports.directoryListing = function (path, callback) {\n        var requestCount, listing = [];\n        var asyncError;\n        \n        var getInfo = function (fileName) {\n            _fs.stat(path + '/' + fileName, function (error, info) {\n                if (!error) {\n                    try {\n                        listing.push({name: fileName, info: info});\n                        requestCount--;\n                    } catch (x) {\n                        error = x;\n                    }\n                }\n                if (error) {\n                    if (!asyncError) {\n                        asyncError = error;\n                        callback(error);\n                    }\n                } else if (requestCount === 0) {\n                    callback(undefined, listing);\n                }\n            });\n        };\n        \n        _fs.readdir(path, function (error, files) {\n            if (!error) {\n                try {\n                    var i, count = files.length;\n                    requestCount = count;\n                    for (i = 0; i < count; i++) {\n                        getInfo(files[i]);\n                    }\n                } catch (x) {\n                    error = x;\n                }\n            }\n            if (error) {\n                callback(error);\n            } else if (requestCount === 0) {\n                callback(undefined, []);\n            }\n        });\n    };\n    \n    /**\n    Gets the list of item names in a directory.\n    \n    @param path The file or directory to get the list for for.\n    \n    @param callback Gets called on completion. Signature: function (error, names).\n    */\n    /*\n    exports.itemsInDirectory = function (path, callback) {\n        _fs.readdir(path, callback);\n    };\n    */\n    \n    /**\n     * Deletes a directory and all of its contents recursively.\n     * @private\n     * @param {String}   path     The file or directory to get delete.\n     * @param {Function} callback Gets called on completion. Signature: function (error).\n     */\n    exports.deleteDirectory = function (path, callback) {\n        // delete the empty directory\n        var finalDelete = function () {\n            try {\n                _fs.rmdir(path, callback);\n            } catch (x) {\n                callback(x);\n            }\n        };\n        \n        // to coordinate all requests\n        var asynchError, numItemsLeft;\n        \n        // gets called when one item is either done or has failed\n        var oneDown = function (error) {\n            if (error && !asynchError) {\n                asynchError = error;\n            }\n            numItemsLeft--;\n            if (numItemsLeft < 1) {\n                if (asynchError) {\n                    callback(asynchError);\n                } else {\n                    finalDelete();\n                }\n            }\n        };\n        \n        // Deletes single item (file or directory).\n        // Gets called once per item in path\n        var deleteItem = function (name) {\n            var itemPath = path + '/' + name;\n            _fs.unlink(itemPath, function (error) {\n                try {\n                    if (error) {\n                        // try to delete as directory\n                        exports.deleteDirectory(itemPath, function (error) {\n                            oneDown(error);\n                        });\n                    } else {\n                        oneDown();\n                    }\n                } catch (x) {\n                    oneDown(x);\n                }\n            });\n        };\n        \n        _fs.readdir(path, function (error, names) {\n            if (!error) {\n                try {\n                    var count = names.length;\n                    if (count < 1) {\n                        // Directory is empty\n                        finalDelete();\n                    } else {\n                        var i;\n                        numItemsLeft = count;\n                        for (i = 0; i < count; i++) {\n                            deleteItem(names[i]);\n                        }\n                    }\n                } catch (x) {\n                    error = x;\n                }\n            }\n            if (error) {\n                callback(error);\n            }\n        });\n    };\n    \n    /** private -- assumes that all necessary directories exist */\n    /**\n     * @private\n     * @param {String}   path       \n     * @param {String}   targetPath \n     * @param {Function} callback   \n     */\n    var _copyFile = function (path, targetPath, callback) {\n        try {\n            var tempPath = targetPath + dcxUtil.generateUuid();\n            // create temp file\n            var tempFile = _fs.createWriteStream(tempPath);\n            var sourceFile = _fs.createReadStream(path);\n            // copy contents\n            sourceFile.on('end', function () {\n                // move to destination\n                _fs.rename(tempPath, targetPath, callback);\n            });\n            sourceFile.pipe(tempFile);\n        } catch (error) {\n            callback(error);\n        }\n    };\n    \n    /**\n     * Copies the file at path to targetPath. Overwrites any existing file at targetPath.\n     * Creates any necessary parent directories.\n     * @private\n     * @param {String}   path       The file to copy.\n     * @param {String}   targetPath The path of the copy.\n     * @param {Function} callback   Gets called on completion. Signature: function (error)\n     */\n    exports.copyFile = function (path, targetPath, callback) {\n        var parentPath = dcxUtil.parentDirectory(targetPath);\n        exports.ensureDirectoryExists(parentPath, function (error) {\n            if (error) {\n                callback(error);\n            } else {\n                _copyFile(path, targetPath, callback);\n            }\n        });\n    };\n    \n    return exports;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* Internal helper class.\n*\n* Implements the core functionality shared by both AdobeDCXBranch and AdobeDCXElement.\n*\n* @private\n* @module AdobeDCXBranchCore\n*/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCXBranchCore',['require','exports','module','./AdobeDCXError','./AdobeDCXNode','./AdobeDCXComponent','./AdobeDCXFS','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError');\n    var AdobeDCXNode = require('./AdobeDCXNode');\n    var AdobeDCXComponent = require('./AdobeDCXComponent');\n    var AdobeDCXFS = require('./AdobeDCXFS');\n    var dcxUtil = require('./AdobeDCXUtil');\n\n    /**\n     * The constructor for AdobeDCXBranchCore is private. Branch instances are getting instantiated on an\n     * as needed-basis.\n     * @constructor\n     * @private\n     * @alias module:AdobeDCXBranchCore\n     * @param {Object}  [data]     private\n     * @param {Object}  [owner]    The branch or the element.\n     * @param {Boolean} [readOnly] private\n     */\n    function AdobeDCXBranchCore(data, owner, readOnly) {\n        this._readOnly = readOnly;\n        this._owner = owner;\n        this._setData(data);\n        this._localStorage = undefined; // for now\n    }\n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXBranchCore.prototype, {\n        /**\n         * An AdobeDCXNode object that represents the root node of the branch or element.\n         * @type {AdobeDCXNode}\n         * @readonly\n         */\n        rootNode: {\n            get: function () {\n                return this.getChildWithAbsolutePath(AdobeDCXNode.ROOT_PATH);\n            },\n            set: function (node) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Property \"rootNode\" is read-only.');\n            }\n        },\n        /**\n         * Whether the branch or element has local storage.\n         * @readonly\n         * @type {Boolean}\n         */\n        hasLocalStorage: {\n            get: function () {\n                return this._localStorage;\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property hasLocalStorage.');\n            }\n        },\n        /**\n         * Whether the branch or element has has been modified in memory.\n         * @readonly\n         * @type {Boolean}\n         */\n        isDirty: {\n            get: function () {\n                return this._isDirty;\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property isDirty.');\n            }\n        },\n        /**\n         * @private\n         */\n        changeCount: {\n            get: function () {\n                return this._data.local ? this._data.local.change || 0 : 0;\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property changeCount.');\n            }\n        }\n    });\n    \n    //******************************************************************************\n    // Children (Nodes)\n    //******************************************************************************\n    \n    /**\n     * Returns the node with the given id or undefined if not found.\n     * @param   {String } id The id of the child node to look up.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranchCore.prototype.getChildWithId = function (id) {\n        return this._allNodes[id];\n    };\n    \n    /**\n     * Returns the node with the given absolute path or undefined if not found.\n     * @param   {String} path The absolute path.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranchCore.prototype.getChildWithAbsolutePath = function (path) {\n        var item = this._absolutePaths[path.toLowerCase()];\n        \n        return item ? (item instanceof AdobeDCXNode ? item : undefined) : undefined;\n    };\n    \n    /**\n     * Generates and returns an array of the child nodes of the given parent node.\n     * @example\n     * var rootNodes = branch.getChildrenOf(branch.rootNode);\n     * @param   {AdobeDCXNode} parentNode The parent node to return the children for.\n     * @returns {Array}\n     */\n    AdobeDCXBranchCore.prototype.getChildrenOf = function (parentNode) {\n        parentNode = parentNode ? this._allNodes[parentNode.id] : this.rootNode;\n        \n        if (!parentNode) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Unknown node\");\n        }\n        \n        var result = [];\n        var children = parentNode._data.children;\n        if (Array.isArray(children)) {\n            var i;\n            for (i = 0; i < children.length; i++) {\n                var nodeData = children[i];\n                var node = this._allNodes[nodeData.id];\n                if (!node) {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Node not in cache\");\n                }\n                result[result.length] = node;\n            }\n        }\n        \n        return result;\n    };\n    \n    \n    /**\n     * Creates a new node and inserts it into the children list of the given parent node or of the \n     * root if no parent node is given.\n     * Returns the new child node.\n     * @param   {String}  [name]       The name of the new child. If undefined the child will not\n     *                                 have a name.\n     * @param   {String}  [nodeId]     The id of the new child. If undefined the new child node will \n     *                                 get a random id.\n     * @param   {Integer} [index]      If given and less than or equal to the current number of \n     *                                 children than the node gets inserted at the given index. \n     *                                 Otherwise it gets added to the end.\n     * @param   {String}  [parentNode] The parent node to add the node to. Default parent is the \n     *                                 root node.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranchCore.prototype.addChild = function (name, nodeId, index, parentNode) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        \n        nodeId = nodeId || dcxUtil.generateUuid();\n        if (this._allNodes[nodeId]) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Node already exists in branch.');\n        }\n        if (index && (typeof index !== 'number' || (index % 1 !== 0))) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"index\" must be an integer.');\n        }\n        \n        var newParent = parentNode ? this._allNodes[parentNode.id] : this.rootNode;\n        if (!newParent) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n        }\n        \n        // Create the new node\n        var newChild = new AdobeDCXNode();\n        newChild.id = nodeId;\n        if (name) {\n            newChild.name = name;\n        }\n        newChild._parentPath = newParent.absolutePath || newParent._parentPath;\n        \n        var children = newParent._data.children;\n        if (children) {\n            if (!(index >= 0 && index <= children.length)) {\n                index = children.length;\n            }\n            if (index === children.length) {\n                // Simple case: add to end\n                children[index] = newChild._data;\n            } else {\n                // Insert\n                children.splice(index, 0, newChild._data);\n            }\n        } else {\n            newParent._data.children = [ newChild._data ];\n        }\n        \n        this._allNodes[newChild.id] = newChild;\n        newChild._owner = this._owner;\n        \n        this._setDirty();\n        return newChild;\n    };\n    \n    /**\n     * Removes and returns the given child node from the branch.\n     * @param   {AdobeDCXNode} node The child node to remove.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranchCore.prototype.removeChild = function (node) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!node) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"node\".');\n        }\n        if (node.isRoot) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Cannot remove the root node.');\n        }\n        \n        var nodeId = node.id;\n        if (!nodeId) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"node\" must have an id.');\n        }\n        \n        var found = this._nodeDataOfParentOfNode(node);\n        if (!found) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Node not found in this branch.');\n        }\n        \n        // remove from data\n        found.parentNodeData.children.splice(found.index, 1);\n        if (found.parentNodeData.children.length === 0) {\n            // Remove empty children node\n            delete found.parentNodeData.children;\n        }\n        \n        // update caches\n        node = this._allNodes[nodeId];\n        this._removeNodeFromCachesRecursively(node._data);\n        \n        this._setDirty();\n        \n        return node;\n    };\n    \n    /**\n     * Moves the existing child from its current parent/index to the given parent/index.\n     * @param   {AdobeDCXNode} node         The child node to move\n     * @param   {Integer}      index        If given and less than or equal to the current number of \n     *                                      children than the node gets inserted at the given index. \n     *                                      Otherwise it gets added to the end.\n     * @param   {AdobeDCXNode} [parentNode] The parent node to move the node to. Default parent is \n     *                                      the root.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranchCore.prototype.moveChild = function (node, index, parentNode) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!node) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"node\".');\n        }\n        if (node.isRoot) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Cannot move the root node.');\n        }\n        if (index && (typeof index !== 'number' || (index % 1 !== 0))) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"index\" must be an integer.');\n        }\n        \n        var nodeId = node.id;\n        if (!nodeId) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"node\" must have an id.');\n        }\n        \n        var found = this._nodeDataOfParentOfNode(node);\n        node = this._allNodes[nodeId];\n        if (!found) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Node not found in this branch.');\n        }\n        \n        var newParent = (parentNode ? this._allNodes[parentNode.id] : this.rootNode);\n        if (!newParent) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n        }\n        \n        if (this._nodeIdIsDescendantOf(newParent.id, node._data)) {\n            // Trying to move the node into a decsendant of itself.\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Must not create a cycle.');\n        }\n            \n        // Remove from data from the old parent and add it to the new parent.\n        // We are using try-catch to ensure that we do not end up losing the node.\n        var data = (found.parentNodeData.children.splice(found.index, 1))[0];\n        try {\n            var children = newParent._data.children;\n            if (children) {\n                if (!(index >= 0 && index <= children.length)) {\n                    index = children.length;\n                }\n                if (index === children.length) {\n                    // Simple case: add to end\n                    children[index] = data;\n                } else {\n                    // Insert\n                    children.splice(index, 0, data);\n                }\n            } else {\n                newParent._data.children = [ data ];\n            }\n        } catch (x) {\n            // re-insert\n            found.parentNodeData.children.splice(found.index, 0, data);\n            throw x;\n        }\n        \n        if (found.parentNodeData.children.length === 0) {\n            // Remove empty children node\n            delete found.parentNodeData.children;\n        }\n        \n        // No need to update caches since this is only a move.\n        \n        this._setDirty();\n        \n        return this._allNodes[nodeId];\n        \n    };\n    \n    /**\n     * Gets passed into copyChild(), replaceChild and called back whenever the operation has finished.\n     * @callback nodeCallback\n     *    @param {Error}         error\n     *    @param {AdobeDCXNode}  node\n     */\n    \n    /**\n     * Copies the given child node as a new node into this branch. The node can be from the same or \n     * from a different composite.\n     * \n     * <p>This function will try reuse the ids of any children and components of the copied node, \n     * in order to minimize the amount of data that will later have to be uploaded, however, clients \n     * must not rely on these ids being preserved in the copied objects.</p>\n     * \n     * <p>Fails if a node with the same id or same absolute path already exists.</p>\n     * \n     * <p>Notice: This method does not work without local storage (e.g. browser environment) if\n     * used to copy between two composites stored at different endpoints.</p>\n     *\n     * @param   {AdobeDCXNode} node         The child node to copy. If it is the root node then \n     *                                      newPath must be provided.\n     * @param   {AdobeDCXNode} [parentNode] The parent node to copy the child node to. If undefined \n     *                                      then the new child node will be added to the root of the \n     *                                      branch.\n     * @param   {Integer}      [index]      If provided and less than or equal to the current number of \n     *                                      children of the parentNode (or root) the child node gets \n     *                                      inserted at the given index. Otherwise it gets added to \n     *                                      the end.\n     * @param   {String}       [newPath]    <p>If provided, the copy of the child node will be assigned \n     *                                      this a its path property and it will also receive a new\n     *                                      random id (unless one is provided with the newId param). \n     *                                      If left undefined then the copy of the node will keep \n     *                                      the path of the original. In either case the function will \n     *                                      fail if the resulting absolute path of the child or any \n     *                                      of its children/components conflicts with an already \n     *                                      existing absolute path.</p>\n     *                                      <p>You must provide a newPath if you are copying the root\n     *                                      node of a branch or element.</p>\n     * @param   {String}       [newId]      If provided, the copy of the child node will be assigned \n     *                                      this a its id. If left undefined (and the newPath param\n     *                                      is also undefined) then the copy will retain the id of\n     *                                      the original. In either case the function will \n     *                                      fail if the resulting id of the child or any \n     *                                      of its children/components conflicts with an already \n     *                                      existing id.\n     * @param   {nodeCallback} [callback]   Optional when not copying between different composites or\n     *                                      when not using local storage. \n     *                                      Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXNode}              Only returns the created child node if no callback is \n     *                                      given.\n     */\n    AdobeDCXBranchCore.prototype.copyChild = function (node, parentNode, index, newPath, newId, callback) {\n        return this._copyChild(node, parentNode, index, newPath, newId, /*replaceExisting*/ false, callback);\n    };\n    \n    /**\n     * <p>Replaces the child node in this branch with a copy of the given node or branch with the same \n     * id (or, if provided, with the given id). Fails if the child node does not exist in this branch.</p>\n     * \n     * <p>This function will try reuse the ids of any children and components of the copied node, \n     * in order to minimize the amount of data that will later have to be uploaded, however, clients \n     * must not rely on these ids being preserved in the copied objects.</p>\n     * \n     * <p>Notice: This method does not work without local storage (e.g. browser environment) if\n     * used to copy between two different composites.</p>\n     * \n     * @param   {AdobeDCXNode} node       The child node to update from.\n     * @param   {String}       [newPath]  If provided the copy of the component will be assigned \n     *                                    this a its path property. Otherwise it will retain its original path.\n     * @param   {String}       [newId]    If provided the copy of the child node will be assigned \n     *                                    this as its id. Otherwise it will retain its original id.\n     * @param   {nodeCallback} [callback] Optional when not copying between different composites or \n     *                                    when not using local storage. \n     *                                    Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXNode}            Only returns the created child node if no callback is \n     *                                    given.\n     */\n    AdobeDCXBranchCore.prototype.replaceChild = function (node, newPath, newId, callback) {\n        return this._copyChild(node, /*parentNode*/ undefined, /*index*/ undefined, /*newPath*/ newPath,\n                                newId || node.id, /*replaceExisting*/ true, callback);\n    };\n    \n    \n    //******************************************************************************\n    // Components\n    //******************************************************************************\n    \n    /**\n     * Returns an array of all components in the branch.\n     * @returns {Array}.\n     */\n    AdobeDCXBranchCore.prototype.allComponents = function () {\n        var result = [], id;\n        for (id in this._allComponents) {\n            if (this._allComponents.hasOwnProperty(id)) {\n                result.push(this._allComponents[id]);\n            }\n        }\n        return result;\n    };\n    \n    /**\n     * Returns the component with the given id or undefined if not found.\n     * @param   {String} id The id of the component to look up.\n     * @returns {AdobeDCXComponent}\n     */\n    AdobeDCXBranchCore.prototype.getComponentWithId = function (id) {\n        return this._allComponents[id];\n    };\n    \n    /**\n     * Returns the component with the given absolute path or undefined if not found.\n     * @param   {String} path The absolute path of the desired component.\n     * @returns {AdobeDCXComponent}\n     */\n    AdobeDCXBranchCore.prototype.getComponentWithAbsolutePath = function (path) {\n        var item = this._absolutePaths[path.toLowerCase()];\n        return item ? (item instanceof AdobeDCXComponent ? item : undefined) : undefined;\n    };\n    \n    /**\n     * Returns an array containing the components of the given node.\n     * @param   {AdobeDCXNode} parentNode The node whose components to return.\n     * @returns {Array}\n     */\n    AdobeDCXBranchCore.prototype.getComponentsOf = function (parentNode) {\n        parentNode = parentNode ? this._allNodes[parentNode.id] : this.rootNode;\n        if (!parentNode) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Unknown node\");\n        }\n        \n        var result = [];\n        var components = parentNode._data.components;\n        if (Array.isArray(components)) {\n            var i;\n            for (i = 0; i < components.length; i++) {\n                var componentData = components[i];\n                var component = this._allComponents[componentData.id];\n                if (!component) {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Component not in cache\");\n                }\n                result[result.length] = component;\n            }\n        }\n        \n        return result;\n    };\n    \n    \n    /**\n     * Gets passed into addComponent(), updateComponent(), copyComponent(), replaceComponent() and\n     * called back whenever the operation has finished.\n     * @callback componentCallback\n     *    @param {Error}                error\n     *    @param {AdobeDCXComponent}    component\n     */\n    \n    /**\n     * <strong>NJS-only</strong> Use AdobeDCXCompositeXfer.uploadNewComponent() followed by \n     * addComponentWithUploadResults() instead.\n     *\n     * <p>Creates and adds a component to the given parent node.</p>\n     *\n     * @param {String}            name         The name of the new component.\n     * @param {String}            type         The mime type of the new component.\n     * @param {String}            relationship The relationship of the new component.\n     * @param {String}            path         The path of the new component. Must satisfy uniqueness \n     *                                         rules for components.\n     * @param {String}            [source]     The absolute file path of the newsource file of the \n     *                                         component.\n     * @param {Boolean}           copy         Whether to copy (true) or move (false) the source file \n     *                                         to its proper location.\n     * @param {String}            [sourceHref] The href of a file asset at the same endpoint as the composite.\n     * @param {AdobeDCXNode}      [parentNode] The node to add the node to. Defaults to the root.\n     * @param {String}            [id]         The id to use for the new component. Must be unique \n     *                                         within the composite. If not provided the component \n     *                                         will get assigned a random uuid.\n     * @param {componentCallback} [callback]   Gets called when adding the component has either \n     *                                         succeeded or failed. Is optional if no source is given.\n     * @return {AdobeDCXComponent} The newly created component if called without source param.\n     */\n    AdobeDCXBranchCore.prototype.addComponent = function (name, type, relationship, path, source, copy, sourceHref, parentNode, id, callback) {\n        var localStorage = this._localStorage;\n        if (!localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage. Use AdobeDCXCompositeXfer.uploadNewComponent() followed by addComponentWithUploadResults()');\n        }\n        // Check preconditions\n        if (typeof callback !== 'function' && source) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"callback\" must be a function.');\n        }\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (id && (typeof id !== 'string')) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"id\" must be of type string.');\n        }\n        if (!source && !sourceHref) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Must provide either source or sourceHref.');\n        }\n        \n        try {\n            if (sourceHref) {\n                // Check to see if the endpoints differ\n                var compositeHref = this._getBranchOf(this).compositeHref;\n                if (compositeHref) {\n                    var compositeEndpoint = dcxUtil.endPointOf(compositeHref);\n                    var sourceEndpoint = dcxUtil.endPointOf(sourceHref);\n                    if (compositeEndpoint && sourceEndpoint && compositeEndpoint !== sourceEndpoint) {\n                        throw new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Given source href has an invalid endpoint: ' + sourceEndpoint);\n                    }\n                }\n            }\n            var storageObject = this._local();\n            \n            id = id || dcxUtil.generateUuid();\n            \n            // create new component\n            var newComponent = new AdobeDCXComponent();\n            newComponent.id = id;\n            newComponent.name = name;\n            newComponent.type = type;\n            newComponent.relationship = relationship;\n            newComponent.path = path;\n            newComponent.state = 'modified';\n            \n            // We are defining a callback function here that we can pass into the calls to local or remote storage\n            var self = this;\n            var insertComponentCallback = function (error) {\n                if (!error) {\n                    try {\n                        // Now that the component asset has been copied/moved/uploaded we need to verify whether we can\n                        // actually accept it. We must not make these check beforehand because the manifest might have\n                        // been modified in the meantime.\n\n                        if (id && self._allComponents[id]) {\n                            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'The \"id\" of a component must be unique.');\n                        }\n\n                        var newParent = parentNode ? self._allNodes[parentNode.id] : self.rootNode;\n                        if (!newParent) {\n                            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n                        }\n\n                        // Check that the resulting absolute path of the component will be unique\n                        var absPath = self._normalizedAbsolutePathForItem(newComponent, newParent);\n                        if (self._absolutePaths[absPath]) {\n                            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n                        }\n                        newComponent._parentPath = newParent.absolutePath || newParent._parentPath;\n\n                        // add to parent node\n                        var components = newParent._data.components;\n                        if (components) {\n                            components.push(newComponent._data);\n                        } else {\n                            newParent._data.components = [ newComponent._data ];\n                        }\n                        newComponent._owner = self._owner;\n                        \n                        if (sourceHref) {\n                            self._setSourceHrefOfComponent(sourceHref, newComponent);\n                        }\n\n                        // Update caches\n                        self._allComponents[newComponent.id] = newComponent;\n                        self._absolutePaths[absPath] = newComponent;\n\n                        self._setDirty();\n                        \n                    } catch (x) {\n                        // At this point local storage has already recorded the component, but we are not\n                        // going to add it to the manifest, so we need to ask it to remove the component.\n                        localStorage.removeComponentAsset(newComponent, storageObject);\n                        if (sourceHref) {\n                            self._setSourceHrefOfComponent(undefined, newComponent);\n                        }\n                    \n                        newComponent = undefined;\n                        error = x;\n                    }\n                }\n                if (callback) {\n                    return callback(error, newComponent);\n                }\n                if (error) {\n                    throw error;\n                }\n                return newComponent;\n            };\n            \n            if (source) {\n                // Now we take care of the source file\n                localStorage.ingestComponentAsset(newComponent, source, copy, storageObject, insertComponentCallback);\n            } else {\n                return insertComponentCallback();\n            }\n        } catch (error) {\n            if (callback) {\n                return callback(error);\n            }\n            throw error;\n        }\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Creates and adds a component to the given parent node or to the root if no parent node is \n     * given.</p>\n     * \n     * @param   {String}            name          The name of the new component.\n     * @param   {String}            relationship  The relationship of the new component.\n     * @param   {String}            path          The path of the new component. Must satisfy uniquenes \n     *                                            rules for components.\n     * @param   {AdobeDCXNode}      [parentNode]  The node to add the node to. Defaults to the root.\n     * @param   {Object}            uploadResults The upload results object returned by a previous call \n     *                                            to AdobeDCXCompositeXfer.uploadAssetForComponent().\n     * @returns {AdobeDCXComponent}               The new component.\n     */\n    AdobeDCXBranchCore.prototype.addComponentWithUploadResults = function (name, relationship, path, parentNode, uploadResults) {\n        // check preconditions\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (uploadResults.compositeId !== this._owner.compositeId) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param uploadResults does not appear valid to be for this composite.');\n        }\n        var recordKeys = Object.keys(uploadResults.records);\n        if (recordKeys.length !== 1) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param uploadResults must contain records of exactly one component upload.');\n        }\n        if (this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'This method is for in-browser use only. Use addComponent() instead.');\n        }\n        \n        var uploadRecord = uploadResults.records[recordKeys[0]];\n        var componentId = uploadRecord.id;\n            \n        if (this._allComponents[componentId]) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate component id: ' + componentId);\n        }\n        \n        var newParent = parentNode ? this._allNodes[parentNode.id] : this.rootNode;\n        if (!newParent) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n        }\n        \n        // create new component\n        var newComponent = new AdobeDCXComponent();\n        newComponent.id = componentId;\n        newComponent.name = name;\n        newComponent.type = uploadRecord.type;\n        newComponent.relationship = relationship;\n        newComponent.path = path;\n        newComponent.state = 'unmodified';\n        newComponent.etag = uploadRecord.etag;\n        newComponent.length = uploadRecord.length;\n        newComponent.version = uploadRecord.version;\n        newComponent.md5 = uploadRecord.md5;\n        \n        // Check that the resulting absolute path of the component will be unique\n        var absPath = this._normalizedAbsolutePathForItem(newComponent, newParent);\n        if (this._absolutePaths[absPath]) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n        }\n        newComponent._parentPath = newParent.absolutePath || newParent._parentPath;\n\n        // add to parent node\n        var components = newParent._data.components;\n        if (components) {\n            components.push(newComponent._data);\n        } else {\n            newParent._data.components = [ newComponent._data ];\n        }\n        newComponent._owner = this._owner;\n\n        // Update caches\n        this._allComponents[componentId] = newComponent;\n        this._absolutePaths[absPath] = newComponent;\n\n        this._setDirty();\n        \n        return newComponent;\n    };\n    \n    /**\n     * <strong>NJS-only</strong> - Use AdobeDCXCompositeXfer.uploadComponent() to upload a new \n     * component asset and then call updateComponentWithUploadResults() instead.\n     *\n     * <p>Updates the asset file of a component with the given source file.</p>\n     *\n     * @param {AdobeDCXComponent} component    The component to update.\n     * @param {String}            [source]     The absolute file path of the new source file.\n     * @param {Boolean}           copy         Whether to copy (true) or move (false) the source file \n     *                                         to its proper location.\n     * @param {componentCallback} callback     Gets called when adding the component has either \n     *                                         succeeded or failed.\n     */\n    AdobeDCXBranchCore.prototype.updateComponent = function (component, source, copy, callback) {\n        // check preconditions\n        var localStorage = this._localStorage;\n        if (!localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage. Use AdobeDCXCompositeXfer.uploadComponent() to upload a new component asset and then call updateComponentWithUploadResults()');\n        }\n        if (typeof callback !== 'function') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"callback\" must be a function.');\n        }\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        component = this._allComponents[component.id];\n        if (!component) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown component.');\n        }\n        \n        try {\n            // We are defining a callback function here that we can pass into the calls to local or remote storage\n            var self = this;\n            var updateComponentCallback = function (error) {\n                if (!error) {\n                    try {\n                        if (component.state !== 'modified') {\n                            component.state = 'modified'; // dirties the branch\n                        } else {\n                            self._setDirty();\n                        }\n                        // Unconditionally set the source href to clear if we have a pre-existing one\n                        self._setSourceHrefOfComponent(undefined, component);\n                    } catch (x) {\n                        error = x;\n                        component = undefined;\n                    }\n                }\n                callback(error, component);\n            };\n            \n            // Now we take care of the source file\n            localStorage.ingestComponentAsset(component, source, copy, this._local(), updateComponentCallback);\n        } catch (error) {\n            callback(error);\n        }\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Updates the component record with the results of a recent upload of said component.</p>\n     * \n     * @param   {AdobeDCXComponent} component     The component.\n     * @param   {Object}            uploadResults The upload results object returned by a previous \n     *                                            call to AdobeDCXCompositeXfer.uploadAssetForComponent().\n     * @returns {AdobeDCXComponent} The updated component.\n     */\n    AdobeDCXBranchCore.prototype.updateComponentWithUploadResults = function (component, uploadResults) {\n        // check preconditions\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        component = this._allComponents[component.id];\n        if (!component) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown component.');\n        }\n        if (this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'This method is for in-browser use only. Use updateComponent() instead.');\n        }\n        if (uploadResults.compositeId !== this._owner.compositeId) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param uploadResults does not appear valid to be for this composite.');\n        }\n        var uploadRecord = uploadResults.records[component.id];\n        if (!uploadRecord) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param uploadResults does not contain an upload record for the given component.');\n        }\n        \n        component.etag = uploadRecord.etag;\n        component.version = uploadRecord.version;\n        component.md5 = uploadRecord.md5;\n        component.length = uploadRecord.length;\n        \n        return component;\n    };\n    \n    /**\n     * Removes the component from the branch.\n     * @param   {AdobeDCXComponent} component The component to remove.\n     * @returns {AdobeDCXComponent} The removed component.\n     */\n    AdobeDCXBranchCore.prototype.removeComponent = function (component) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!component) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"component\".');\n        }\n        \n        var componentId = component.id;\n        if (!componentId) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"component\" must have an id.');\n        }\n        \n        var found = this._nodeDataOfParentOfComponent(component);\n        if (!found) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Component not found in this branch.');\n        }\n        \n        // remove from data\n        found.parentNodeData.components.splice(found.index, 1);\n        if (found.parentNodeData.components.length === 0) {\n            // Remove empty components node\n            delete found.parentNodeData.components;\n        }\n        \n        // update caches\n        component = this._allComponents[componentId];\n        delete this._allComponents[componentId];\n        delete this._absolutePaths[this._normalizedAbsolutePathForItem(component)];\n        \n        // Update local storage\n        if (this._localStorage) {\n            this._localStorage.removeComponentAsset(component, this._local());\n            this._setSourceHrefOfComponent(undefined, component);\n        }\n        \n        component._owner = undefined;\n        component._parentPath = '';\n        \n        this._setDirty();\n        \n        return component;\n    };\n    \n    \n    /**\n     * Moves the component to the given node or the root if node is undefined\n     * @param   {AdobeDCXComponent} component    The component to move.\n     * @param   {AdobeDCXNode}      [parentNode] The node to move the component to.\n     * @returns {AdobeDCXComponent} The moved component.\n     */\n    AdobeDCXBranchCore.prototype.moveComponent = function (component, parentNode) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!component) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"component\".');\n        }\n        \n        var componentId = component.id;\n        if (!componentId) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"component\" must have an id.');\n        }\n        \n        var found = this._nodeDataOfParentOfComponent(component);\n        if (!found) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Component not found in this branch.');\n        }\n        \n        var newParent = parentNode ? this._allNodes[parentNode.id] : this.rootNode;\n        if (!newParent) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n        }\n        \n        // Check that the resulting absolute path of the component will be unique\n        var absPath = this._normalizedAbsolutePathForItem(component, newParent);\n        if (this._absolutePaths[absPath]) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n        }\n        \n        // move\n        var data = found.parentNodeData.components.splice(found.index, 1)[0];\n        var components = newParent._data.components;\n        if (components) {\n            components.push(data);\n        } else {\n            newParent._data.components = [ data ];\n        }\n        if (found.parentNodeData.components.length === 0) {\n            // Remove empty components node\n            delete found.parentNodeData.components;\n        }\n        \n        // update component and caches\n        component = this._allComponents[componentId];\n        delete this._absolutePaths[this._normalizedAbsolutePathForItem(component)];\n        component._parentPath = newParent.absolutePath || newParent._parentPath;\n        this._absolutePaths[absPath] = component;\n        \n        this._setDirty();\n        \n        return component;\n    };\n    \n    /**\n     * Copies the given component and adds it as a new component to this branch. Fails if the \n     * component already exists.\n     *\n     * @param   {AdobeDCXComponent} component    The component to copy.\n     * @param   {AdobeDCXNode}      [parentNode] The node to copy the component to. If none is \n     *                                           provided then the component will be added to the \n     *                                           root.\n     * @param   {String}            [newPath]    If provided the copy of the component will be \n     *                                           assigned this a its path property and it will also \n     *                                           get assigned a new id if none is provided via the \n     *                                           <em>newId</em> param.\n     * @param   {String}            [newId]      If provided the copy of the component will be \n     *                                           assigned this a its id property.\n     * @param   {componentCallback} [callback]   Optional when not copying between different \n     *                                           composites. Gets called when the copy is done or \n     *                                           has failed.\n     * @returns {AdobeDCXComponent}              Only returns the new component when called without \n     *                                           a callback.\n     */\n    AdobeDCXBranchCore.prototype.copyComponent = function (component, parentNode, newPath, newId, callback) {\n        return this._copyComponent(component, parentNode, newPath, newId, /*replaceExisting*/ false, callback);\n    };\n    \n    /**\n     * Replaces the matching component (same id) in this branch with a copy of the given component. \n     * Fails if the component can't be found.\n     *\n     * @param   {AdobeDCXComponent} component  The component to copy.\n     * @param   {String}            [newPath]  If provided the copy of the component will be \n     *                                         assigned this a its path property and it will also \n     *                                         get assigned a new id if none is provided via the \n     *                                         newId param.\n     * @param   {String}            [newId]    If provided the copy of the component will be \n     *                                         assigned this a its id property.\n     * @param   {componentCallback} [callback] Optional when not copying between different \n     *                                         composites. Gets called when the copy is done or has \n     *                                         failed.\n     * @returns {AdobeDCXComponent}            Only returns the new component when called without \n     *                                         a callback.\n     */\n    AdobeDCXBranchCore.prototype.replaceComponent = function (component, newPath, newId, callback) {\n        return this._copyComponent(component, /*parentNode*/ undefined, newPath, newId || component.id,\n                                   /*replaceExisting*/ true, callback);\n    };\n    \n    /**\n     * Gets passed into assetOfComponent() and called back whenever the operation has finished.\n     * @callback filePathCallback\n     *    @param {Error}     error\n     *    @param {String}    filePath\n     */\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Determines and returns the path of the asset of the component. Can be called either \n     * synchronously or asynchronously. The former just returns the path. The latter also checks for \n     * the existence of the file and only returns the path (to the callback) if it actually exists.</p>\n     *\n     * @param   {AdobeDCXComponent} component  The component to get the asset path for.\n     * @param   {filePathCallback}  [callback] Gets called when both the path and the existence of \n     *                                         the file at the path have been determined.\n     * @returns {AdobeDCXComponent}            Only returns the local file path of the component\n     *                                         when called without a callback.\n     */\n    AdobeDCXBranchCore.prototype.assetOfComponent = function (component, callback) {\n        try {\n            if (!this._localStorage) {\n                throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n            }\n            if (!component) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"component\".');\n            }\n            var componentId = component.id;\n            if (!componentId) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"component\" must have an id.');\n            }\n            \n            var path = this._localStorage.componentAssetPath(component, this._local());\n            \n            if (callback) {\n                AdobeDCXFS.exists(path, function (exists) {\n                    callback(undefined, exists ? path : null);\n                });\n            } else {\n                return path;\n            }\n        } catch (error) {\n            if (callback) {\n                callback(error);\n            } else {\n                throw error;\n            }\n        }\n    };\n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n    \n    /**\n     * @private\n     */\n    AdobeDCXBranchCore.prototype._getHrefOfComponent = function (component) {\n        // HACK: We need the session in order to determine the source href for the component\n        // since we currently do not have that available we just construct it here\n        \n        var href, branch = this._getBranchOf(component);\n        var compositeHref = branch.compositeHref;\n\n        if (compositeHref && typeof component.version !== 'undefined') {\n            href = dcxUtil.appendPathElements(compositeHref, component.id);\n            href += ';version=' + component.version;\n        }\n        \n        return href;\n    };\n    \n    /**\n     * Sets or clears the source href of the given component.\n     * @private\n     * @param {String|undefined}  sourceHref The new sourceHref or undefined\n     * @param {AdobeDCXComponent} component  The component.\n     * @param {Object}            [local]    Optional: The local data object to use.\n     */\n    AdobeDCXBranchCore.prototype._setSourceHrefOfComponent = function (sourceHref, component, local) {\n        var id = component.id;\n        var lookup = this._componentSourceHrefLookup(true, local);\n        if (sourceHref) {\n            lookup[id] = sourceHref;\n        } else if (lookup[id]) {\n            delete lookup[id];\n        }\n    };\n    \n    /**\n     * Returns the source href of the given component if one has previously been recorded.\n     * @private\n     * @param   {AdobeDCXComponent} component The component.\n     * @param {Object}              [local]   Optional: The local data object to use.\n     * @returns {String|undefined}  The source href or undefined.\n     */\n    AdobeDCXBranchCore.prototype._getSourceHrefOfComponent = function (component, local) {\n        var id = component.id;\n        var lookup = this._componentSourceHrefLookup(false, local);\n        if (lookup) {\n            return lookup[id];\n        }\n        \n        return undefined;\n    };\n    \n    /**\n     * Copies over any source hrefs from the given branch core. Overwrites or clears any \n     * existing source hrefs.\n     * @private\n     * @param {AdobeDCXBranchCore} otherCore The core to copy from\n     */\n    AdobeDCXBranchCore.prototype._copySourceHrefsFrom = function (otherCore) {\n        var otherLookup = otherCore._componentSourceHrefLookup(false);\n        var myComponents = this.allComponents();\n        var numComponents = myComponents.length;\n        \n        if (numComponents && otherLookup) {\n            var i, myLookup = this._componentSourceHrefLookup(true);\n            for (i = 0; i < numComponents; i++) {\n                var componentId = myComponents[i].id;\n                myLookup[componentId] = otherLookup[componentId];\n            }\n        }\n    };\n    \n    /**\n    * @private\n    */\n    AdobeDCXBranchCore.prototype._getBranchOf = function (item) {\n        if (item._owner) {\n            return this._getBranchOf(item._owner);\n        }\n        return item;\n    };\n    \n    /**\n     * Returns true if the given core is of the same composite.\n     * @private\n     * @param   {AdobeDCXBranchCore} otherCore The other core.\n     * @returns {Boolean}            Whether the composites match.\n     */\n    AdobeDCXBranchCore.prototype._isSameComposite = function (otherCore) {\n        return this._getBranchOf(this)._data.id === this._getBranchOf(otherCore)._data.id;\n    };\n\n    /**\n     * Returns a stringified representation of the branch that can be used to persist\n     * and later restore it.\n     * @private\n     * @param   {Boolean} stripOutLocalData Whether to exclude the local data node.\n     * @param   {Boolean} pretty            Whether to pretty print the JSON output.\n     * @returns {String}\n     */\n    AdobeDCXBranchCore.prototype._stringify = function (stripOutLocalData, pretty) {\n        if (stripOutLocalData) {\n            // temporarily remove the local node\n            var local = this._data.local;\n            var remoteData = null;\n            try {\n                delete this._data.local;\n                remoteData = JSON.stringify(this._data, undefined, pretty ? 2 : undefined);\n            } catch (x) {\n                throw x;\n            } finally {\n                if (local) {\n                    this._data.local = local;\n                }\n            }\n            return remoteData;\n        }\n        return JSON.stringify(this._data, undefined, pretty ? 2 : undefined);\n    };\n \n    /**\n     * Verifies and sets the new data and creates the caches. Throws if invalid data.\n     * @private\n     * @param   {Object}         data Data\n     * @returns {AdobeDCXBranch} The branch.\n     */\n    AdobeDCXBranchCore.prototype._setData = function (data) {\n            \n        // Create the root node\n        var rootNode = new AdobeDCXNode(data, this._readOnly, true);\n        rootNode._owner = this._owner;\n        rootNode._parentPath = '';\n        var id = rootNode.id;\n            \n        // Create new caches and lookups\n        var allComponents = {},\n            allNodes = {},\n            absPaths = {};\n        allNodes[id] = rootNode;\n        absPaths[AdobeDCXNode.ROOT_PATH] = rootNode;\n            \n        // function to recurse down the hierarchy\n        var self = this;\n        var buildDOMandCachesRecursively = function (thisNodeData, allComponents, allNodes, absPaths, parentPath) {\n            var i, path, absPath;\n\n            // Capture the components of this node\n            var components = thisNodeData.components;\n            if (Array.isArray(components)) {\n                for (i = 0; i < components.length; i++) {\n                    var componentData = components[i];\n                    var component = new AdobeDCXComponent(componentData, self._readOnly);\n                    if (allComponents[component.id]) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Duplicate component id: \" + component.id);\n                    }\n                    path = component.path;\n                    if (!dcxUtil.isValidPath(path)) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Invalid component path: \" + path);\n                    }\n                    component._owner = self._owner;\n                    component._parentPath = parentPath;\n                    absPath = self._normalizedAbsolutePathForItem(component);\n                    if (absPaths[absPath]) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Duplicate absolute path: \" + absPath);\n                    }\n                    allComponents[component.id] = component;\n                    absPaths[absPath] = component;\n                }\n            }\n\n            // Capture the child nodes and recurse down\n            var children = thisNodeData.children;\n            if (Array.isArray(children)) {\n                for (i = 0; i < children.length; i++) {\n                    var nodeData = children[i];\n                    var node = new AdobeDCXNode(nodeData, self._readOnly);\n                    if (allNodes[node.id]) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Duplicate node id: \" + node.id);\n                    }\n                    path = node.path;\n                    node._owner = self._owner;\n                    node._parentPath = parentPath;\n                    if (path) {\n                        if (!dcxUtil.isValidPath(path)) {\n                            throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Invalid node path: \" + path);\n                        }\n                        absPath = self._normalizedAbsolutePathForItem(node);\n                        if (absPaths[absPath]) {\n                            throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Duplicate absolute path: \" + absPath);\n                        }\n                        absPaths[absPath] = node;\n                    }\n                    allNodes[node.id] = node;\n\n                    // recurse down\n                    buildDOMandCachesRecursively(nodeData, allComponents, allNodes, absPaths, node.path ? dcxUtil.appendPathElements(parentPath, node.path) : parentPath);\n                }\n            }\n        };\n\n        // Create components and child nodes while populating the new caches.\n        buildDOMandCachesRecursively(data, allComponents, allNodes, absPaths, AdobeDCXNode.ROOT_PATH);\n\n        this._data = data;\n        this._allComponents = allComponents;\n        this._allNodes = allNodes;\n        this._absolutePaths = absPaths;\n\n        this._isDirty = false;\n        return this;\n    };\n    \n    /**\n     * Recursively removes the given node and all its sub nodes and components from the caches.\n     * @private\n     * @param {Object} thisNodeData Data\n     */\n    AdobeDCXBranchCore.prototype._removeNodeFromCachesRecursively = function (thisNodeData) {\n        var i;\n        \n        // Remove the components\n        var components = thisNodeData.components;\n        if (Array.isArray(components)) {\n            for (i = 0; i < components.length; i++) {\n                var componentId = components[i].id;\n                var component = this._allComponents[componentId];\n                delete this._allComponents[componentId];\n                delete this._absolutePaths[this._normalizedAbsolutePathForItem(component)];\n                component._owner = undefined;\n                // Update local storage\n                if (this._localStorage) {\n                    this._localStorage.removeComponentAsset(component, this._local());\n                    this._setSourceHrefOfComponent(undefined, component);\n                }\n            }\n        }\n        \n        // Remove the child nodes\n        var children = thisNodeData.children;\n        if (Array.isArray(children)) {\n            for (i = 0; i < children.length; i++) {\n                this._removeNodeFromCachesRecursively(children[i]);\n            }\n        }\n        \n        // Remove this node\n        var nodeId = thisNodeData.id;\n        var node = this._allNodes[nodeId];\n        delete this._allNodes[nodeId];\n        if (node.path) {\n            delete this._absolutePaths[this._normalizedAbsolutePathForItem(node)];\n        }\n        node._owner = undefined;\n    };\n    \n    /**\n     * Returns the local node, creating it if necessary.\n     * @private\n     * @returns {Object}\n     */\n    AdobeDCXBranchCore.prototype._local = function () {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!this._data.local) {\n            this._data.local = { version: 2 };\n        }\n        return this._data.local;\n    };\n    \n    /**\n     * Returns the lookup table for component source hrefs, creating it if necessary & requested.\n     * @private\n     * @returns {Object}\n     */\n    AdobeDCXBranchCore.prototype._componentSourceHrefLookup = function (createIfNecessary, local) {\n        if (createIfNecessary && this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!local) {\n            local = this._local();\n        }\n        var lookup = local['componentS2SCopy#srcHref'];\n        \n        if (!lookup && createIfNecessary) {\n            lookup = local['componentS2SCopy#srcHref'] = {};\n        }\n        \n        return lookup;\n    };\n    \n    /**\n     * Recursively resets components.\n     * @private\n     * @param {Object} node\n     */\n    AdobeDCXBranchCore.prototype._recursiveReset = function (node, componentCallback) {\n        var i, components = node.components;\n        \n        if (components) {\n            for (i = components.length - 1; i >= 0; i--) { // iterating back to front so that we can delete items\n                var component = components[i];\n                if (component.state === 'committedDelete') {\n                    // the component is no longer used\n                    delete components[i];\n                    delete this._allComponents[component.id];\n                    delete component._owner;\n                    // Update local storage\n                    if (this._localStorage) {\n                        this._localStorage.removeComponentAsset(component, this._local());\n                    }\n                    this._setSourceHrefOfComponent(undefined, component, this._local());\n                } else {\n                    delete component.etag;\n                    delete component.version;\n                    delete component.length;\n                    delete component.md5;\n                    component.state = 'modified';\n                    if (componentCallback) {\n                        componentCallback(component);\n                    }\n                }\n            }\n        }\n        \n        var children = node.children;\n        \n        if (children) {\n            for (i = 0; i < children.length; i++) {\n                this._recursiveReset(children[i], componentCallback);\n            }\n        }\n    };\n    \n    /**\n     * Figures out whether a node with id nodeId is a sub node of nodeData.\n     * @private\n     * @param   {String}  nodeId   \n     * @param   {Object}  nodeData\n     * @returns {Boolean} \n     */\n    AdobeDCXBranchCore.prototype._nodeIdIsDescendantOf = function (nodeId, nodeData) {\n        var i, children = nodeData.children;\n        \n        if (children) {\n            for (i = 0; i < children.length; i++) {\n                var childData = children[i];\n                if (childData.id === nodeId || this._nodeIdIsDescendantOf(nodeId, childData)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    };\n    \n    /**\n     * Returns an array with all components of the given node and its descendants.\n     * @private\n     * @param   {Object} node               The node.\n     * @param   {Object} [allComponents=[]] USed for recursion. Leave undefined.\n     * @returns {Object}\n     */\n    AdobeDCXBranchCore.prototype._recursivelyGetAllComponentsOfChild = function (node, allComponents) {\n        allComponents = allComponents || [];\n        \n        var data = node._data || node;\n        var i, c, components = data.components;\n        if (components) {\n            c = components.length;\n            for (i = 0; i < c; i++) {\n                allComponents[allComponents.length] = this._allComponents[components[i].id];\n            }\n        }\n        \n        var children = data.children;\n        if (children) {\n            c = children.length;\n            for (i = 0; i < c; i++) {\n                allComponents = this._recursivelyGetAllComponentsOfChild(children[i], allComponents);\n            }\n        }\n        \n        return allComponents;\n    };\n    \n    \n    /**\n     * Returns the node data of the parent node of the given node.\n     * @private\n     * @param   {Object}   node\n     * @param   {Object}   [currentNodeData=this._data] Used for recursion. Don't set.\n     * @returns {Object}     found an object of the form { parentNodeData: dataObject, index: integer }. Otherwise null.\n     */\n    AdobeDCXBranchCore.prototype._nodeDataOfParentOfNode = function (node, currentNodeData) {\n        currentNodeData = currentNodeData || this._data;\n        \n        var i, id = node._data.id, children = currentNodeData.children;\n        \n        if (children) {\n            for (i = 0; i < children.length; i++) {\n                var childData = children[i];\n                var path = childData.path;\n                if (childData.id === id) {\n                    return { parentNodeData: currentNodeData, index: i };\n                }\n                var found = this._nodeDataOfParentOfNode(node, childData);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n        \n        return null;\n    };\n    \n    \n    /**\n     * Returns the node data of the parent node of the given component.\n     * @private\n     * @param   {Object}   component                    \n     * @param   {Object} [currentNodeData=this._data] Used for recursion. Don't set.\n     * @returns {Object}       found an object of the form { parentNodeData: dataObject, index: integer }. Otherwise null.\n     */\n    AdobeDCXBranchCore.prototype._nodeDataOfParentOfComponent = function (component, currentNodeData) {\n        currentNodeData = currentNodeData || this._data;\n        \n        var i, id = component._data.id, components = currentNodeData.components;\n        if (components) {\n            for (i = 0; i < components.length; i++) {\n                var componentData = components[i];\n                if (componentData.id === id) {\n                    return { parentNodeData: currentNodeData, index: i };\n                }\n            }\n        }\n            \n        var children = currentNodeData.children;\n        if (children) {\n            for (i = 0; i < children.length; i++) {\n                var childData = children[i];\n                var found = this._nodeDataOfParentOfComponent(component, childData);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n        \n        return null;\n    };\n    \n    /**\n     * Collects all the updates necessary to update the absolute paths of all sub nodes and components.\n     * @private\n     * @param {Object} currentNode         \n     * @param {String} currentAbsolutePath \n     * @param {Array}  updates             \n     */\n    AdobeDCXBranchCore.prototype._determineAbsolutePathChangesRecursively = function (currentNode, currentAbsolutePath, updates) {\n        var i, components = currentNode.components;\n        if (components) {\n            for (i = 0; i < components.length; i++) {\n                var componentData = components[i];\n                var component = this._allComponents[componentData.id];\n                \n                updates.push({ item: component, parentPath: currentAbsolutePath, absPath: dcxUtil.appendPathElements(currentAbsolutePath, componentData.path) });\n            }\n        }\n            \n        var children = currentNode.children;\n        if (children) {\n            for (i = 0; i < children.length; i++) {\n                var nodeData = children[i];\n                var node = this._allNodes[nodeData.id];\n                var path = nodeData.path;\n                \n                var newAbsPath = path ? dcxUtil.appendPathElements(currentAbsolutePath, path) : currentAbsolutePath;\n                updates.push({ item: node, parentPath: currentAbsolutePath, absPath: (path ? newAbsPath : undefined) });\n                \n                // recurse down\n                this._determineAbsolutePathChangesRecursively(nodeData, newAbsPath, updates);\n            }\n        }\n    };\n    \n    /**\n     * Updates the path of a node. Caller must dirty the branch.\n     * @private\n     * @param {Object} node    \n     * @param {String} newPath\n     */\n    AdobeDCXBranchCore.prototype._setPathOfNode = function (node, newPath) {\n        // We need to recalculate the absolute and parent paths of the node and its components as well as\n        // of any of its sub nodes and their components.\n        // At the same time we need to guarantee that all absolute paths are unique and leave the\n        // DOM untouched in case of an error.\n        \n        var newAbsPath = newPath ? dcxUtil.appendPathElements(node.parentPath, newPath) : node.parentPath;\n\n        var updates = [ { item: node, absPath: (newPath ? newAbsPath : undefined) } ];\n        this._determineAbsolutePathChangesRecursively(node._data, newAbsPath, updates);\n        \n        // Create a new cache by duplicating the old cache, removing the old paths of the changed items and then adding\n        // the new paths while checking for duplicates.\n        var i, update, newAbsolutePaths = dcxUtil.flatCopy(this._absolutePaths);\n        for (i = 0; i < updates.length; i++) {\n            var item = updates[i].item;\n            if (item._data.path) {\n                delete newAbsolutePaths[this._normalizedAbsolutePathForItem(item)];\n            }\n        }\n        for (i = 0; i < updates.length; i++) {\n            update = updates[i];\n            if (update.absPath) {\n                var absPath = update.absPath.toLowerCase();\n                if (newAbsolutePaths[absPath]) {\n                    throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n                }\n                newAbsolutePaths[absPath] = update.item;\n            }\n        }\n        \n        // Now we can update the parent paths of the items since we know that they are all unique\n        for (i = 0; i < updates.length; i++) {\n            update = updates[i];\n            if (update.parentPath) {\n                update.item._parentPath = update.parentPath;\n            }\n        }\n        node._data.path = newPath;\n        this._absolutePaths = newAbsolutePaths;\n    };\n    \n    /**\n     * Updates the path of a component. Caller must dirty the branch.\n     * @private\n     * @param {Object} component \n     * @param {String} newPath   \n     */\n    AdobeDCXBranchCore.prototype._setPathOfComponent = function (component, newPath) {\n        if (!this._allComponents[component.id]) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown component.');\n        }\n        \n        var newAbsPath = dcxUtil.appendPathElements(component.parentPath, newPath).toLowerCase();\n        if (this._absolutePaths[newAbsPath]) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path for component: ' + newAbsPath);\n        }\n\n        delete this._absolutePaths[this._normalizedAbsolutePathForItem(component)];\n        this._absolutePaths[newAbsPath] = component;\n        \n        component._data.path = newPath;\n    };\n    \n    /**\n     * Sets the dirty flag and (optionally) the compositeState\n     * @private\n     * @param {Boolean} preserveCompositeState \n     */\n    AdobeDCXBranchCore.prototype._setDirty = function (preserveCompositeState) {\n        this._isDirty = true;\n        this._local().change = this.changeCount + 1;\n        if (!preserveCompositeState && (this._data.state === 'unmodified' || !this._data.state)) {\n            this._data.state = 'modified';\n        }\n    };\n    \n    /**\n     * Returns a normalized and lowercased copy of the absolute path of item.\n     * @private\n     * @param   {Object}   item\n     * @param   {Object} newParent Optional. If given this parent will be used to determine the absolute path.\n     * @returns {Object} \n     */\n    AdobeDCXBranchCore.prototype._normalizedAbsolutePathForItem = function (item, newParent) {\n        var path;\n        if (newParent) {\n            path = dcxUtil.appendPathElements(newParent.absolutePath || newParent._parentPath, item.path);\n        } else {\n            path = item.absolutePath;\n        }\n        return path.toLowerCase();\n    };\n    \n    /**\n     * @private\n     */\n    AdobeDCXBranchCore.prototype._hasSameEndpoint = function (item) {\n        var targetHref = this._getBranchOf(this).compositeHref;\n        var sourceHref = this._getBranchOf(item).compositeHref;\n        if (targetHref && sourceHref) {\n            var targetEndpoint = dcxUtil.endPointOf(targetHref);\n            var sourceEndpoint = dcxUtil.endPointOf(sourceHref);\n            if (targetEndpoint && sourceEndpoint && targetEndpoint !== sourceEndpoint) {\n                return false;\n            }\n        }\n        return true;\n    };\n    \n    \n    /**\n     * This gets called in the context of the component callback in both _copyChild and _copyComponent.\n     * It updates local storage, source hrefs and state of the copied component based on the circumstances.\n     * \n     * @private\n     * \n     * @param {Object}  originalComponent The component that got copied.\n     * @param {Object}  copiedComponent   The copy of the component.\n     * @param {Boolean} isSameComposite   Whether the original and copied component are from the same \n     *                                    composite.\n     * @param {Boolean} isSameEndpoint    Whether the composite of original and copy reside at the same \n     *                                    endpoint.\n     * @param {Boolean} canChangeId       Whether it is ok to change the id of the component.\n     * @param {Object}  localStorage      The local storage object responsible for the copy -- can \n     *                                    be undefined.\n     * @param {Object}  localData         The new local data section for the target branch.\n     * @param {Object}  sourceLocalData   The local data section of the soure branch to be used when\n     *                                    copying within the same composite.\n     */\n    function updateStorageForCopiedComponent(originalComponent, copiedComponent,\n                                              isSameComposite, isSameEndpoint, canChangeId,\n                                              localStorage, localData, sourceLocalData) {\n        var targetCore = copiedComponent._owner._core;\n        var sourceCore = originalComponent._owner._core;\n        \n        // If the component gets copied within a composite and if it retains its id it by\n        // definition retains its identity.\n        var retainsIdentity = isSameComposite && (originalComponent.id === copiedComponent.id);\n        // See whether the original component already has a source href\n        var sourceHref = sourceCore._getSourceHrefOfComponent(originalComponent);\n        // See whether we have an existing component with the same id that we are going to update.\n        var existingComponentWithSameId = targetCore.getComponentWithId(copiedComponent.id);\n        \n        // Currently S2SC is only possible if all of the below is true:\n        var s2scIsPossible = isSameEndpoint\n            && (!existingComponentWithSameId || !existingComponentWithSameId.etag)\n            && (originalComponent.state === 'unmodified');\n        \n        // Regardless of whether S2SC is possible or not, we only want to do it if we are dealing \n        // with a new component and the original doesn't already have a source href.\n        var s2scIsDesired = !retainsIdentity && !sourceHref;\n        \n        // We assume that S2SC is required if it is desired. We set this to false later if we find\n        // that we have a valid local file that we could upload instead.\n        var s2scIsRequired = s2scIsDesired;\n        \n        if (canChangeId && !existingComponentWithSameId) {\n            if (sourceHref || s2scIsDesired) {\n                // TODO: Figure out whether we already have upload results from a previously\n                // interrupted push. If so then change the id so that we don't have to copy\n                // the asset again.\n\n                if (originalComponent.id === copiedComponent.id) {\n                    // TODO: See whether we can remove this when we get full s2sc support.\n\n                    // Currently the storage service does not support updates via s2sc. If we are\n                    // using s2sc we need to ensure that we do not reuse a component id that might\n                    // have existed previously. An example would be if I copy a library element into\n                    // a composite, push, delete the element and then copy it again.\n                    copiedComponent._data.id = dcxUtil.generateUuid();\n                    copiedComponent.state = 'modified';\n                    copiedComponent.etag = undefined;\n                    copiedComponent.version = undefined;\n                    copiedComponent.md5 = undefined;\n                    copiedComponent.length = undefined;\n                }\n            }\n        }\n\n        // Copy over local storage mapping if available.\n        if (localStorage) {\n            if (localStorage._copyComponentMapping(originalComponent.id, sourceLocalData, copiedComponent.id, localData)) {\n                // We have a local file, so a s2s copy is no longer mandatory\n                s2scIsRequired = false;\n                if (!retainsIdentity) {\n                    // This is a new component in the composite. We need to ensure that it gets either uploaded or copied.\n                    copiedComponent.state = 'modified';\n                }\n            }\n        }\n\n        // Update the source href for S2SC\n        if (s2scIsDesired) {\n            if (s2scIsPossible) {\n                sourceHref =  sourceCore._getHrefOfComponent(originalComponent);\n\n                targetCore._setSourceHrefOfComponent(sourceHref, copiedComponent, localData);\n                if (!sourceHref && s2scIsRequired) {\n                    // We don't have a source href and we don't have local storage\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_STATE,\n                        'Failed to determine the source href of a component that does not have a local file.');\n                }\n            } else if (s2scIsRequired) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_STATE,\n                        'Could not use server-to-server copy for component ' + originalComponent.id);\n            }\n        } else {\n            // We need to set the source href whether it is defined or not.\n            targetCore._setSourceHrefOfComponent(sourceHref, copiedComponent, localData);\n        }\n        \n        if (sourceHref) {\n            copiedComponent.state = 'modified';\n        }\n    }\n    \n    \n    /**\n     * <p>Deep copies the given component and adds it as a new component to this branch.</p>\n     * \n     * <p>This function gets called in various different situations and thus needs to work correctly or\n     * fail with proper errors in the possible permutations of:</p>\n     * \n     * <p>- locality: whether the source and target are from the same branch, different branches of the \n     * same composite, different composites or even composites with different endpoints.</p>\n     * <p>- identity: whether the node should be a new node or replace (update) an existing one.</p>\n     * <p>- operational model: whether local storage is available and if so whether the component file \n     * is stored locally.</p>\n     * <p>- state: whether the component is unmodified, modified with a local file or modified with \n     * a source href.</p>\n     * \n     * <p>After some initial verification and preparation the function first starts any necessary \n     * asynchronous operations (i.e. the file copy). If none are necessary or once they all have \n     * succeeded it calls _copyComponentModel to do the actual model changes, passing in a callback that \n     * gets called for each component (one in this case) and that takes care of udating local storage \n     * and/or source href for a later server-to-server copy request.</p>\n     * \n     * @private\n     */\n    AdobeDCXBranchCore.prototype._copyComponent = function (component, parentNode, newPath, newId, replaceExisting, callback) {\n        if (!component) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"component\".');\n        }\n        if (callback && typeof callback !== 'function') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param callback must be a function.');\n        }\n        \n        var self = this;\n        var sourceCore = component._owner._core;\n        var isSameComposite = this._isSameComposite(sourceCore);\n        var isSameEndpoint = isSameComposite || this._hasSameEndpoint(component);\n        var sourceLocalData = sourceCore._local();\n        var localStorage = this._localStorage;\n        var sourceLocalStorage = sourceCore._localStorage;\n        var useLocalStorage = localStorage && sourceLocalStorage;\n        \n        // Verify parameters\n        if (useLocalStorage && !callback  && !isSameComposite) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Must pass a callback when copying between two different composites.');\n        }\n\n        if (!useLocalStorage && !isSameEndpoint) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'Cannot copy between two different endpoints without local storage.');\n        }\n        \n        // This gets passed as copyComponentCallback into the call to _copyComponentCore. It updates\n        // the local file mapping and source href of the copied component as necessary.\n        var copyComponentCallback = function (originalComponent, copiedComponent, localData) {\n            updateStorageForCopiedComponent(originalComponent, copiedComponent, isSameComposite, isSameEndpoint, /*canChangeId*/ !newId,\n                                        useLocalStorage ? localStorage : undefined, localData, sourceLocalData);\n        };\n        \n        var componentFilePath = useLocalStorage ? sourceLocalStorage.componentAssetPath(component, sourceLocalData) : undefined;\n        \n        // Special case: If no callback is given we perform the copy synchronously since all we have to do is\n        // to copy the local storage mapping for each component.\n        if (!callback) {\n            return this._copyComponentModel(component, parentNode, replaceExisting, newPath, newId, copyComponentCallback);\n        }\n        \n        if (isSameComposite || !componentFilePath) {\n            // We do not need to copy a local file\n            try {\n                callback(undefined, this._copyComponentModel(component, parentNode, replaceExisting, newPath, newId, copyComponentCallback));\n            } catch (x) {\n                callback(x);\n            }\n        } else {\n            // We are going to use _copyComponentCore to do the actual model work, but we need to do any asynchronous operations \n            // (file copies, etc.) beforehand.\n            var newSourceLocalData = {};\n            // We let local storage handle the copy and polpulate the new local data storage mapping\n            localStorage.ingestComponentAsset(component, componentFilePath, /*copy*/ true, newSourceLocalData, function (error) {\n                if (error) {\n                    callback(error);\n                } else {\n                    try {\n                        sourceLocalData = newSourceLocalData;\n                        callback(undefined, self._copyComponentModel(component, parentNode, replaceExisting,\n                                                                    newPath, newId, copyComponentCallback));\n                    } catch (x) {\n                        callback(x);\n                    }\n                }\n            });\n        }\n    };\n    \n    /**\n     * Copies the given component from a different branch of the same composite into this branch. \n     * Notice that this method and its call to copyComponentCallback are synchronous. If you need to \n     * do anything asynchronous you will need to do that before (preferably) or after calling this \n     * method.\n     * \n     * Throws if it runs into an error.\n     * @private\n     * @param   {AdobeDCXComponent} component               The component to copy.\n     * @param   {AdobeDCXNode}      [parentNode]            Optional: The node to copy the component to. \n     *                                                      If none if provided then the component will \n     *                                                      be added to the root.\n     * @param   {Boolean}           [replaceExisting]       Optional: Default is false. Whether to \n     *                                                      replace an existing component.\n     * @param   {String}            [newPath]               Optional: If provided the copy of the \n     *                                                      component will be assigned this a its \n     *                                                      path property and it will also get \n     *                                                      assigned a new id.\n     * @param   {String}            [newId]                 Optional: If provided the copy of the \n     *                                                      component will be assigned this as its id.\n     * @param   {componentCallback} [copyComponentCallback] Optional. Gets called for each component \n     *                                                      that gets copied. Caller can use this to \n     *                                                      tweak the component before it gets added \n     *                                                      to the DOM.\n     *                                                      Signature: function (originalComponent, \n     *                                                      copiedCoponent, localDataOfTargetBranch)\n     * @returns {AdobeDCXComponent}                         The new component\n     */\n    AdobeDCXBranchCore.prototype._copyComponentModel = function (component, parentNode, replaceExisting,\n                                                                  newPath, newId, copyComponentCallback) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!component) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"component\".');\n        }\n        \n        var sourceBranch = component._owner;\n        \n        // Create the new component as a copy of component\n        var newComponent = new AdobeDCXComponent(JSON.parse(JSON.stringify(component._data)));\n        if (newPath) {\n            newComponent.path = newPath;\n            newComponent.id = newId || dcxUtil.generateUuid();\n        } else if (newId) {\n            newComponent.id = newId;\n        }\n        newComponent._owner = this._owner;\n        if (component.id !== newComponent.id || !this._isSameComposite(sourceBranch._core)) {\n            newComponent.state = 'modified';\n            newComponent.etag = undefined;\n            newComponent.version = undefined;\n            newComponent.md5 = undefined;\n            newComponent.length = undefined;\n        }\n        \n        // Verify pre-existing component\n        var existingComponent = this._allComponents[newComponent.id];\n        if (existingComponent && !replaceExisting) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Component already exists.');\n        }\n        if (replaceExisting && !existingComponent) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Could not find existing component.');\n        }\n        \n        // Determine the new parent\n        var index, newParent;\n        if (!replaceExisting) {\n            newParent = (parentNode ? this._allNodes[parentNode.id] : this.rootNode);\n            if (!newParent) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n            }\n        } else {\n            var found = this._nodeDataOfParentOfComponent(existingComponent);\n            if (!found) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Parent node of existing component not found in this branch.');\n            }\n            var parentId = found.parentNodeData.id;\n            newParent = this._allNodes[parentId];\n            if (!newParent) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Unknown parent node.');\n            }\n            index = found.index;\n        }\n        newComponent._parentPath = newParent.absolutePath || newParent._parentPath;\n        \n        // Check path\n        if (!dcxUtil.isValidPath(newComponent.path)) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Component path must be a valid path for a component.');\n        }\n        var absPath = this._normalizedAbsolutePathForItem(newComponent);\n        var itemWithSamePath = this._absolutePaths[absPath];\n        if (itemWithSamePath && itemWithSamePath !== existingComponent) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n        }\n        \n        var newLocalData = this._local();\n        if (copyComponentCallback) {\n            // Call back to give the caller a chance to tweak the copied component before we insert it.\n            newLocalData = dcxUtil.deepCopy(newLocalData);\n            copyComponentCallback(component, newComponent, newLocalData);\n        }\n        \n        // Now we can make the actual model changes:\n        \n        // Insert new component\n        var components = newParent._data.components;\n        if (replaceExisting) {\n            components[index] = newComponent._data;\n        } else {\n            if (components) {\n                components.push(newComponent._data);\n            } else {\n                newParent._data.components = [ newComponent._data ];\n            }\n        }\n\n        // Update caches\n        this._data.local = newLocalData;\n        this._allComponents[newComponent.id] = newComponent;\n        this._absolutePaths[absPath] = newComponent;\n\n        this._setDirty();\n\n        // SUCCESS\n        return newComponent;\n    };\n    \n    /**\n     * <p>Deep copies the given child node and its nodes and components into this branch as a new child.\n     * The node can be from the same or from a different composite. \n     * If it is a root node then you must specify newPath since it can't keep its original path.</p>\n     * \n     * <p>This function gets called in various different situations and thus needs to work correctly or\n     * fail with proper errors in the various possible permutations:</p>\n     * \n     * <p>- whether the source and target are from the same branch, different branches of the \n     * same composite, different composites or even composites with different endpoints.</p>\n     * <p>- whether the node should be a new node or replace (update) an existing one.</p>\n     * <p>- whether local storage is available and if so whether the component files are stored locally.</p>\n     * <p>- whether the components are unmodified, modified with a local file or modified with a source href.</p>\n     * \n     * <p>After some initial verification and preparation the function first starts any necessary \n     * asynchronous operations (i.e. file copies). If none are necessary or once they all have \n     * succeeded it calls _copyChildModel to do the actual model changes, passing in a callback that \n     * gets called for each component and that takes care of udating local storage and/or source hrefs\n     * for a later server-to-server copy request.</p>\n     * \n     * <p>The function creates copies of the lookup tables and manipulates those during the copy\n     * operation. Only once everything has succeeded it inserts the new node (and removes the one to replace)\n     * and replaces the lookup tables with its copies so that it can bail out at any time before that\n     * without having actually modified the DOM.</p>\n     * \n     * @private\n     */\n    AdobeDCXBranchCore.prototype._copyChild = function (node, parentNode, index, newPath, newId, replaceExisting, callback) {\n        if (!node) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting param \"node\".');\n        }\n        \n        var self = this;\n        var sourceCore = node._owner._core;\n        \n        var isSameComposite = this._isSameComposite(sourceCore);\n        var isSameEndpoint = isSameComposite || this._hasSameEndpoint(node);\n        \n        var sourceLocalData = sourceCore._local();\n        var localStorage = this._localStorage;\n        var sourceLocalStorage = sourceCore._localStorage;\n        var useLocalStorage = localStorage && sourceLocalStorage;\n        \n        var sourceComponents = sourceCore._recursivelyGetAllComponentsOfChild(node);\n        \n        if (sourceComponents.length > 0) {\n            if (useLocalStorage && !callback && !isSameComposite) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Must pass a callback when copying between two different composites.');\n            }\n\n            if (!useLocalStorage && !isSameEndpoint) {\n                throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'Cannot copy components between two different endpoints without local storage.');\n            }\n        }\n        \n        // This gets passed as copyComponentCallback into the call to _copyComponentCore. It updates\n        // the local file mapping and source href of the copied component as necessary.\n        var copyComponentCallback = function (originalComponent, copiedComponent, localData) {\n            updateStorageForCopiedComponent(originalComponent, copiedComponent, isSameComposite, isSameEndpoint, /*canChangeId*/ true,\n                                        useLocalStorage ? localStorage : undefined, localData, sourceLocalData);\n        };\n        \n        // Special case: If no callback is given we perform the copy synchronously since all we have to do is\n        // to copy the local storage mapping for each component.\n        if (!callback) {\n            return this._copyChildModel(node, parentNode, index, replaceExisting, newPath, newId, copyComponentCallback);\n        }\n        \n        // Used at various places below to finalize the copy operation\n        var finalizeCopy = function () {\n            callback(undefined, self._copyChildModel(node, parentNode, index, replaceExisting, newPath,\n                                                    newId, copyComponentCallback));\n        };\n        \n        if (sourceComponents.length === 0 || isSameComposite || !useLocalStorage) {\n            try {\n                finalizeCopy();\n            } catch (x) {\n                callback(x);\n            }\n        } else {\n            // We are going to use _copyChildModel to do the actual model work, but we need to do any asynchronous operations \n            // (file copies, etc.) beforehand.\n            var newSourceLocalData = {};\n\n            var i, c = sourceComponents.length;\n            var numComponentsToGo = 0, asyncError;\n            \n            // Gets passsed in as the callback to localStorage.ingestComponentAsset()\n            var copyComplete = function (error) {\n                if (error && !asyncError) {\n                    asyncError = error;\n                }\n                numComponentsToGo--;\n                if (numComponentsToGo === 0) {\n                    if (asyncError) {\n                        callback(asyncError);\n                    } else {\n                        try {\n                            sourceLocalData = newSourceLocalData;\n                            finalizeCopy();\n                        } catch (x) {\n                            callback(x);\n                        }\n                    }\n                }\n            };\n\n            for (i = 0; i < c; i++) {\n                var component = sourceComponents[i];\n                var filePath = sourceLocalStorage.componentAssetPath(component, sourceLocalData);\n                if (filePath) {\n                    // We let local storage handle the copy and polpulate the new local data storage mapping\n                    numComponentsToGo++;\n                    localStorage.ingestComponentAsset(component, filePath, /*copy*/ true, newSourceLocalData, copyComplete);\n                }\n            }\n            \n            if (numComponentsToGo === 0) {\n                try {\n                    finalizeCopy();\n                } catch (y) {\n                    callback(y);\n                }\n            }\n        }\n    };\n    \n    /**\n     * Copies the given child node with all its nodes and components. Notice that this method and \n     * its call to copyComponentCallback are synchronous. If you need to do anything asynchronous you \n     * will need to do that before (preferably) or after calling this method.\n     * \n     * Throws if it runs into an error.\n     * @private\n     * @param   {AdobeDCXNode} node                  The child node (or whole branch) to copy.\n     * @param   {AdobeDCXNode} parentNode            The parent node to copy the child node to.\n     *                                               Gets ignored if replaceExisting is true.\n     * @param   {Integer}      index                 Optional: If given and less than or equal to the \n     *                                               current number of children of the parentNode the \n     *                                               node gets inserted at the given index. Otherwise \n     *                                               it gets added to the end. Gets ignored if \n     *                                               replaceExisting is true.\n     * @param   {Boolean}      replaceExisting       Optional: Default is false.\n     * @param   {String}       newPath               Optional: If provided the copy of the component \n     *                                               will be assigned this a its path property.\n     * @param   {String}       newId                 Optional: If provided the copy of the component \n     *                                               will be assigned this as its id.\n     * @param   {Boolean}      reuseIds              If true we try to reuse ids.\n     * @param   {nodeCallback} copyComponentCallback Optional. Gets called for each component that \n     *                                               gets copied. Caller can use this to tweak the \n     *                                               component before it gets added to the DOM.\n     *                                               Should throw if something goes wrong.\n     *                                               Signature: function (originalComponent, \n     *                                               copiedCoponent, localDataOfTargetBranch)\n     * @returns {AdobeDCXNode}          new child node.\n     */\n    AdobeDCXBranchCore.prototype._copyChildModel = function (node, parentNode, index, replaceExisting, newPath, newId, copyComponentCallback) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        \n        var sourceBranch = node._owner;\n        \n        // Create the new node\n        var newNode = new AdobeDCXNode(JSON.parse(JSON.stringify(node._data)));\n        if (newPath) {\n            newNode.path = newPath;\n            newNode.id = newId || dcxUtil.generateUuid();\n        } else if (newId) {\n            newNode.id = newId;\n        }\n        \n        newNode._owner = this._owner;\n        if (node.isRoot) {\n            // Remove unnecessary properties from an embedded composite a.k.a element\n            delete newNode._data.local;\n            delete newNode._data['manifest-format-version'];\n        }\n        \n        // Verify pre-existing node\n        var existingNode = this._allNodes[newNode.id];\n        if (existingNode && !replaceExisting) {\n            throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Child node already exists.');\n        }\n        if (replaceExisting && !existingNode) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Could not find existing node to replace.');\n        }\n        \n        // Determine the new parent\n        var newParent;\n        if (!replaceExisting) {\n            newParent = (parentNode ? this._allNodes[parentNode.id] : this.rootNode);\n            if (!newParent) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown parent node.');\n            }\n        } else {\n            // We ignore any parent node that was passed in and just use the parent node of the node to replace.\n            var found = this._nodeDataOfParentOfNode(existingNode);\n            if (!found) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Parent of existing node not found in this branch.');\n            }\n            var parentId = found.parentNodeData.id;\n            newParent = this._allNodes[parentId];\n            if (!newParent) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Unknown parent node.');\n            }\n            index = found.index;\n        }\n        newNode._parentPath = newParent.absolutePath || newParent._parentPath;\n\n        // Verify path\n        if (newNode.path) {\n            if (!dcxUtil.isValidPath(newNode.path)) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Node path must be a valid path for a node.');\n            }\n            // Check that the resulting absolute path of the node will be unique\n            var absPath = this._normalizedAbsolutePathForItem(newNode);\n            var itemWithSamePath = this._absolutePaths[absPath];\n            if (itemWithSamePath && itemWithSamePath !== existingNode) {\n                throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n            }\n        }\n        \n        // Now that we have passed all the checks above we can start making the necessary changes.\n        // We do so by creating copies of our lookup tables and the local storage data so that we can\n        // back out cleanly if we run into a problem while traversing the new node's hiearchy.\n        \n        var newAllNodes = dcxUtil.flatCopy(this._allNodes);\n        var newAllComponents = dcxUtil.flatCopy(this._allComponents);\n        var newAbsolutePaths = dcxUtil.flatCopy(this._absolutePaths);\n        var newLocalData = dcxUtil.deepCopy(this._local());\n        \n        // Recurses through the node and its descendents and removes its contents from all the lookup tables\n        // that are being passed in.\n        var recursivelyRemoveNodeFromLookups = function (node, core, allNodes, allComponents, absolutePaths, localData) {\n            delete allNodes[node.id];\n            if (node.path) {\n                delete absolutePaths[core._normalizedAbsolutePathForItem(node)];\n            }\n            \n            var i, count;\n            var children = node._data.children;\n            if (children) {\n                count = children.length;\n                for (i = 0; i < count; i++) {\n                    recursivelyRemoveNodeFromLookups(allNodes[children[i].id], core, allNodes, allComponents, absolutePaths, localData);\n                }\n            }\n            \n            var components = node._data.components;\n            if (components) {\n                count = components.length;\n                for (i = 0; i < count; i++) {\n                    var component = allComponents[components[i].id];\n                    delete allComponents[component.id];\n                    delete absolutePaths[core._normalizedAbsolutePathForItem(component)];\n                    if (core._localStorage) {\n                        core._localStorage.removeComponentAsset(component, localData);\n                        core._setSourceHrefOfComponent(undefined, component, localData);\n                    }\n                }\n            }\n        };\n        \n        if (existingNode) {\n            recursivelyRemoveNodeFromLookups(existingNode, this, newAllNodes, newAllComponents, newAbsolutePaths, newLocalData);\n        }\n        \n        var self = this;\n        \n        var recursivelyAddNodeToLookups = function (node, owner, sourceBranch, allNodes, allComponents, absolutePaths, localData, sourceLocalData) {\n            if (allNodes[node.id]) {\n                throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate node id: ' + node.id);\n            }\n            allNodes[node.id] = node;\n\n            var absPath;\n            if (node.path) {\n                absPath = owner._core._normalizedAbsolutePathForItem(node);\n                if (absolutePaths[absPath]) {\n                    throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n                }\n                absolutePaths[absPath] = node;\n            }\n\n            var i, count, children = node._data.children;\n            if (children) {\n                count = children.length;\n                for (i = 0; i < count; i++) {\n                    var child = new AdobeDCXNode(children[i]);\n                    if (allNodes[child.id]) {\n                        child.id = dcxUtil.generateUuid();\n                    }\n                    child._owner = owner;\n                    child._parentPath = node.absolutePath || node._parentPath;\n                    recursivelyAddNodeToLookups(child, owner, sourceBranch, allNodes, allComponents, absolutePaths, localData, sourceLocalData);\n                }\n            }\n\n            var components = node._data.components;\n            if (components) {\n                count = components.length;\n                for (i = 0; i < count; i++) {\n                    var component = new AdobeDCXComponent(components[i]);\n                    var originalComponentId = component.id;\n                    if (allComponents[originalComponentId]) {\n                        component.id = dcxUtil.generateUuid();\n                        component.state = 'modified';\n                        component.etag = undefined;\n                        component.version = undefined;\n                        component.md5 = undefined;\n                        component.length = undefined;\n                    }\n                    component._owner = owner;\n                    component._parentPath = node.absolutePath || node._parentPath;\n                    if (copyComponentCallback) {\n                        copyComponentCallback(sourceBranch.getComponentWithId(originalComponentId), component, localData);\n                    }\n                    if (allComponents[component.id]) {\n                        throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate component id: ' + component.id);\n                    }\n                    allComponents[component.id] = component;\n                    absPath = owner._core._normalizedAbsolutePathForItem(component);\n                    if (absolutePaths[absPath]) {\n                        throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'Duplicate absolute path: ' + absPath);\n                    }\n                    absolutePaths[absPath] = component;\n                }\n            }\n        };\n        \n        recursivelyAddNodeToLookups(newNode, this._owner, sourceBranch, newAllNodes, newAllComponents, newAbsolutePaths, newLocalData, sourceBranch._local());\n        \n        // If none of the previous code has thrown we can actually add the new node to the model and upadate the caches.\n        \n        if (replaceExisting) {\n            newParent._data.children[index] = newNode._data;\n        } else {\n            var children = newParent._data.children;\n            if (children) {\n                if (!(index >= 0 && index <= children.length)) {\n                    index = children.length;\n                }\n                if (index === children.length) {\n                    // Simple case: add to end\n                    children[index] = newNode._data;\n                } else {\n                    // Insert\n                    children.splice(index, 0, newNode._data);\n                }\n            } else {\n                newParent._data.children = [ newNode._data ];\n            }\n        }\n\n        // Update caches, local data and lookups\n        self._allNodes = newAllNodes;\n        self._allComponents = newAllComponents;\n        self._absolutePaths = newAbsolutePaths;\n        self._data.local = newLocalData;\n\n        self._setDirty();\n\n        // SUCCESS\n        return newNode;\n    };\n    \n    /**\n     * Verifies the integrity of the in-memory structures of the branch. Looks for incorrect caches/lookup tables, incorrect\n     * object references and cycles/duplicate objects. Also, optionally, verifies that all asset files exist locally.\n     * @private\n     * @param   {Boolean}  shouldBeComplete Whether to check for the existence of all component assets. @Warning: This check is using synchronous file system calls.\n     * @param   {Function} logger           Optional. A function that gets called for every error found. Signature: function (string)\n     * @param   {Object}   fs               Optional. The file system object to use in the shouldBeComplete check\n     * @returns {Array}    Array of errors or null if everything is OK.\n     */\n    AdobeDCXBranchCore.prototype._verifyIntegrity = function (shouldBeComplete, logger, fs) {\n        var self = this;\n        var errors = [];\n        var startedLog = false;\n        \n        var logError = function (message) {\n            errors.push(new AdobeDCXError(AdobeDCXError.INVALID_STATE, message));\n            if (logger) {\n                if (!startedLog) {\n                    logger('Branch for composite ' + self.rootNode.id + ' has the following errors:');\n                    startedLog = true;\n                }\n                logger('   ' + message);\n            }\n            return false;\n        };\n        \n        var assert = function (condition, message) {\n            if (!condition) {\n                return logError(message);\n            }\n            return true;\n        };\n        \n        var itemsEncountered = [];\n        var itemEncountered = function (item) {\n            if (itemsEncountered.indexOf(item) < 0 || logError('Item ' + item.id + ' encountered more than once')) {\n                itemsEncountered.push(item);\n            }\n        };\n        \n        // Make copies of the caches\n        var allComponents = dcxUtil.flatCopy(this._allComponents);\n        var allNodes = dcxUtil.flatCopy(this._allNodes);\n        var absolutePaths = dcxUtil.flatCopy(this._absolutePaths);\n        \n        var absPathArray = Object.keys(absolutePaths);\n        var i, c = absPathArray.length;\n        for (i = 0; i < c; i++) {\n            var absPath = absPathArray[i];\n            assert(absPath.charAt(0) === '/', 'Absolute path ' + absPath + ' does not start with a slash.');\n        }\n        \n        var recurse = function (nodeData, parentPath) {\n            var i, absPath;\n            var children = nodeData.children;\n            if (children) {\n                for (i = 0; i < children.length; i++) {\n                    var childData = children[i];\n                    var node = allNodes[childData.id];\n                    if (node || logError('Node ' + childData.id + ' is not in cache.')) {\n                        itemEncountered(node);\n                        assert(node._data === childData, 'Node ' + node.id + ' _data property incorrect.');\n                        delete allNodes[node.id];\n                        if (node.path && node._owner) {\n                            absPath = self._normalizedAbsolutePathForItem(node);\n                            if (absolutePaths[absPath] || logError('Absolute path of node ' + node.id + ' (' + absPath + ') is not in cache.')) {\n                                delete absolutePaths[absPath];\n                            }\n                        }\n                        assert(node._parentPath === parentPath, 'Parent path of node ' + node.id + ' should be ' + parentPath + ' but is ' + node._parentPath);\n                        assert(node._owner === self._owner, 'Node ' + node.id + ' _owner property is not correct.');\n                    }\n                    recurse(childData, childData.path ? dcxUtil.appendPathElements(parentPath, childData.path) : parentPath);\n                }\n            }\n            var components = nodeData.components;\n            if (components) {\n                for (i = 0; i < components.length; i++) {\n                    var componentData = components[i];\n                    var component = allComponents[componentData.id];\n                    if (component || logError('Component ' + componentData.id + ' is not in cache.')) {\n                        itemEncountered(component);\n                        assert(component._data === componentData, 'Component ' + component.id + ' _data property incorrect.');\n                        delete allComponents[component.id];\n                        if (component._owner) {\n                            absPath = self._normalizedAbsolutePathForItem(component);\n                            if (absolutePaths[absPath] || logError('Absolute path ' + absPath + ' is not in cache.')) {\n                                delete absolutePaths[absPath];\n                            }\n                        }\n                        assert(component._parentPath === parentPath, 'Parent path of component ' + component.id + ' should be ' + parentPath + ' but is ' + component._parentPath);\n                        assert(component._owner === self._owner, 'Component ' + component.id + ' _owner property is not correct.');\n                    }\n                }\n                \n            }\n        };\n        \n        // Verify that the root node is there\n        var rootNode = absolutePaths[AdobeDCXNode.ROOT_PATH];\n        if (assert(rootNode, 'Cannot find root node via path')) {\n            assert(rootNode.id === this._data.id, 'Root node has correct id');\n            assert(rootNode.path === AdobeDCXNode.ROOT_PATH, 'Root node has correct path');\n            assert(rootNode._parentPath === '', 'Root node has correct parent path');\n            assert(rootNode._owner === this._owner, 'Root node has correct owner');\n            assert(rootNode._data === this._data, 'Root node has correct data');\n            if (assert(allNodes[rootNode.id] === rootNode, 'Cannot find root node via id')) {\n                delete allNodes[rootNode.id];\n            }\n            delete absolutePaths[AdobeDCXNode.ROOT_PATH];\n        }\n        \n        recurse(this._data, AdobeDCXNode.ROOT_PATH);\n        \n        // Ensure that all our chaches are empty\n        var keysLeft = Object.keys(allComponents);\n        for (i = 0; i < keysLeft.length; i++) {\n            logError('Component ' + keysLeft[i] + ' is in cache but could not be found.');\n        }\n        keysLeft = Object.keys(allNodes);\n        for (i = 0; i < keysLeft.length; i++) {\n            logError('Node ' + keysLeft[i] + ' is in cache but could not be found.');\n        }\n        keysLeft = Object.keys(absolutePaths);\n        for (i = 0; i < keysLeft.length; i++) {\n            logError('Absolute path ' + keysLeft[i] + ' is in cache but could not be found.');\n        }\n        \n        // Now we check the local section to ensure that we do not have any stale entries\n        // and (optionally) that all files are present.\n        if (this._localStorage) {\n            var componentIds = this._localStorage.componentIds(this._local());\n            for (i = 0; i < componentIds.length; i++) {\n                assert(this._allComponents[componentIds[i]], 'Component ' + componentIds[i] + ' is in local storage mapping but could not be found in the manifest.');\n            }\n            if (shouldBeComplete) {\n                componentIds = Object.keys(this._allComponents);\n                for (i = 0; i < componentIds.length; i++) {\n                    var componentId = componentIds[i];\n                    var component = this._allComponents[componentId];\n                    var assetPath = this._localStorage.componentAssetPath(component, this._local());\n                    if (assert(assetPath, 'Component ' + componentId + ' does not have an entry in local storage mapping.') && fs) {\n                        assert(fs.existsSync(assetPath), 'Asset ' + assetPath + ' does not exist.');\n                    }\n                }\n            }\n            var sourceHrefMap = this._componentSourceHrefLookup();\n            if (sourceHrefMap) {\n                componentIds = Object.keys(sourceHrefMap);\n                c = componentIds.length;\n                for (i = 0; i < c; i++) {\n                    var comp = this._allComponents[componentIds[i]];\n                    if (!comp) {\n                        assert(false, 'Component ' + componentIds[i] + ' is in local source href mapping but could not be found in the manifest.');\n                    } else {\n                        assert(comp.state === 'modified', 'Component ' + componentIds[i] + ' is in local source href mapping but has a state of ' + comp.state);\n                    }\n                }\n            }\n        }\n        \n        return errors.length ? errors : null;\n    };\n    \n    \n    return AdobeDCXBranchCore;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* An element is a node in a dcx composite that represents an embedded composite. The AdobeDCXElement\n* class allows working with such an element in a safe manner.\n*\n* <p>The constructor for AdobeDCXElement is private. Instances are getting instantiated on an\n* as needed-basis and can be accessed via the {@link module:AdobeDCXBranch} instance.</p>\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only \n* supported when running in a Node.js environment with local storage. Conversely methods, arguments \n* and properties that are marked <strong>XHR-only</strong> are only available in a browser enviroment. \n* Examples are also often marked with either <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXElement\n*/\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeDCXElement',['require','exports','module','./AdobeDCXBranchCore','./AdobeDCXError','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXBranchCore = require('./AdobeDCXBranchCore');\n    var AdobeDCXError = require('./AdobeDCXError');\n    var dcxUtil = require('./AdobeDCXUtil');\n    \n    var MANIFEST_FORMAT_VERSION = 5;\n\n    /**\n     * The constructor for AdobeDCXElement is private. Element instances are getting instantiated on an\n     * as needed-basis.\n     * @constructor\n     * @private\n     * @alias module:AdobeDCXElement\n     * @param {Object}  [data]      private\n     * @param {Object}  [owner]    private\n     * @param {Boolean} [readOnly]  private\n     */\n    function AdobeDCXElement(data, owner, readOnly) {\n        this._owner = owner;\n        if (data) {\n            data = this._setData(data, readOnly); // creates _core\n        } else {\n            var id = dcxUtil.generateUuid();\n            data = { 'id': id };\n            this._core = new AdobeDCXBranchCore(data, this, readOnly);\n            this._data = data;\n        }\n    }\n    \n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXElement.prototype, {\n        /**\n         * An AdobeDCXNode object that represents the root of the underlying manifest.\n         * @type {AdobeDCXNode}\n         * @readonly\n         */\n        rootNode: {\n            get: function () {\n                return this._core.rootNode;\n            },\n            set: function (node) {\n                this._core.rootNode = node;\n            }\n        },\n        /**\n         * The name of the composite.\n         * @type {String}\n         */\n        name: {\n            get: function () {\n                return this._core.rootNode.name;\n            },\n            set: function (name) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof name !== 'string' && typeof name !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    core.rootNode.name = name;\n                }\n            }\n        },\n        /**\n         * The type of the element.\n         * @type {String}\n         */\n        type: {\n            get: function () {\n                return this._core.rootNode.type;\n            },\n            set: function (type) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof type !== 'string' || type === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a non-empty string.');\n                } else {\n                    core.rootNode.type = type;\n                }\n            }\n        },\n        /**\n         * The href of the composite that can be used to pull and push the composite. Can be either\n         * relative to the service endpoint or absolute\n         * @type {String}\n         * @readonly\n         */\n        compositeHref: {\n            get: function () {\n                return this._owner.compositeHref;\n            },\n            set: function (href) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Property \"compositeHref\" is read-only.');\n            }\n        },\n        /**\n         * @private\n         * @type {Object}\n         */\n        _localStorage: {\n            get: function () {\n                return this._core._localStorage;\n            },\n            set: function (value) {\n                this._core._localStorage = value;\n            }\n        },\n        /**\n         * Whether the composite has local storage.\n         * @readonly\n         * @type {Boolean}\n         */\n        hasLocalStorage: {\n            get: function () {\n                return this._core.hasLocalStorage;\n            },\n            set: function (value) {\n                this._core.hasLocalStorage = value;\n            }\n        },\n        /**\n         * @private\n         * @type {Boolean}\n         */\n        _isDirty: {\n            get: function () {\n                return this._core._isDirty;\n            },\n            set: function (value) {\n                this._core._isDirty = value;\n            }\n        },\n        /**\n         * Whether the composite has has been modified in memory and needs to be committed to local\n         * storage.\n         * @readonly\n         * @type {Boolean}\n         */\n        isDirty: {\n            get: function () {\n                return this._isDirty;\n            },\n            set: function (value) {\n                this._core.isDirty = value;\n            }\n        },\n        /**\n         * @private\n         */\n        changeCount: {\n            get: function () {\n                return this._core.changeCount;\n            },\n            set: function (value) {\n                this._core.changeCount = value;\n            }\n        }\n    });\n    \n    \n    // TODO: Add APIs for sub elements\n    \n    \n    //******************************************************************************\n    // Children (Nodes)\n    //******************************************************************************\n    \n    /**\n     * Returns the node with the given id or undefined if not found.\n     * @param   {String } id The id of the child node to look up.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXElement.prototype.getChildWithId = function (id) {\n        return this._core.getChildWithId(id);\n    };\n    \n    /**\n     * Returns the node with the given absolute path or undefined if not found.\n     * @param   {String} path The absolute path.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXElement.prototype.getChildWithAbsolutePath = function (path) {\n        return this._core.getChildWithAbsolutePath(path);\n    };\n    \n    /**\n     * Generates and returns an array of the child nodes of the given parent node.\n     * @example\n     * var rootNodes = element.getChildrenOf(element.rootNode);\n     * @param   {AdobeDCXNode} parentNode The parent node to return the children for.\n     * @returns {Array}\n     */\n    AdobeDCXElement.prototype.getChildrenOf = function (parentNode) {\n        return this._core.getChildrenOf(parentNode);\n    };\n    \n    \n    /**\n     * Creates a new node and inserts it into the children list of the given parent node or of the \n     * root if no parent node is given.\n     * Returns the new child node.\n     * @param   {String}  [name]       The name of the new child. If undefined the child will not\n     *                                 have a name.\n     * @param   {String}  [nodeId]     The id of the new child. If undefined the new child node will \n     *                                 get a random id.\n     * @param   {Integer} [index]      If given and less than or equal to the current number of \n     *                                 children than the node gets inserted at the given index. \n     *                                 Otherwise it gets added to the end.\n     * @param   {String}  [parentNode] The parent node to add the node to. Default parent is the \n     *                                 root node.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXElement.prototype.addChild = function (name, nodeId, index, parentNode) {\n        return this._core.addChild(name, nodeId, index, parentNode);\n    };\n    \n    /**\n     * Removes and returns the given child node from the element.\n     * @param   {AdobeDCXNode} node The child node to remove.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXElement.prototype.removeChild = function (node) {\n        return this._core.removeChild(node);\n    };\n    \n    /**\n     * Moves the existing child from its current parent/index to the given parent/index.\n     * @param   {AdobeDCXNode} node         The child node to move\n     * @param   {Integer}      index        If given and less than or equal to the current number of \n     *                                      children than the node gets inserted at the given index. \n     *                                      Otherwise it gets added to the end.\n     * @param   {AdobeDCXNode} [parentNode] The parent node to move the node to. Default parent is \n     *                                      the root.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXElement.prototype.moveChild = function (node, index, parentNode) {\n        return this._core.moveChild(node, index, parentNode);\n        \n    };\n    \n    /**\n     * Gets passed into copyChild(), replaceChild and called back whenever the operation has finished.\n     * @callback nodeCallback\n     *    @param {Error}         error\n     *    @param {AdobeDCXNode}  node\n     */\n    \n    /**\n     * Copies the given child node as a new node into this element. The node can be from the same or \n     * from a different composite.\n     * \n     * <p>This function will try reuse the ids of any children and components of the copied node, \n     * in order to minimize the amount of data that will later have to be uploaded, however, clients \n     * must not rely on these ids being preserved in the copied objects.</p>\n     * \n     * <p>Fails if a node with the same id or same absolute path already exists.</p>\n     * \n     * <p>Notice: This method does not work without local storage (e.g. browser environment) if\n     * used to copy between two composites stored at different endpoints.</p>\n     *\n     * @param   {AdobeDCXNode} node         The child node to copy. If it is the root node then \n     *                                      newPath must be provided.\n     * @param   {AdobeDCXNode} [parentNode] The parent node to copy the child node to. If undefined \n     *                                      then the new child node will be added to the root of the \n     *                                      branch.\n     * @param   {Integer}      [index]      If provided and less than or equal to the current number of \n     *                                      children of the parentNode (or root) the child node gets \n     *                                      inserted at the given index. Otherwise it gets added to \n     *                                      the end.\n     * @param   {String}       [newPath]    <p>If provided, the copy of the child node will be assigned \n     *                                      this a its path property and it will also receive a new\n     *                                      random id (unless one is provided with the newId param). \n     *                                      If left undefined then the copy of the node will keep \n     *                                      the path of the original. In either case the function will \n     *                                      fail if the resulting absolute path of the child or any \n     *                                      of its children/components conflicts with an already \n     *                                      existing absolute path.</p>\n     *                                      <p>You must provide a newPath if you are copying the root\n     *                                      node of a branch or element.</p>\n     * @param   {String}       [newId]      If provided, the copy of the child node will be assigned \n     *                                      this a its id. If left undefined (and the newPath param\n     *                                      is also undefined) then the copy will retain the id of\n     *                                      the original. In either case the function will \n     *                                      fail if the resulting id of the child or any \n     *                                      of its children/components conflicts with an already \n     *                                      existing id.\n     * @param   {nodeCallback} [callback]   Optional when not copying between different composites or\n     *                                      when not using local storage. \n     *                                      Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXNode}              Only returns the created child node if no callback is \n     *                                      given.\n     */\n    AdobeDCXElement.prototype.copyChild = function (node, parentNode, index, newPath, newId, callback) {\n        return this._core.copyChild(node, parentNode, index, newPath, newId, callback);\n    };\n    \n    \n    //******************************************************************************\n    // Components\n    //******************************************************************************\n    \n    /**\n     * Returns an array of all components in the element.\n     * @returns {Array}.\n     */\n    AdobeDCXElement.prototype.allComponents = function () {\n        return this._core.allComponents();\n    };\n    \n    /**\n     * Returns the component with the given id or undefined if not found.\n     * @param   {String} id The id of the component to look up.\n     * @returns {AdobeDCXComponent}\n     */\n    AdobeDCXElement.prototype.getComponentWithId = function (id) {\n        return this._core.getComponentWithId(id);\n    };\n    \n    /**\n     * Returns the component with the given absolute path or undefined if not found.\n     * @param   {String} path The absolute path of the desired component.\n     * @returns {AdobeDCXComponent}\n     */\n    AdobeDCXElement.prototype.getComponentWithAbsolutePath = function (path) {\n        return this._core.getComponentWithAbsolutePath(path);\n    };\n    \n    /**\n     * Returns an array containing the components of the given node.\n     * @param   {AdobeDCXNode} parentNode The node whose components to return.\n     * @returns {Array}\n     */\n    AdobeDCXElement.prototype.getComponentsOf = function (parentNode) {\n        return this._core.getComponentsOf(parentNode);\n    };\n    \n    \n    /**\n     * Gets passed into addComponent(), updateComponent(), copyComponent(), replaceComponent() and\n     * called back whenever the operation has finished.\n     * @callback componentCallback\n     *    @param {Error}                error\n     *    @param {AdobeDCXComponent}    component\n     */\n    \n    /**\n     * <strong>NJS-only</strong> Use AdobeDCXCompositeXfer.uploadNewComponent() followed by \n     * addComponentWithUploadResults() instead.\n     *\n     * <p>Creates and adds a component to the given parent node.</p>\n     *\n     * @param {String}            name         The name of the new component.\n     * @param {String}            type         The mime type of the new component.\n     * @param {String}            relationship The relationship of the new component.\n     * @param {String}            path         The path of the new component. Must satisfy uniqueness \n     *                                         rules for components.\n     * @param {String}            [source]     The absolute file path of the new source file of the \n     *                                         component. Is optional if a sourceHref is passed in.\n     * @param {Boolean}           copy         Whether to copy (true) or move (false) the source file \n     *                                         to its proper location.\n     * @param {String}            [sourceHref] The href of a file asset at the same endpoint as the composite.\n     *                                          Is optional if a source is passed in.\n     * @param {AdobeDCXNode}      [parentNode] The node to add the node to. Defaults to the root.\n     * @param {String}            [id]         The id to use for the new component. Must be unique \n     *                                         within the composite. If not provided the component \n     *                                         will get assigned a random uuid.\n     * @param {componentCallback} [callback]   Gets called when adding the component has either \n     *                                         succeeded or failed. Is optional if no source is given.\n     * @return {AdobeDCXComponent} The newly created component if called without source param.\n     */\n    AdobeDCXElement.prototype.addComponent = function (name, type, relationship, path, source, copy, sourceHref, parentNode, id, callback) {\n        return this._core.addComponent(name, type, relationship, path, source, copy, sourceHref, parentNode, id, callback);\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Creates and adds a component to the given parent node or to the root if no parent node is \n     * given.</p>\n     * \n     * @param   {String}            name          The name of the new component.\n     * @param   {String}            relationship  The relationship of the new component.\n     * @param   {String}            path          The path of the new component. Must satisfy uniquenes \n     *                                            rules for components.\n     * @param   {AdobeDCXNode}      [parentNode]  The node to add the node to. Defaults to the root.\n     * @param   {Object             }             uploadResults The upload results object returned by a previous call \n     *                                            to AdobeDCXCompositeXfer.uploadAssetForComponent().\n     * @returns {AdobeDCXComponent}               The new component.\n     */\n    AdobeDCXElement.prototype.addComponentWithUploadResults = function (name, relationship, path, parentNode, uploadResults) {\n        return this._core.addComponentWithUploadResults(name, relationship, path, parentNode, uploadResults);\n    };\n    \n    /**\n     * <strong>NJS-only</strong> - Use AdobeDCXCompositeXfer.uploadComponent() to upload a new \n     * component asset and then call updateComponentWithUploadResults() instead.\n     *\n     * <p>Updates the asset file of a component with the given source file.</p>\n     *\n     * @param {AdobeDCXComponent} component The component to update.\n     * @param {String}            source    The absolute file path of the new source file.\n     * @param {Boolean}           copy      Whether to copy (true) or move (false) the source file \n     *                                      to its proper location.\n     * @param {componentCallback} callback  Gets called when adding the component has either \n     *                                      succeeded or failed.\n     */\n    AdobeDCXElement.prototype.updateComponent = function (component, source, copy, callback) {\n        return this._core.updateComponent(component, source, copy, callback);\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Updates the component record with the results of a recent upload of said component.</p>\n     * \n     * @param   {AdobeDCXComponent} component     The component.\n     * @param   {Object}            uploadResults The upload results object returned by a previous \n     *                                            call to AdobeDCXCompositeXfer.uploadAssetForComponent().\n     * @returns {AdobeDCXComponent} The updated component.\n     */\n    AdobeDCXElement.prototype.updateComponentWithUploadResults = function (component, uploadResults) {\n        return this._core.updateComponentWithUploadResults(component, uploadResults);\n    };\n    \n    /**\n     * Removes the component from the element.\n     * @param   {AdobeDCXComponent} component The component to remove.\n     * @returns {AdobeDCXComponent} The removed component.\n     */\n    AdobeDCXElement.prototype.removeComponent = function (component) {\n        return this._core.removeComponent(component);\n    };\n    \n    \n    /**\n     * Moves the component to the given node or the root if node is undefined\n     * @param   {AdobeDCXComponent} component    The component to move.\n     * @param   {AdobeDCXNode}      [parentNode] The node to move the component to.\n     * @returns {AdobeDCXComponent} The moved component.\n     */\n    AdobeDCXElement.prototype.moveComponent = function (component, parentNode) {\n        return this._core.moveComponent(component, parentNode);\n    };\n    \n    /**\n     * Copies the given component and adds it as a new component to this branch. Fails if the \n     * component already exists.\n     * \n     * <p>Notice: This method does not work without local storage (browser environment) if\n     * used to copy between two composites with different endpoints.</p>\n     *\n     * @param   {AdobeDCXComponent} component    The component to copy.\n     * @param   {AdobeDCXNode}      [parentNode] The node to copy the component to. If none is \n     *                                           provided then the component will be added to the \n     *                                           root.\n     * @param   {String}            [newPath]    If provided the copy of the component will be \n     *                                           assigned this a its path property and it will also \n     *                                           get assigned a random new id if none is provided via\n     *                                           the <em>newId</em> param.\n     * @param   {String}            [newId]      If provided the copy of the component will be assigned \n     *                                           this a its id. If left undefined (and if newPath is \n     *                                           undefined as well) then the copy of the component \n     *                                           will retain the id of the original.\n     *                                           This is useful when merging conflicting changes since\n     *                                           it preserves the identity of components and avoids\n     *                                           unnecessary network traffic.\n     * @param   {componentCallback} [callback]   Optional when not copying between different \n     *                                           composites or when copying without local storage.\n     *                                           Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXComponent} Only returns the new component when called without \n     *                                           a callback.\n     */\n    AdobeDCXElement.prototype.copyComponent = function (component, parentNode, newPath, newId, callback) {\n        return this._core.copyComponent(component, parentNode, newPath, newId, callback);\n    };\n    \n    /**\n     * Gets passed into assetOfComponent() and called back whenever the operation has finished.\n     * @callback filePathCallback\n     *    @param {Error}     error\n     *    @param {String}    filePath\n     */\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Determines and returns the path of the asset of the component. Can be called either \n     * synchronously or asynchronously. The former just returns the path. The latter also checks for \n     * the existence of the file and only returns the path (to the callback) if it actually exists.</p>\n     *\n     * @param   {AdobeDCXComponent} component  The component to get the asset path for.\n     * @param   {filePathCallback}  [callback] Gets called when both the path and the existence of \n     *                                         the file at the path have been determined.\n     * @returns {AdobeDCXComponent}            Only returns the local file path of the component\n     *                                         when called without a callback.\n     */\n    AdobeDCXElement.prototype.assetOfComponent = function (component, callback) {\n        return this._core.assetOfComponent(component, callback);\n    };\n    \n    //******************************************************************************\n    // Persistence\n    //******************************************************************************\n\n    /**\n     * Restores the element from its stringified representation (manifest). Throws if data is invalid.\n     * @private\n     * @param   {String} data The stringified representation.\n     * @returns {AdobeDCXElement}.\n     */\n    AdobeDCXElement.prototype.parse = function (data) {\n        // verify params\n        if (typeof data !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"data\" must be a string');\n        }\n        var newData = null;\n\n        // parse the string\n        try {\n            newData = JSON.parse(data);\n        } catch (e) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_JSON,\n                                    'Manifest could not be parsed. Underlying error: ' + e.message);\n        }\n\n        // set the new data\n        return this._setData(newData, this._core._readOnly);\n    };\n\n    \n    \n    //******************************************************************************\n    // Miscellaneous\n    //******************************************************************************\n    \n    /**\n     * Creates and returns a read-write deep copy of the element.\n     * @private\n     * @returns {AdobeDCXElement}\n     */\n    AdobeDCXElement.prototype.copy = function () {\n        return new AdobeDCXElement(JSON.parse(JSON.stringify(this._data)), this._owner);\n    };\n    \n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n    \n    /**\n     * For each component in this element this method looks up the matching component\n     * in sourceBranch and if it exists there and has the same etag then it\n     * updates local storage mapping and source hrefs for that component to point to the same asset.\n     * @private\n     * @param {AdobeDCXBranch} sourceBranch The branch to copy the data from. Must be a branch of the same\n     *                                composite.\n     */\n    AdobeDCXElement.prototype._updateLocalDataFromBranch = function (sourceBranch) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        if (!sourceBranch._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage for source.');\n        }\n        if (this._localStorage.compositePath !== sourceBranch._localStorage.compositePath) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Branches must have same storage path.');\n        }\n        \n        this._core._localStorage.copyLocalStorageData(sourceBranch, sourceBranch._core._local(), this, this._core._local());\n        this._core._copySourceHrefsFrom(sourceBranch._core);\n    };\n\n    \n    /**\n     * Returns an error if the passed in data is not a valid manifest. Returns null if everything is OK.\n     * @private\n     * @param   {Object} data The value object to verify.\n     * @returns {Error}\n     */\n    AdobeDCXElement.prototype._verify = function (data) {\n        if (typeof data.id !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Element is missing an id of type string\");\n        }\n        if (typeof data.name !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Element is missing a name of type string\");\n        }\n        if (typeof data.type !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Element is missing a type of type string\");\n        }\n        \n        return null;\n    };\n    \n    /**\n     * Verifies and sets the new data and creates the caches. Throws if invalid data.\n     * @private\n     * @param   {Object}         data Data\n     * @param {Boolean} readOnly Whether the element is read-only.\n     * @returns {AdobeDCXElement} The element.\n     */\n    AdobeDCXElement.prototype._setData = function (data, readOnly) {\n        \n        var err = this._verify(data);\n        if (err === null) {\n            this._core = new AdobeDCXBranchCore(data, this, readOnly);\n            this._data = data;\n            \n            return this;\n        }\n        throw err;\n    };\n    \n    /**\n     * @private\n     */\n    AdobeDCXElement.prototype._local = function () {\n        return this._core._local();\n    };\n    \n    /**\n     * Sets the dirty flag and (optionally) the compositeState\n     * @private\n     * @param {Boolean} preserveCompositeState \n     */\n    AdobeDCXElement.prototype._setDirty = function (preserveCompositeState) {\n        this._core._setDirty(preserveCompositeState);\n    };\n    \n    \n    /**\n     * Updates the path of a node. Caller must dirty the element.\n     * @private\n     * @param {Object} node    \n     * @param {String} newPath\n     */\n    AdobeDCXElement.prototype._setPathOfNode = function (node, newPath) {\n        this._core._setPathOfNode(node, newPath);\n    };\n    \n    /**\n     * Verifies the integrity of the in-memory structures of the element. Looks for incorrect caches/lookup tables, incorrect\n     * object references and cycles/duplicate objects. Also, optionally, verifies that all asset files exist locally.\n     * @private\n     * @param   {Boolean}  shouldBeComplete Whether to check for the existence of all component assets. @Warning: This check is using synchronous file system calls.\n     * @param   {Function} logger           Optional. A function that gets called for every error found. Signature: function (string)\n     * @param   {Object}   fs               Optional. The file system object to use in the shouldBeComplete check\n     * @returns {Array}    Array of errors or null if everything is OK.\n     */\n    AdobeDCXElement.prototype._verifyIntegrity = function (shouldBeComplete, logger, fs) {\n        return this._core._verifyIntegrity(shouldBeComplete, logger, fs);\n    };\n    \n    return AdobeDCXElement;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* A branch of a composite represents a specific version of the composite. The main branch is the \n* <em>current</em> branch, which also allows editing a composite. Other branches are usually\n* read-only and only available when running under Node.js. These branches are <em>base</em>,\n* <em>pushed</em> and <em>pulled</em>.\n*\n* <p>The constructor for AdobeDCXBranch is private. Branch instances are getting instantiated on an\n* as needed-basis and can be accessed via the {@link module:AdobeDCXComposite} instance.</p>\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXBranch\n*/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCXBranch',['require','exports','module','./AdobeDCXBranchCore','./AdobeDCXElement','./AdobeDCXError','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXBranchCore = require('./AdobeDCXBranchCore');\n    var AdobeDCXElement = require('./AdobeDCXElement');\n    var AdobeDCXError = require('./AdobeDCXError');\n    var dcxUtil = require('./AdobeDCXUtil');\n    \n    var MANIFEST_FORMAT_VERSION = 6;\n\n    /**\n     * The constructor for AdobeDCXBranch is private. Branch instances are getting instantiated on an\n     * as needed-basis.\n     * @constructor\n     * @private\n     * @alias module:AdobeDCXBranch\n     * @param {Object}  [data]      private\n     * @param {Boolean} [readOnly]  private\n     */\n    function AdobeDCXBranch(data, readOnly) {\n        if (data) {\n            data = this._setData(data, readOnly); // creates _core\n        } else {\n            var id = dcxUtil.generateUuid();\n            data = { 'manifest-format-version': MANIFEST_FORMAT_VERSION, 'id': id };\n            this.originalManifestFormatVersion = MANIFEST_FORMAT_VERSION;\n            this._core = new AdobeDCXBranchCore(data, this, readOnly);\n            this._data = data;\n        }\n        this._pendingElements = [];\n    }\n    \n    /**\n    * @private\n    */\n    AdobeDCXBranch._newBranchAsCopyOfCore = function (coreToCopy, localStorage) {\n        var data = JSON.parse(JSON.stringify(coreToCopy._data));\n        var branch = new AdobeDCXBranch(data);\n        var core = branch._core;\n        \n        branch._localStorage = localStorage;\n        branch._resetIdentity(function (resetComponent) {\n            var origComponent = coreToCopy.getComponentWithId(resetComponent.id);\n            if (!origComponent) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not find original component.');\n            }\n            if (origComponent.state === 'modified' || !origComponent.etag) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Cannot create a new composite from a branch that contains modified or unbound components.');\n            }\n            var origHref = coreToCopy._getHrefOfComponent(origComponent);\n            if (!origHref) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Cannot determine the href of component id ' + origComponent.id);\n            }\n        \n            // For each component in the reset branch we set its source href to the href of\n            // the original component\n            core._setSourceHrefOfComponent(origHref, resetComponent);\n            if (localStorage) {\n                localStorage.removeComponentAsset(resetComponent, core._local());\n            }\n        });\n        \n        return branch;\n    };\n    \n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXBranch.prototype, {\n        /**\n         * The id of the composite. Must be a unique among the nodes of the composite.\n         * \n         * <p>While not strictly read-only most clients do not ever have to modify this property.</p>\n         * @type {String}\n         */\n        compositeId: {\n            get: function () {\n                return this._core.rootNode.id;\n            },\n            set: function (id) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof id !== 'string' || id === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a non-empty string.');\n                } else if (core._allNodes[id]) {\n                    throw new AdobeDCXError(AdobeDCXError.DUPLICATE_VALUE, 'There is already a node with the same id.');\n                } else {\n                    delete core._allNodes[this._data.id];\n                    this._data.id = id;\n                    core._allNodes[id] = this._core.rootNode;\n                    core._setDirty();\n                }\n            }\n        },\n        /**\n         * An AdobeDCXNode object that represents the root of the underlying manifest.\n         * @type {AdobeDCXNode}\n         * @readonly\n         */\n        rootNode: {\n            get: function () {\n                return this._core.rootNode;\n            },\n            set: function (node) {\n                this._core.rootNode = node;\n            }\n        },\n        /**\n         * The name of the composite.\n         * @type {String}\n         */\n        name: {\n            get: function () {\n                return this._core.rootNode.name;\n            },\n            set: function (name) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof name !== 'string' && typeof name !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    core.rootNode.name = name;\n                }\n            }\n        },\n        /**\n         * The type of the composite.\n         * @type {String}\n         */\n        type: {\n            get: function () {\n                return this._core.rootNode.type;\n            },\n            set: function (type) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof type !== 'string' || type === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a non-empty string.');\n                } else {\n                    core.rootNode.type = type;\n                }\n            }\n        },\n        /**\n         * The href of the composite that can be used to pull and push the composite. Can be either\n         * relative to the service endpoint or absolute\n         * <strong>Do not modify this for a bound composite.</strong>\n         * @type {String}\n         */\n        compositeHref: {\n            get: function () {\n                return (this._data.local ? this._data.local.compositeHref : undefined);\n            },\n            set: function (href) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof href !== 'string' && typeof href !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    core._local().compositeHref = dcxUtil.ensureRelativeHrefStartsWithSlash(href);\n                    core._setDirty();\n                }\n            }\n        },\n        /**\n         * @private\n         * @type {String}\n         */\n        _collaborationType: {\n            get: function () {\n                return (this._data.local ? this._data.local.collaborationType : undefined);\n            },\n            set: function (value) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else {\n                    if (value) {\n                        core._local().collaborationType = value;\n                    } else {\n                        delete core._local().collaborationType;\n                    }\n                    core._setDirty(true);\n                }\n            }\n        },\n        /**\n         * The etag of the manifest of the composite.\n         * @type {String}\n         * @readonly\n         */\n        manifestEtag: {\n            get: function () {\n                return (this._data.local ? this._data.local.manifestEtag : undefined);\n            },\n            set: function (etag) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof etag !== 'string' && typeof etag !== 'undefined') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string or undefined.');\n                } else {\n                    core._local().manifestEtag = etag;\n                    core._setDirty();\n                }\n            }\n        },\n        /**\n         * The editing state of the composite. Can be <em>'unmodified'</em>, <em>'modified'</em>, \n         * <em>'pendingDelete'</em> or <em>'committedDelete'</em>.\n         * @type {String}\n         */\n        compositeState: {\n            get: function () {\n                return this._data.state || 'unmodified';\n            },\n            set: function (state) {\n                var core = this._core;\n                if (core._readOnly) {\n                    throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n                } else if (typeof state !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else if (state !== 'unmodified' && state !== 'modified' && state !== 'pendingDelete' && state !== 'committedDelete') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS,\n                                            'State must be \"modified\", \"unmodified\", \"pendingDelete\", or \"committedDelete\".');\n                } else {\n                    this._data.state = state;\n                    core._setDirty(true);\n                }\n            }\n        },\n        /**\n         * Whether the composite is bound to a composite on a server. If <em>false</em> for newly\n         * created empty composites that have never been pulled from or pushed to the server.\n         * @readonly\n         * @type {Boolean}\n         */\n        isBound: {\n            get: function () {\n                return this.manifestEtag && this.compositeHref;\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property isBound. Use resetIdentity instead.');\n            }\n        },\n        /**\n         * @private\n         * @type {Object}\n         */\n        _localStorage: {\n            get: function () {\n                return this._core._localStorage;\n            },\n            set: function (value) {\n                this._core._localStorage = value;\n            }\n        },\n        /**\n         * Whether the composite has local storage.\n         * @readonly\n         * @type {Boolean}\n         */\n        hasLocalStorage: {\n            get: function () {\n                return this._core.hasLocalStorage;\n            },\n            set: function (value) {\n                this._core.hasLocalStorage = value;\n            }\n        },\n        /**\n         * @private\n         * @type {Boolean}\n         */\n        _isDirty: {\n            get: function () {\n                return this._core._isDirty;\n            },\n            set: function (value) {\n                this._core._isDirty = value;\n            }\n        },\n        /**\n         * Whether the composite has has been modified in memory and needs to be committed to local\n         * storage.\n         * @readonly\n         * @type {Boolean}\n         */\n        isDirty: {\n            get: function () {\n                return this._core.isDirty;\n            },\n            set: function (value) {\n                this._core.isDirty = value;\n            }\n        },\n        /**\n         * @private\n         */\n        localData: {\n            get: function () {\n                return this._core._stringify(false, true);\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property localData.');\n            }\n        },\n        /**\n         * @private\n         */\n        remoteData: {\n            get: function () {\n                return this._core._stringify(true);\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property remoteData.');\n            }\n        },\n        /**\n         * Lists any elements (type AdobeDCXElement) that have been created and have not yet\n         * been used to update the corresponding child node or been abandoned.\n         * @readonly\n         * @type {Array}\n         */\n        pendingElements: {\n            get: function () {\n                return this._pendingElements;\n            },\n            set: function (value) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property pendingElements.');\n            }\n        },\n        /**\n         * @private\n         */\n        changeCount: {\n            get: function () {\n                return this._core.changeCount;\n            },\n            set: function (value) {\n                this._core.changeCount = value;\n            }\n        }\n    });\n    \n    \n    //******************************************************************************\n    // Persistence\n    //******************************************************************************\n\n    /**\n     * Restores the branch from its stringified representation (manifest). Throws if data is invalid.\n     * @private\n     * @param   {String} data The stringified representation.\n     * @returns {AdobeDCXBranch}.\n     */\n    AdobeDCXBranch.prototype.parse = function (data) {\n        // verify params\n        if (typeof data !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"data\" must be a string');\n        }\n        var newData = null;\n\n        // parse the string\n        try {\n            newData = JSON.parse(data);\n        } catch (e) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_JSON,\n                                    'Manifest could not be parsed. Underlying error: ' + e.message);\n        }\n\n        // set the new data\n        return this._setData(newData, this._core._readOnly);\n    };\n    \n    \n    //******************************************************************************\n    // Elements\n    //******************************************************************************\n    \n    /**\n     * Returns the element with the given id or undefined if not found.\n     * Throws if the node in question is not a valid element).\n     * Notice that the branch keeps track of pending element objects. You must either call\n     * updateElement or abandonElement when you are done with it so that the branch can update\n     * its data and perform any necessary clean up tasks.\n     * @param   {String } id The id of the child node to look up.\n     * @returns {AdobeDCXElement}\n     */\n    AdobeDCXBranch.prototype.getElementWithId = function (id) {\n        return this._createElement(this._core.getChildWithId(id));\n    };\n    \n    /**\n     * Returns the element with the given absolute path or undefined if not found.\n     * Throws if the node in question is not a valid element).\n     * Notice that the branch keeps track of pending element objects. You must either call\n     * updateElement or abandonElement when you are done with it so that the branch can update\n     * its data and perform any necessary clean up tasks.\n     * @param   {String} path The absolute path.\n     * @returns {AdobeDCXElement}\n     */\n    AdobeDCXBranch.prototype.getElementWithAbsolutePath = function (path) {\n        return this._createElement(this._core.getChildWithAbsolutePath(path));\n    };\n    \n    /**\n     * Creates a new element node and inserts it into the children list of the given parent node or of the \n     * root if no parent node is given.\n     * Returns the new element.\n     * Throws if the path is invalid.\n     * Notice that the branch keeps track of pending element objects. You must either call\n     * updateElement or abandonElement when you are done with it so that the branch can update\n     * its data and perform any necessary clean up tasks.\n     * @param   {String}  [name]       The name of the new element.\n     * @param   {String}  [type]       The type of the new element.\n     * @param   {String}  [path]       The path of the new element.\n     * @param   {String}  [nodeId]     The id of the new child. If undefined the new child node will \n     *                                 get a random id.\n     * @param   {Integer} [index]      If given and less than or equal to the current number of \n     *                                 children than the node gets inserted at the given index. \n     *                                 Otherwise it gets added to the end.\n     * @param   {String}  [parentNode] The parent node to add the node to. Default parent is the \n     *                                 root node.\n     * @returns {AdobeDCXElement}\n     */\n    AdobeDCXBranch.prototype.addElement = function (name, type, path, nodeId, index, parentNode) {\n        if (typeof name !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Element must have a name of type string\");\n        }\n        if (typeof type !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Element must have a type of type string\");\n        }\n        if (typeof path !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, \"Element must have a path of type string\");\n        }\n        var node = this._core.addChild(name, nodeId, index, parentNode);\n        try {\n            // Using try-catch because setting the path of the node can fail.\n            node.path = path;\n        } catch (x) {\n            // Need to remove the node from the branch.\n            this._core.removeChild(node);\n            // Now we can safely re-throw the exception.\n            throw (x);\n        }\n        node._data.type = type;\n        return (this._createElement(node));\n    };\n    \n    /**\n     * Updates the data of the existing element in the branch.\n     * Notice that the element object will no longer be tracked by the branch after updateElement\n     * has been called. You will have to request the element again using getElementWithId or\n     * getElementWithAbsolutePath if you want to keep working with it.\n     * Throws if the element doesn't exist or if the update results in duplicate paths/ids.\n     * \n     * @param {AdobeDCXElement} element The modified element.\n     * @returns {AdobeDCXNode} The updated node in the branch.\n     */\n    AdobeDCXBranch.prototype.updateElement = function (element) {\n        var elementNode = this.getChildWithId(element.rootNode.id);\n        if (!elementNode) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Element does not exist in branch.');\n        }\n        var node = this._core.replaceChild(element.rootNode, elementNode.path);\n        this._deleteElement(element);\n        return node;\n    };\n    \n    /**\n     * Cleans up an element that was previously created and has not been used to update the corresponding\n     * node in the branch. Throws if the branch doesn't recognize the element (e.g. calling abandonElement\n     * twice or after already having called updateElement).\n     * \n     * @param {AdobeDCXElement} element The element that is no longer needed.\n     */\n    AdobeDCXBranch.prototype.abandonElement = function (element) {\n        this._deleteElement(element);\n    };\n    \n    //******************************************************************************\n    // Children (Nodes)\n    //******************************************************************************\n    \n    /**\n     * Returns the node with the given id or undefined if not found.\n     * @param   {String } id The id of the child node to look up.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranch.prototype.getChildWithId = function (id) {\n        return this._core.getChildWithId(id);\n    };\n    \n    /**\n     * Returns the node with the given absolute path or undefined if not found.\n     * @param   {String} path The absolute path.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranch.prototype.getChildWithAbsolutePath = function (path) {\n        return this._core.getChildWithAbsolutePath(path);\n    };\n    \n    /**\n     * Generates and returns an array of the child nodes of the given parent node.\n     * @example\n     * var rootNodes = branch.getChildrenOf(branch.rootNode);\n     * @param   {AdobeDCXNode} parentNode The parent node to return the children for.\n     * @returns {Array}\n     */\n    AdobeDCXBranch.prototype.getChildrenOf = function (parentNode) {\n        return this._core.getChildrenOf(parentNode);\n    };\n    \n    /**\n     * Creates a new node and inserts it into the children list of the given parent node or of the \n     * root if no parent node is given.\n     * Returns the new child node.\n     * @param   {String}  [name]       The name of the new child. If undefined the child will not\n     *                                 have a name.\n     * @param   {String}  [nodeId]     The id of the new child. If undefined the new child node will \n     *                                 get a random id.\n     * @param   {Integer} [index]      If given and less than or equal to the current number of \n     *                                 children than the node gets inserted at the given index. \n     *                                 Otherwise it gets added to the end.\n     * @param   {String}  [parentNode] The parent node to add the node to. Default parent is the \n     *                                 root node.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranch.prototype.addChild = function (name, nodeId, index, parentNode) {\n        return this._core.addChild(name, nodeId, index, parentNode);\n    };\n    \n    /**\n     * Removes and returns the given child node from the branch.\n     * @param   {AdobeDCXNode} node The child node to remove.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranch.prototype.removeChild = function (node) {\n        return this._core.removeChild(node);\n    };\n    \n    /**\n     * Moves the existing child from its current parent/index to the given parent/index.\n     * @param   {AdobeDCXNode} node         The child node to move\n     * @param   {Integer}      index        If given and less than or equal to the current number of \n     *                                      children than the node gets inserted at the given index. \n     *                                      Otherwise it gets added to the end.\n     * @param   {AdobeDCXNode} [parentNode] The parent node to move the node to. Default parent is \n     *                                      the root.\n     * @returns {AdobeDCXNode}\n     */\n    AdobeDCXBranch.prototype.moveChild = function (node, index, parentNode) {\n        return this._core.moveChild(node, index, parentNode);\n        \n    };\n    \n    /**\n     * Gets passed into copyChild(), replaceChild and called back whenever the operation has finished.\n     * @callback nodeCallback\n     *    @param {Error}         error\n     *    @param {AdobeDCXNode}  node\n     */\n    \n    /**\n     * Copies the given child node as a new node into this branch. The node can be from the same or \n     * from a different composite.\n     * \n     * <p>This function will try reuse the ids of any children and components of the copied node, \n     * in order to minimize the amount of data that will later have to be uploaded, however, clients \n     * must not rely on these ids being preserved in the copied objects.</p>\n     * \n     * <p>Fails if a node with the same id or same absolute path already exists.</p>\n     * \n     * <p>Notice: This method does not work without local storage (e.g. browser environment) if\n     * used to copy between two composites stored at different endpoints.</p>\n     *\n     * @param   {AdobeDCXNode} node         The child node to copy. If it is the root node then \n     *                                      newPath must be provided.\n     * @param   {AdobeDCXNode} [parentNode] The parent node to copy the child node to. If undefined \n     *                                      then the new child node will be added to the root of the \n     *                                      branch.\n     * @param   {Integer}      [index]      If provided and less than or equal to the current number of \n     *                                      children of the parentNode (or root) the child node gets \n     *                                      inserted at the given index. Otherwise it gets added to \n     *                                      the end.\n     * @param   {String}       [newPath]    <p>If provided, the copy of the child node will be assigned \n     *                                      this a its path property and it will also receive a new\n     *                                      random id (unless one is provided with the newId param). \n     *                                      If left undefined then the copy of the node will keep \n     *                                      the path of the original. In either case the function will \n     *                                      fail if the resulting absolute path of the child or any \n     *                                      of its children/components conflicts with an already \n     *                                      existing absolute path.</p>\n     *                                      <p>You must provide a newPath if you are copying the root\n     *                                      node of a branch or element.</p>\n     * @param   {String}       [newId]      If provided, the copy of the child node will be assigned \n     *                                      this a its id. If left undefined (and the newPath param\n     *                                      is also undefined) then the copy will retain the id of\n     *                                      the original. In either case the function will \n     *                                      fail if the resulting id of the child or any \n     *                                      of its children/components conflicts with an already \n     *                                      existing id.\n     * @param   {nodeCallback} [callback]   Optional when not copying between different composites or\n     *                                      when not using local storage. \n     *                                      Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXNode}              Only returns the created child node if no callback is \n     *                                      given.\n     */\n    AdobeDCXBranch.prototype.copyChild = function (node, parentNode, index, newPath, newId, callback) {\n        return this._core.copyChild(node, parentNode, index, newPath, newId, callback);\n    };\n    \n    /**\n     * <p>Replaces the child node in this branch with a copy of the given node or branch with the same \n     * id (or, if provided, with the given id). Fails if the child node does not exist in this branch.</p>\n     * \n     * <p>This function will try reuse the ids of any children and components of the copied node, \n     * in order to minimize the amount of data that will later have to be uploaded, however, clients \n     * must not rely on these ids being preserved in the copied objects.</p>\n     * \n     * <p>Notice: This method does not work without local storage (e.g. browser environment) if\n     * used to copy between two different composites.</p>\n     * \n     * @param   {AdobeDCXNode} node       The child node to update from.\n     * @param   {String}       [newPath]  If provided the copy of the component will be assigned \n     *                                    this a its path property. Otherwise it will retain its original path.\n     * @param   {String}       [newId]    If provided the copy of the child node will be assigned \n     *                                    this as its id. Otherwise it will retain its original id.\n     * @param   {nodeCallback} [callback] Optional when not copying between different composites or \n     *                                    when not using local storage. \n     *                                    Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXNode}            Only returns the created child node if no callback is \n     *                                    given.\n     */\n    AdobeDCXBranch.prototype.replaceChild = function (node, newPath, newId, callback) {\n        return this._core.replaceChild(node, newPath, newId, callback);\n    };\n    \n    \n    //******************************************************************************\n    // Components\n    //******************************************************************************\n    \n    /**\n     * Returns an array of all components in the branch.\n     * @returns {Array}.\n     */\n    AdobeDCXBranch.prototype.allComponents = function () {\n        return this._core.allComponents();\n    };\n    \n    /**\n     * Returns the component with the given id or undefined if not found.\n     * @param   {String} id The id of the component to look up.\n     * @returns {AdobeDCXComponent}\n     */\n    AdobeDCXBranch.prototype.getComponentWithId = function (id) {\n        return this._core.getComponentWithId(id);\n    };\n    \n    /**\n     * Returns the component with the given absolute path or undefined if not found.\n     * @param   {String} path The absolute path of the desired component.\n     * @returns {AdobeDCXComponent}\n     */\n    AdobeDCXBranch.prototype.getComponentWithAbsolutePath = function (path) {\n        return this._core.getComponentWithAbsolutePath(path);\n    };\n    \n    /**\n     * Returns an array containing the components of the given node.\n     * @param   {AdobeDCXNode} parentNode The node whose components to return.\n     * @returns {Array}\n     */\n    AdobeDCXBranch.prototype.getComponentsOf = function (parentNode) {\n        return this._core.getComponentsOf(parentNode);\n    };\n    \n    \n    /**\n     * Gets passed into addComponent(), updateComponent(), copyComponent(), replaceComponent() and\n     * called back whenever the operation has finished.\n     * @callback componentCallback\n     *    @param {Error}                error\n     *    @param {AdobeDCXComponent}    component\n     */\n    \n    /**\n     * <strong>NJS-only</strong> Use AdobeDCXCompositeXfer.uploadNewComponent() followed by \n     * addComponentWithUploadResults() instead.\n     *\n     * <p>Creates and adds a component to the given parent node.</p>\n     *\n     * @param {String}            name         The name of the new component.\n     * @param {String}            type         The mime type of the new component.\n     * @param {String}            relationship The relationship of the new component.\n     * @param {String}            path         The path of the new component. Must satisfy uniqueness \n     *                                         rules for components.\n     * @param {String}            [source]     The absolute file path of the new source file of the \n     *                                         component. Is optional if a sourceHref is passed in.\n     * @param {Boolean}           copy         Whether to copy (true) or move (false) the source file \n     *                                         to its proper location.\n     * @param {String}            [sourceHref] The href of a file asset at the same endpoint as the composite.\n     *                                          Is optional if a source is passed in.\n     * @param {AdobeDCXNode}      [parentNode] The node to add the node to. Defaults to the root.\n     * @param {String}            [id]         The id to use for the new component. Must be unique \n     *                                         within the composite. If not provided the component \n     *                                         will get assigned a random uuid.\n     * @param {componentCallback} [callback]   Gets called when adding the component has either \n     *                                         succeeded or failed. Is optional if no source is given.\n     * @return {AdobeDCXComponent} The newly created component if called without source param.\n     */\n    AdobeDCXBranch.prototype.addComponent = function (name, type, relationship, path, source, copy, sourceHref, parentNode, id, callback) {\n        return this._core.addComponent(name, type, relationship, path, source, copy, sourceHref, parentNode, id, callback);\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Creates and adds a component to the given parent node or to the root if no parent node is \n     * given.</p>\n     * \n     * @param   {String}            name          The name of the new component.\n     * @param   {String}            relationship  The relationship of the new component.\n     * @param   {String}            path          The path of the new component. Must satisfy uniquenes \n     *                                            rules for components.\n     * @param   {AdobeDCXNode}      [parentNode]  The node to add the node to. Defaults to the root.\n     * @param   {Object             }             uploadResults The upload results object returned by a previous call \n     *                                            to AdobeDCXCompositeXfer.uploadAssetForNewComponent().\n     * @returns {AdobeDCXComponent}               The new component.\n     */\n    AdobeDCXBranch.prototype.addComponentWithUploadResults = function (name, relationship, path, parentNode, uploadResults) {\n        return this._core.addComponentWithUploadResults(name, relationship, path, parentNode, uploadResults);\n    };\n    \n    /**\n     * <strong>NJS-only</strong> - Use AdobeDCXCompositeXfer.uploadComponent() to upload a new \n     * component asset and then call updateComponentWithUploadResults() instead.\n     *\n     * <p>Updates the asset file of a component with the given source file.</p>\n     *\n     * @param {AdobeDCXComponent} component The component to update.\n     * @param {String}            source    The absolute file path of the new source file.\n     * @param {Boolean}           copy      Whether to copy (true) or move (false) the source file \n     *                                      to its proper location.\n     * @param {componentCallback} callback  Gets called when adding the component has either \n     *                                      succeeded or failed.\n     */\n    AdobeDCXBranch.prototype.updateComponent = function (component, source, copy, callback) {\n        return this._core.updateComponent(component, source, copy, callback);\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Updates the component record with the results of a recent upload of said component.</p>\n     * \n     * @param   {AdobeDCXComponent} component     The component.\n     * @param   {Object}            uploadResults The upload results object returned by a previous \n     *                                            call to AdobeDCXCompositeXfer.uploadAssetForComponent().\n     * @returns {AdobeDCXComponent} The updated component.\n     */\n    AdobeDCXBranch.prototype.updateComponentWithUploadResults = function (component, uploadResults) {\n        return this._core.updateComponentWithUploadResults(component, uploadResults);\n    };\n    \n    /**\n     * Removes the component from the branch.\n     * @param   {AdobeDCXComponent} component The component to remove.\n     * @returns {AdobeDCXComponent} The removed component.\n     */\n    AdobeDCXBranch.prototype.removeComponent = function (component) {\n        return this._core.removeComponent(component);\n    };\n    \n    \n    /**\n     * Moves the component to the given node or the root if node is undefined\n     * @param   {AdobeDCXComponent} component    The component to move.\n     * @param   {AdobeDCXNode}      [parentNode] The node to move the component to.\n     * @returns {AdobeDCXComponent} The moved component.\n     */\n    AdobeDCXBranch.prototype.moveComponent = function (component, parentNode) {\n        return this._core.moveComponent(component, parentNode);\n    };\n    \n    /**\n     * Copies the given component and adds it as a new component to this branch. Fails if the \n     * component already exists.\n     * \n     * <p>Notice: This method does not work without local storage (browser environment) if\n     * used to copy between two composites with different endpoints.</p>\n     *\n     * @param   {AdobeDCXComponent} component    The component to copy.\n     * @param   {AdobeDCXNode}      [parentNode] The node to copy the component to. If none is \n     *                                           provided then the component will be added to the \n     *                                           root.\n     * @param   {String}            [newPath]    If provided the copy of the component will be \n     *                                           assigned this a its path property and it will also \n     *                                           get assigned a random new id if none is provided via\n     *                                           the <em>newId</em> param.\n     * @param   {String}            [newId]      If provided the copy of the component will be assigned \n     *                                           this a its id. If left undefined (and if newPath is \n     *                                           undefined as well) then the copy of the component \n     *                                           will retain the id of the original.\n     *                                           This is useful when merging conflicting changes since\n     *                                           it preserves the identity of components and avoids\n     *                                           unnecessary network traffic.\n     * @param   {componentCallback} [callback]   Optional when not copying between different \n     *                                           composites or when copying without local storage.\n     *                                           Gets called when the copy is done or has failed.\n     * @returns {AdobeDCXComponent} Only returns the new component when called without \n     *                                           a callback.\n     */\n    AdobeDCXBranch.prototype.copyComponent = function (component, parentNode, newPath, newId, callback) {\n        return this._core.copyComponent(component, parentNode, newPath, newId, callback);\n    };\n    \n    /**\n     * Replaces the matching component (same id) in this branch with a copy of the given component. \n     * Fails if the component can't be found.\n     * \n     * <p>Notice: This method does not work without local storage (browser environment) if\n     * used to copy between two different composites.</p>\n     *\n     * @param   {AdobeDCXComponent} component  The component to copy.\n     * @param   {String}            [newPath]  If provided the copy of the component will be \n     *                                         assigned this a its path property and it will also \n     *                                         get assigned a new id if none is provided via the \n     *                                         newId param.\n     * @param   {String}            [newId]    If provided the copy of the component will be \n     *                                         assigned this a its id property.\n     * @param   {componentCallback} [callback] Optional when not copying between different \n     *                                         composites. Gets called when the copy is done or has \n     *                                         failed.\n     * @returns {AdobeDCXComponent}            Only returns the new component when called without \n     *                                         a callback.\n     */\n    AdobeDCXBranch.prototype.replaceComponent = function (component, newPath, newId, callback) {\n        return this._core.replaceComponent(component, newPath, newId, callback);\n    };\n    \n    /**\n     * Gets passed into assetOfComponent() and called back whenever the operation has finished.\n     * @callback filePathCallback\n     *    @param {Error}     error\n     *    @param {String}    filePath\n     */\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Determines and returns the path of the asset of the component. Can be called either \n     * synchronously or asynchronously. The former just returns the path. The latter also checks for \n     * the existence of the file and only returns the path (to the callback) if it actually exists.</p>\n     *\n     * @param   {AdobeDCXComponent} component  The component to get the asset path for.\n     * @param   {filePathCallback}  [callback] Gets called when both the path and the existence of \n     *                                         the file at the path have been determined.\n     * @returns {AdobeDCXComponent}            Only returns the local file path of the component\n     *                                         when called without a callback.\n     */\n    AdobeDCXBranch.prototype.assetOfComponent = function (component, callback) {\n        return this._core.assetOfComponent(component, callback);\n    };\n    \n    \n    //******************************************************************************\n    // Miscellaneous\n    //******************************************************************************\n    \n    /**\n     * Creates and returns a read-write deep copy of the branch.\n     * @private\n     * @returns {AdobeDCXBranch}\n     */\n    AdobeDCXBranch.prototype.copy = function () {\n        return new AdobeDCXBranch(JSON.parse(JSON.stringify(this._data)));\n    };\n    \n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n    \n    // elements\n    /**\n     * [[Description]]\n     * @private\n     * @param {Object} node [[Description]]\n     */\n    AdobeDCXBranch.prototype._createElement = function (node) {\n        var newElement;\n        \n        if (node) {\n            // extract the data\n            var data = JSON.parse(JSON.stringify(node._data));\n            data[\"manifest-format-version\"] = this._data[\"manifest-format-version\"];\n            delete data.path; // remove the path property\n            \n            // instantiate a new element object\n            newElement = new AdobeDCXElement(data, this, this._core._readOnly);\n            \n            if (newElement) {\n                if (this._localStorage) {\n                    // copy over required local data\n                    newElement._localStorage = this._localStorage;\n                    newElement._updateLocalDataFromBranch(this);\n                    \n                    // register element at local storage\n                    this._localStorage.registerInMemoryBranchOrElement(newElement);\n                }\n            }\n        }\n        \n        if (newElement) {\n            this._pendingElements.push(newElement);\n        }\n        return newElement;\n    };\n    \n    /**\n     * [[Description]]\n     * @private\n     * @param {Object} element [[Description]]\n     */\n    AdobeDCXBranch.prototype._deleteElement = function (element) {\n        var index  = this._pendingElements.indexOf(element);\n        if (index < 0) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Unknown element.');\n        }\n        this._pendingElements.splice(index, 1);\n        \n        if (this._localStorage) {\n            // register element at local storage\n            this._localStorage.unregisterInMemoryBranchOrElement(element);\n        }\n        \n        // TODO: Delete element manifest\n    };\n    \n    \n    // conversion\n    /**\n     * [[Description]]\n     * @private\n     * @param {Object} node [[Description]]\n     */\n    function removeLocalStorageAssetIdRecursively(node) {\n        var i, c, components = node.components;\n        if (components) {\n            c = components.length;\n            for (i = 0; i < c; i++) {\n                var component = components[i];\n                delete component.localStorageAssetId;\n            }\n        }\n        var children = node.children;\n        if (children) {\n            c = children.length;\n            for (i = 0; i < c; i++) {\n                removeLocalStorageAssetIdRecursively(children[i]);\n            }\n        }\n    }\n    \n    function convertDataFrom5To6(data, isRoot) {\n        // Version 6 requires that all component version properties are strings\n        // We also ensure that we do not have a path property at the root\n        // Notice that this function is recursive\n        \n        if (isRoot) {\n            if (data.path) {\n                delete data.path;\n            }\n        }\n        \n        var i, components = data.components;\n        if (typeof components === 'object') {\n            for (i = 0; i < components.length; i++) {\n                var component = components[i];\n                if (typeof component.version === 'number') {\n                    component.version = component.version.toString();\n                }\n            }\n        }\n        var children = data.children;\n        if (typeof children === 'object') {\n            for (i = 0; i < children.length; i++) {\n                var child = children[i];\n                convertDataFrom5To6(child);\n            }\n        }\n    }\n    \n    /**\n     * [[Description]]\n     * @private\n     * @param {Object} data Data\n     */\n    function convertDataIfNecessary(data) {\n        var version = data['manifest-format-version'];\n        \n        if (version < MANIFEST_FORMAT_VERSION) {\n            if (version < 4) {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'Encountered manifest format version ' +\n                                        data['manifest-format-version'] + '. Format version conversion not yet implemented for that version.');\n            }\n            if (version < 5) {\n                // We need to remove the localStorageAssetId property from component records\n                removeLocalStorageAssetIdRecursively(data);\n            }\n            if (version < 6) {\n                convertDataFrom5To6(data, true);\n            }\n        }\n    }\n    \n    /**\n     * For each component in this branch this method looks up the matching component\n     * in sourceBranch and if it exists there and has the same etag then it\n     * updates local storage mapping and source hrefs for that component to point to the same asset.\n     * @private\n     * @param {AdobeDCXBranch} sourceBranch The branch to copy the data from. Must be a branch of the same\n     *                                composite.\n     */\n    AdobeDCXBranch.prototype._updateLocalDataFromBranch = function (sourceBranch) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        if (!sourceBranch._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage for source.');\n        }\n        if (this._localStorage.compositePath !== sourceBranch._localStorage.compositePath) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Branches must have same storage path.');\n        }\n        \n        this._core._localStorage.copyLocalStorageData(sourceBranch, sourceBranch._core._local(), this, this._core._local());\n        this._core._copySourceHrefsFrom(sourceBranch._core);\n    };\n\n    \n    /**\n     * Returns an error if the passed in data is not a valid manifest. Returns null if everything is OK.\n     * @private\n     * @param   {Object} data The value object to verify.\n     * @returns {Error}\n     */\n    AdobeDCXBranch.prototype._verify = function (data) {\n        if (typeof data.id !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Manifest is missing an id of type string\");\n        }\n        if (typeof data.name !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Manifest is missing a name of type string\");\n        }\n        if (typeof data.type !== 'string') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Manifest is missing a type of type string\");\n        }\n        if (typeof data['manifest-format-version'] !== 'number') {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Manifest is missing a manifest-format-version of type number\");\n        }\n        \n        return null;\n    };\n    \n    /**\n     * Verifies and sets the new data and creates the caches. Throws if invalid data.\n     * @private\n     * @param   {Object}         data Data\n     * @param {Boolean} readOnly Whether the branch is read-only.\n     * @returns {AdobeDCXBranch} The branch.\n     */\n    AdobeDCXBranch.prototype._setData = function (data, readOnly) {\n        this.originalManifestFormatVersion = data['manifest-format-version'];\n        convertDataIfNecessary(data);\n        \n        // Upgrade local data version if necessary\n        if (data.local) {\n            // We went back and forth regarding whether the href saved in the local section is\n            // relative or absolute. Since it now can be either we do no longer convert the local\n            // section but we should be setting the correct version here so that we can support\n            // conversion in the future if it becomes necessary\n            data.local.version = 2;\n        }\n        \n        var err = this._verify(data);\n        if (err === null) {\n            // Ensure that we always write out the version that we understand:\n            data['manifest-format-version'] = MANIFEST_FORMAT_VERSION;\n            \n            this._core = new AdobeDCXBranchCore(data, this, readOnly);\n            this._data = data;\n            \n            return this;\n        }\n        throw err;\n    };\n    \n    \n    /**\n     * Resets the binding and (optionally) the identity of the branch\n     * @private\n     * @param {Boolean} retainId\n     */\n    AdobeDCXBranch.prototype._reset = function (retainId, componentCallback) {\n        if (this._readOnly) {\n            throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This object is read-only.');\n        }\n        if (this._data.local) {\n            delete this._data.local.manifestEtag;\n            delete this._data.local.compositeHref;\n        }\n        if (!retainId) {\n            this._data.id = dcxUtil.generateUuid();\n        }\n        \n        this._data.state = 'modified';\n        \n        this._core._recursiveReset(this._data, componentCallback);\n        \n        this._core._setDirty();\n    };\n    \n    /**\n     * Resets the binding of the branch while retaining its id.\n     * @private\n     */\n    AdobeDCXBranch.prototype._resetBinding = function (componentCallback) {\n        this._reset(true, componentCallback);\n    };\n    \n    /**\n     * Resets the binding and ids of the branch.\n     * @private\n     */\n    AdobeDCXBranch.prototype._resetIdentity = function (componentCallback) {\n        this._reset(false, componentCallback);\n    };\n    \n    /**\n     * @private\n     */\n    AdobeDCXBranch.prototype._local = function () {\n        return this._core._local();\n    };\n    \n    /**\n     * Sets the dirty flag and (optionally) the compositeState\n     * @private\n     * @param {Boolean} preserveCompositeState \n     */\n    AdobeDCXBranch.prototype._setDirty = function (preserveCompositeState) {\n        this._core._setDirty(preserveCompositeState);\n    };\n    \n    \n    /**\n     * Updates the path of a node. Caller must dirty the branch.\n     * @private\n     * @param {Object} node    \n     * @param {String} newPath\n     */\n    AdobeDCXBranch.prototype._setPathOfNode = function (node, newPath) {\n        this._core._setPathOfNode(node, newPath);\n    };\n    \n    /**\n     * Verifies the integrity of the in-memory structures of the branch. Looks for incorrect caches/lookup tables, incorrect\n     * object references and cycles/duplicate objects. Also, optionally, verifies that all asset files exist locally.\n     * @private\n     * @param   {Boolean}  shouldBeComplete Whether to check for the existence of all component assets. @Warning: This check is using synchronous file system calls.\n     * @param   {Function} logger           Optional. A function that gets called for every error found. Signature: function (string)\n     * @param   {Object}   fs               Optional. The file system object to use in the shouldBeComplete check\n     * @returns {Array}    Array of errors or null if everything is OK.\n     */\n    AdobeDCXBranch.prototype._verifyIntegrity = function (shouldBeComplete, logger, fs) {\n        return this._core._verifyIntegrity(shouldBeComplete, logger, fs);\n    };\n    \n    return AdobeDCXBranch;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n * Captures the state and progess of a composite push operation which can be used to resume a failed push at a later time.\n * @private\n */\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeDCXPushJournal',['require','exports','module','./AdobeDCXError','./AdobeDCXFS','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError'),\n        AdobeDCXFS = require('./AdobeDCXFS'),\n        dcxUtil = require('./AdobeDCXUtil');\n    \n    var JOURNAL_FORMAT_VERSION = 3;\n\n    // Constructor\n    function AdobeDCXPushJournal(composite, filePath, data) {\n        if (data) {\n            this._setData(data, composite.href);\n        } else {\n            this._data = { 'push-journal-format-version': JOURNAL_FORMAT_VERSION, 'composite-href': composite.href, 'uploaded-components': {} };\n        }\n        this._filePath = filePath;\n        \n        // The following three properties are there to handle simultaneous commit requests\n        this._waitingCallbacks = [];\n        this._commitInProgress = false;\n        this._needAnotherCommit = false;\n    }\n    \n    /**\n     * Factory method. Creates a new journal object that gets initialized from the journal file at filePath. If the file can't be read\n     * or if its contents are invalid and createIfNecessary is false then the callback is called with an error. If createIfNecessary is true then\n     * the new journal will be empty if the file couldn't get read.\n     * @private\n     * @param {String}            filePath          The path to load the journal from.\n     * @param {AdobeDCXComposite} composite         The composite for the journal.\n     * @param {Boolean}           createIfNecessary Whether to create an empty journal if the file at filePath could not get read.\n     * @param {Function}          callback          Gets called on completion. Signature: function (error, journal)\n     */\n    AdobeDCXPushJournal.readJournal = function (filePath, composite, createIfNecessary, callback) {\n        AdobeDCXFS.readFile(filePath, 'utf8', function (error, data) {\n            var journal;\n            \n            if (error && error.code && createIfNecessary) {\n                error = undefined;\n            }\n            \n            if (!error) {\n                try {\n                    data = JSON.parse(data);\n                    journal = new AdobeDCXPushJournal(composite, filePath, data);\n                } catch (x) {\n                    if (createIfNecessary) {\n                        journal = new AdobeDCXPushJournal(composite, filePath);\n                    } else {\n                        error = x;\n                    }\n                }\n            }\n            \n            callback(error, error ? undefined : journal);\n        });\n    };\n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXPushJournal.prototype, {\n        compositeHref: {\n            get: function () {\n                return this._data['composite-href'];\n            },\n            set: function (id) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This property is read-only.');\n            }\n        },\n        // The new etag of the manifest as returned by the upload.\n        manifestEtag: {\n            get: function () {\n                return this._data.etag;\n            },\n            set: function (etag) {\n                if (etag) {\n                    this._data.etag = etag;\n                } else {\n                    delete this._data.etag;\n                }\n            }\n        },\n        // The change count of the manifest that go uploaded.\n        changeCount: {\n            get: function () {\n                return this._data.change;\n            },\n            set: function (change) {\n                if (change) {\n                    this._data.change = change;\n                } else {\n                    delete this._data.change;\n                }\n            }\n        },\n        // Whether the composite has been created during the push.\n        compositeHasBeenCreated: {\n            get: function () {\n                return this._data['composite-created'] ? true : false;\n            },\n            set: function (hasBeenCreated) {\n                if (hasBeenCreated) {\n                    this._data['composite-created'] = true;\n                } else {\n                    delete this._data['composite-created'];\n                }\n            }\n        },\n        // Whether the composite has been deleted during the push.\n        compositeHasBeenDeleted: {\n            get: function () {\n                return this._data['composite-deleted'] ? true : false;\n            },\n            set: function (hasBeenDeleted) {\n                if (hasBeenDeleted) {\n                    this._data['composite-deleted'] = true;\n                } else {\n                    delete this._data['composite-deleted'];\n                }\n            }\n        },\n        // Is true if the journal doesn't contain any information worth keeping.\n        isEmpty: {\n            get: function () {\n                return Object.keys(this._data['uploaded-components']).length === 0 && !this.compositeHasBeenDeleted && !this.manifestEtag;\n            },\n            set: function (id) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This property is read-only.');\n            }\n        },\n        // Is true if the journal represents a completed push\n        isComplete: {\n            get: function () {\n                return (this._data.etag && this._data.change) || this._data['composite-deleted'] ? true : false;\n            },\n            set: function (id) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'This property is read-only.');\n            }\n        }\n    });\n    \n    \n    //******************************************************************************\n    // Component uploads\n    //******************************************************************************\n    \n    /**\n     * Records the upload of the given component.\n     * @private\n     * @param {String}  componentId          \n     * @param {String}  etag                 \n     * @param {String}  version              \n     * @param {String}  md5                  \n     * @param {Integer} length               \n     * @param {String}  localStorageFileName\n     */\n    AdobeDCXPushJournal.prototype.recordUploadedComponent = function (componentId, etag, version, md5, length, localStorageFileName, sourceHref) {\n        var record = { etag: etag, length: length, version: version, md5: md5 };\n        if (localStorageFileName) {\n            record['storage-name'] = localStorageFileName;\n        }\n        if (sourceHref) {\n            record['source-href'] = sourceHref;\n        }\n        \n        this._data['uploaded-components'][componentId] = record;\n    };\n    \n    /**\n     * Returns an array of the ids of all uploaded components.\n     * @private\n     * @returns {Array}\n     */\n    AdobeDCXPushJournal.prototype.idsOfAllUploadedComponents = function () {\n        return Object.keys(this._data['uploaded-components']);\n    };\n    \n    /**\n     * Returns an upload record of the given component or undefined if it has not been uploaded.\n     * @param   {String}   componentId\n     * @returns {Object}\n     * @example\n     *      {\n     *           etag: componentEtag, length: componentLength, version: \n     *           component.Version, md5: componentMd5, \n     *           'storage-name': localStorageFileName\n     *      }\n     */\n    AdobeDCXPushJournal.prototype.getRecordForUploadedComponent = function (componentId) {\n        return this._data['uploaded-components'][componentId];\n    };\n    \n    /**\n    Deletes the upload record for the given component.\n    */\n    AdobeDCXPushJournal.prototype.removeRecordForUploadedComponent = function (componentId) {\n        delete this._data['uploaded-components'][componentId];\n    };\n    \n    \n    //******************************************************************************\n    // Merge\n    //******************************************************************************\n    \n    /**\n    Applies the journaled data to the provided branch.\n    */\n    AdobeDCXPushJournal.prototype.applyToBranch = function (branch, preserveDirtyState) {\n        if (!this.isComplete) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Journal is not complete.');\n        }\n        var branchWasDirty = branch.isDirty;\n        if (this.compositeHasBeenDeleted) {\n            branch._data.state = 'committedDelete';\n            branch.manifestEtag = this.manifestEtag; // This bumps the change count on branch\n        } else {\n            var branchHasChangedSincePush = (branch.compositeState !== 'unmodified') && (this.changeCount !== branch.changeCount);\n            \n            // Iterate over all uploaded components and update their counterparts in branch.\n            var componentIds = this.idsOfAllUploadedComponents();\n            var i, count = componentIds.length;\n            for (i = 0; i < count; i++) {\n                var id = componentIds[i];\n                var component = branch.getComponentWithId(id);\n                \n                if (component) { // we ignore components that have been deleted since the push\n                    var uploadRecord = this.getRecordForUploadedComponent(component.id);\n                    \n                    component._data.etag = uploadRecord.etag;\n                    component._data.length = uploadRecord.length;\n                    component._data.version = uploadRecord.version;\n                    component._data.md5 = uploadRecord.md5;\n                    \n                    if (uploadRecord['source-href']) {\n                        if (branch._core._getSourceHrefOfComponent(component) === uploadRecord['source-href']) {\n                            // If the source hrefs match than the component is no longer modified\n                            component._data.state = 'unmodified';\n                            branch._core._setSourceHrefOfComponent(undefined, component);\n                        }\n                    } else if (branch.hasLocalStorage && branch._localStorage.componentAssetName(component, branch._local()) === uploadRecord['storage-name']) {\n                        // If the file paths match than the component is no longer modified\n                        component._data.state = 'unmodified';\n                        branch._core._setSourceHrefOfComponent(undefined, component);\n                    } else if (!branch.hasLocalStorage) {\n                        component._data.state = 'unmodified';\n                    }\n                }\n            }\n            \n            // Update the branch root.\n            branch.manifestEtag = this.manifestEtag; // This bumps the change count on branch\n            \n            // Do this last:\n            if (!branchHasChangedSincePush) {\n                // If the change count matches what was pushed then the composite is no longer modified\n                branch._data.state = 'unmodified';\n            }\n        }\n        if (preserveDirtyState) {\n            branch._isDirty = branchWasDirty;\n        }\n    };\n\n    \n    \n    //******************************************************************************\n    // Commit\n    //******************************************************************************\n    \n    /**\n    Writes the journal to local storage. Correctly handles muliple overlapping requests.\n    \n    @param callback Optional. Signature: function (error)\n    */\n    AdobeDCXPushJournal.prototype.commitChanges = function (callback) {\n        if (!this._filePath) {\n            // Rather then erroring out we just pretend that everything is fine so that\n            // the push algorithm doesn't have to constantly check whether it is OK\n            // to call this method.\n            if (callback) {\n                callback();\n            }\n            return;\n        }\n        \n        var self = this;\n        \n        // Do the actual commit and recurse as long as there are new requests being made\n        // while this request is being processed.\n        var doCommit = function (callbacks) {\n            // Ensure that other requests that come in while making this one can get queued.\n            self._needAnotherCommit = false;\n            self._commitInProgress = true;\n            self._waitingCallbacks = [];\n            \n            AdobeDCXFS.writeFileAtomically(self._filePath, JSON.stringify(self._data), 'utf8', function (error) {\n                var i, count = callbacks.length;\n                for (i = 0; i < count; i++) {\n                    try {\n                        callbacks[i](error);\n                    } catch (x) {\n                        // Nothing to do.\n                    }\n                }\n                if (self._needAnotherCommit) {\n                    // Recurse\n                    doCommit(self._waitingCallbacks);\n                } else {\n                    self._commitInProgress = false;\n                }\n            });\n        };\n        \n        if (self._commitInProgress) {\n            // There is already a commit underway. We don't want to write to the file multiple times at once.\n            this._needAnotherCommit = true;\n            if (callback) {\n                this._waitingCallbacks.push(callback);\n            }\n        } else {\n            doCommit(callback ? [callback] : []);\n        }\n    };\n    \n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n\n    /**\n    Verifies and sets the new data. Throws if invalid data.\n    */\n    AdobeDCXPushJournal.prototype._setData = function (data, compositeHref) {\n        \n        if (data['push-journal-format-version'] <= 2) {\n            // Version 2 push journals can contain numeric component version properties\n            // we are converting them to strings here:\n            var componentRecords = data['uploaded-components'];\n            if (componentRecords) {\n                var componentIds = Object.keys(componentRecords);\n                var i, c = componentIds.length;\n                for (i = 0; i < c; i++) {\n                    var id = componentIds[i];\n                    var record = componentRecords[id];\n                    if (typeof record.version === 'number') {\n                        record.version = String(record.version);\n                    }\n                }\n            }\n            data['push-journal-format-version'] = JOURNAL_FORMAT_VERSION;\n        }\n        \n        var err = this._verify(data, compositeHref);\n        if (err === null) {\n            this._data = data;\n            return this;\n        }\n        throw err;\n    };\n    \n    /**\n    Returns an error if the passed in data is not a valid node. Returns null if everything is OK.\n    */\n    AdobeDCXPushJournal.prototype._verify = function (data, compositeHref) {\n        if (data['push-journal-format-version'] !== JOURNAL_FORMAT_VERSION) {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'Wrong push journal format version.');\n        }\n        if (data['composite-href'] !== compositeHref) {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'Composite and journal hrefs mismatch.');\n        }\n        if (!data['uploaded-components']) {\n            return new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'Missing component list.');\n        }\n        \n        return null;\n    };\n    \n    return AdobeDCXPushJournal;\n});\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n * Local storage mapping for a composite.\n * @private\n**/\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeDCXLocalStorage',['require','exports','module','./AdobeDCXError','./AdobeDCXUtil','./AdobeDCXFS'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError'),\n        dcxUtil = require('./AdobeDCXUtil'),\n        AdobeDCXFS = require('./AdobeDCXFS');\n\n    // Constructor\n    function AdobeDCXLocalStorage(compositePath, preserveFileExtensions) {\n        if (typeof compositePath !== 'string' || compositePath === '') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"compositePath\" must be a non-empty string.');\n        }\n        this._compositePath = compositePath;\n        this._preserveFileExtensions = preserveFileExtensions;\n        \n        this._inMemoryBranchesAndElements = [];\n        this._inflightComponents = [];\n    }\n\n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXLocalStorage.prototype, {\n        compositePath: {\n            get: function () {\n                return this._compositePath;\n            },\n            set: function (compositePath) {\n                if (typeof compositePath !== 'string' || compositePath === '') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"compositePath\" must be a non-empty string.');\n                } else {\n                    this._compositePath = compositePath;\n                }\n            }\n        }\n    });\n    \n    //******************************************************************************\n    // Manifests\n    //******************************************************************************\n    \n    /** Returns the file path for the current manifest. */\n    AdobeDCXLocalStorage.prototype.currentManifestPath = function () {\n        return this._compositePath + '/manifest';\n    };\n    \n    /** Returns the file path for the base manifest. */\n    AdobeDCXLocalStorage.prototype.currentBaseManifestPath = function () {\n        return this._compositePath + '/manifest.base';\n    };\n    \n    /** Returns the file path for the pulled manifest. */\n    AdobeDCXLocalStorage.prototype.pulledManifestPath = function () {\n        return this._compositePath + '/pull.manifest';\n    };\n    \n    /** Returns the file path for the base of the pulled manifest. */\n    AdobeDCXLocalStorage.prototype.pulledBaseManifestPath = function () {\n        return this._compositePath + '/pull.manifest.base';\n    };\n    \n    /** Returns the file path for the pushed manifest. */\n    AdobeDCXLocalStorage.prototype.pushedManifestPath = function () {\n        return this._compositePath + '/push.manifest';\n    };\n    \n    \n    //******************************************************************************\n    // Branches\n    //******************************************************************************\n    \n    /**\n    Accepts the pulled branch as the new current branch, discards any temporary pull data\n    and also updates the base manifest. Is a no-op if no branch is provided and if there\n    is no pulled manifest in local storage (as may be the case if a pull didn't find any\n    modification on the server).\n    \n    @param branch Optional. The branch to accept. If not provided then the pulled manifest from\n    local storage will be used.\n    @param callback Gets called on completion. Signature: (error, currentBranch)\n    */\n    AdobeDCXLocalStorage.prototype.resolvePulledBranch = function (branch, callback) {\n        var self = this;\n        \n        // Write out the branch replacing current manifest\n        AdobeDCXFS.writeFileAtomically(this.currentManifestPath(), branch.localData, 'utf8', function (error) {\n            if (error) {\n                if (error.code !== AdobeDCXError.OUT_OF_SPACE) {\n                    error = new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not write current manifest.', error);\n                }\n                callback(error);\n            } else {\n                // Update base manifest\n                AdobeDCXFS.move(self.pulledManifestPath(), self.currentBaseManifestPath(), /*touch*/ false, function (error) {\n                    if (error) {\n                        callback(new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not move pull manifest.', error));\n                    } else {\n                        // Delete push journal\n                        self._deleteJournal(callback);\n                    }\n                });\n            }\n        });\n    };\n\n    /**\n    Accepts the pushed branch as the new current branch, discards any temporary push data\n    and also updates the base manifest.\n    \n    @param branch The branch to accept.\n    @param callback Gets called on completion. Signature: (error, currentBranch)\n    */\n    AdobeDCXLocalStorage.prototype.acceptPushedBranch = function (branch, callback) {\n        \n        var self = this;\n        \n        // Write out the branch replacing current manifest\n        AdobeDCXFS.writeFileAtomically(this.currentManifestPath(), branch.localData, 'utf8', function (error) {\n            if (error) {\n                if (error.code !== AdobeDCXError.OUT_OF_SPACE) {\n                    error = new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not write current manifest.', error);\n                }\n                callback(new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not write current manifest.', error));\n            } else {\n                // Update base manifest\n                AdobeDCXFS.move(self.pushedManifestPath(), self.currentBaseManifestPath(), /*touch*/ false, function (error) {\n                    if (error) {\n                        callback(new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not move push manifest.', error));\n                    } else {\n                        // Delete push journal\n                        self._deleteJournal(callback);\n                    }\n                });\n            }\n        });\n    };\n    \n    /**\n    Discards the last pull.\n    \n    @param callback Gets called on completion. Signature: (error)\n    */\n    AdobeDCXLocalStorage.prototype.discardPulledBranch = function (callback) {\n        var self = this;\n        \n        AdobeDCXFS.deleteFile(this.pulledManifestPath(), callback);\n    };\n    \n    /**\n    Discards the last push.\n    \n    @param callback Gets called on completion. Signature: (error)\n    */\n    AdobeDCXLocalStorage.prototype.discardPushedBranch = function (callback) {\n        var self = this;\n        \n        AdobeDCXFS.deleteFile(this.pushedManifestPath(), function (error) {\n            if (error) {\n                callback(error);\n            } else {\n                self._deleteJournal(callback);\n            }\n        });\n    };\n    \n    /**\n    Discards the base branch.\n    \n    @param callback Gets called on completion. Signature: (error)\n    */\n    AdobeDCXLocalStorage.prototype.discardBaseBranch = function (callback) {\n        AdobeDCXFS.deleteFile(this.currentBaseManifestPath(), callback);\n    };\n\n    //******************************************************************************\n    // Elements\n    //******************************************************************************\n    \n    /**\n     * Informs the local storage object of the existence of the given in-memory element or branch so \n     * that it can consider it when determining which local files are still in use.\n     * \n     * @private\n     * @param {AdobeDCXElement|AdobeDCXBranch} element The element or branch to register\n     */\n    AdobeDCXLocalStorage.prototype.registerInMemoryBranchOrElement = function (branchOrElement) {\n        if (this._inMemoryBranchesAndElements.indexOf(branchOrElement) >= 0) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Branch or element is already registered.');\n        }\n        this._inMemoryBranchesAndElements.push(branchOrElement);\n    };\n    \n    /**\n     * Informs the local storage object that the given, previously registered element is\n     * no longer relevant.\n     * \n     * @private\n     * @param {AdobeDCXEelement} element The element to unregister.\n     */\n    AdobeDCXLocalStorage.prototype.unregisterInMemoryBranchOrElement = function (branchOrElement) {\n        var index = this._inMemoryBranchesAndElements.indexOf(branchOrElement);\n        if (index < 0) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Unknown branch or element.');\n        }\n        this._inMemoryBranchesAndElements.splice(index, 1);\n    };\n    \n    //******************************************************************************\n    // Journal\n    //******************************************************************************\n    \n    /**\n    Deletes the journal.\n     \n    @param callback Gets called on completion. Signature: (error)\n    */\n    AdobeDCXLocalStorage.prototype._deleteJournal = function (callback) {\n        AdobeDCXFS.deleteFile(this.pushJournalPath(), callback);\n    };\n    \n    //******************************************************************************\n    // Component Assets\n    //******************************************************************************\n    \n    var illegalName = /(\\/)|(\\.$)/;\n    \n    /** Returns the file name in local storage for the given component. */\n    AdobeDCXLocalStorage.prototype.componentAssetName = function (component, storageObject) {\n        var map = storageObject['copyOnWrite#storageIds'];\n        var name = map ? map[component.id] : null;\n        // Prevent injection of ../../userdata into the storage mapping by whatever means.\n        // Any name containing a slash or ending in a dot is illegal.\n        if (name && illegalName.test(name)) {\n            name = null;\n        }\n        return name;\n    };\n    \n    /** Returns the file path for the given component. */\n    AdobeDCXLocalStorage.prototype.componentAssetPath = function (component, storageObject) {\n        var fileName = this.componentAssetName(component, storageObject);\n        \n        return fileName ? this._componentPathFromName(fileName) : null;\n    };\n    \n    /** Updates the asset of the component by copying/moving the file at filePath to local storage. */\n    AdobeDCXLocalStorage.prototype.ingestComponentAsset = function (component, filePath, copy, storageObject, callback) {\n        var self = this;\n        var fileName = this._newFileNameForComponent(component);\n        var targetPath = this._componentPathFromName(fileName);\n        this._inflightComponents.push(fileName);\n        \n        var copyOrMoveDone = function (error) {\n            if (!error) {\n                try {\n                    self._setComponentName(component, storageObject, fileName);\n                } catch (x) {\n                    error = x;\n                }\n            }\n            var index = self._inflightComponents.indexOf(fileName);\n            if (index < 0 && !error) {\n                error = new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Could not find inflight component.');\n            }\n            self._inflightComponents.splice(index, 1);\n            callback(error);\n        };\n        \n        if (copy) {\n            AdobeDCXFS.copyFile(filePath, targetPath, copyOrMoveDone);\n        } else {\n            AdobeDCXFS.move(filePath, targetPath, /*touch*/ true, copyOrMoveDone);\n        }\n    };\n    \n    /** Removes the record of the component asset from local storage. Does not touch the file. */\n    AdobeDCXLocalStorage.prototype.removeComponentAsset = function (component, storageObject) {\n        var mapping = storageObject['copyOnWrite#storageIds'];\n        if (mapping) {\n            delete mapping[component.id];\n        }\n    };\n    \n    /** Returns an array of all component ids for which a mapping exists. */\n    AdobeDCXLocalStorage.prototype.componentIds = function (storageObject) {\n        var mapping = storageObject['copyOnWrite#storageIds'];\n        if (mapping) {\n            return Object.keys(mapping);\n        }\n        return [];\n    };\n    \n    /** Copies over storage mapping from source branch to target branch for those components in target branch\n    that also exist in source branch with the same etag. */\n    AdobeDCXLocalStorage.prototype.copyLocalStorageData = function (source, sourceStorageObject, target, targetStorageObject) {\n        var targetComponents = target.allComponents();\n        var i, count = targetComponents.length;\n        \n        var sourceMapping = sourceStorageObject['copyOnWrite#storageIds'];\n        if (!sourceMapping) {\n            // nothing to copy\n            return;\n        }\n        \n        var targetMapping = targetStorageObject['copyOnWrite#storageIds'];\n        if (!targetMapping) {\n            targetMapping = targetStorageObject['copyOnWrite#storageIds'] = {};\n        }\n        \n        for (i = 0; i < count; i++) {\n            var targetComponent = targetComponents[i];\n            var componentId = targetComponent.id;\n            var sourceComponent = source.getComponentWithId(componentId);\n            if (sourceComponent) {\n                if (sourceComponent.etag === targetComponent.etag) {\n                    var assetName = sourceMapping[componentId];\n                    if (assetName) {\n                        targetMapping[componentId] = assetName;\n                    }\n                }\n            }\n        }\n    };\n    \n    /** Garbage collection. */\n    AdobeDCXLocalStorage.prototype.removeUnusedLocalFiles = function (lastCurrentTimeStamp, callback) {\n        \n        // We need to get three pieces of information\n        // 1. A list of all component asset names referenced in any of the manifest files\n        // 2. The oldest modification time stamp of all of the manifest files\n        // 3. A list of all files in the component directory (file name & modification time stamp)\n        //\n        // We call two different asynchronous functions to get this information in parallel.\n        //\n        // Once we have everything we call the following function to determine which files\n        // to delete and to kick off those deletion requests.\n        // Component assets can be deleted if they are not referenced by any on-disk or in-memory \n        // manifest, they are not in the _inflightComponents list, and if their modification date is \n        // older than that of the oldest manifest. This is a conservative approach which we can tune \n        // to be more aggressive if necessary.\n        \n        var self = this;\n        var asyncError, referencedAssetNamesLookup, oldestManifestTimeStamp, componentListing, numRequests;\n        \n        var doDeleteFile = function (fileName) {\n            self._deleteComponentAsset(fileName, function (error) {\n                if (error && !asyncError) {\n                    asyncError = error;\n                }\n                numRequests--;\n                if (numRequests === 0) {\n                    callback(asyncError);\n                }\n            });\n        };\n        \n        var doDelete = function () {\n            try {\n                // First, determine which files to delete.\n                var i, count = componentListing.length;\n                var toDelete = [];\n                for (i = 0; i < count; i++) {\n                    var fileName = componentListing[i].name;\n                    var fileInfo = componentListing[i].info;\n\n                    if (!referencedAssetNamesLookup[fileName] && (fileInfo.mtime.getTime() < oldestManifestTimeStamp)\n                            && self._inflightComponents.indexOf(fileName) < 0) {\n                        toDelete.push(fileName);\n                    }\n                }\n                numRequests = count = toDelete.length;\n                if (numRequests > 0) {\n                    // Delete\n                    for (i = 0; i < count; i++) {\n                        doDeleteFile(toDelete[i]);\n                    }\n                }\n            } catch (x) {\n                callback(x);\n                return;\n            }\n            if (numRequests === 0) {\n                // nothing to delete\n                callback();\n            }\n        };\n        \n        this._gatherComponentAssetNames([this.currentManifestPath(), this.currentBaseManifestPath(),\n                                         this.pulledManifestPath(), this.pulledBaseManifestPath(),\n                                         this.pushedManifestPath()], lastCurrentTimeStamp, function (error, manifestCount, assetNamesLookup, oldestTimeStamp) {\n            if (asyncError) {\n                callback(asyncError);\n                return;\n            }\n            if (!error) {\n                try {\n                    if (manifestCount < 1 || !oldestTimeStamp) {\n                        throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, manifestCount < 1 ? 'No manifest found.' : 'Invalid time stamp');\n                    }\n                    referencedAssetNamesLookup = assetNamesLookup;\n                    oldestManifestTimeStamp = oldestTimeStamp;\n                } catch (x) {\n                    error = x;\n                }\n            }\n            if (error) {\n                asyncError = error;\n            }\n            if (componentListing) {\n                // directoryListing() has already returned\n                if (asyncError) {\n                    callback(asyncError);\n                } else {\n                    doDelete();\n                }\n            }\n        });\n        \n        AdobeDCXFS.directoryListing(this._compositePath + '/components', function (error, listing) {\n            if (asyncError) {\n                callback(asyncError);\n                return;\n            }\n            if (!error) {\n                try {\n                    componentListing = listing;\n                } catch (x) {\n                    error = x;\n                }\n            }\n            if (error) {\n                asyncError = error;\n            }\n            if (referencedAssetNamesLookup) {\n                // _gatherComponentAssetNames() has already returned\n                if (asyncError) {\n                    callback(asyncError);\n                } else {\n                    doDelete();\n                }\n            }\n        });\n    };\n    \n    //******************************************************************************\n    // Miscellaneous\n    //******************************************************************************\n    \n    /** Returns a file path that can be used as a tempfile for a component asset. */\n    AdobeDCXLocalStorage.prototype.tempPathForComponent = function () {\n        return this._compositePath + '/tmp/' + dcxUtil.generateUuid();\n    };\n    \n    /** Deletes the temp files of the composite. */\n    AdobeDCXLocalStorage.prototype.deleteTempFiles = function (callback) {\n        AdobeDCXFS.deleteDirectory(this._compositePath + '/tmp', callback);\n    };\n    \n    /** Returns the file path for the client data directory. */\n    AdobeDCXLocalStorage.prototype.clientDataPath = function () {\n        return this._compositePath + '/clientdata';\n    };\n    \n    /** Returns the file path for the push journal. */\n    AdobeDCXLocalStorage.prototype.pushJournalPath = function () {\n        return this._compositePath + '/push.journal';\n    };\n\n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n    \n    /** Copies over storage mapping from one branch to another for a single component defined by sourceId and targetId. */\n    AdobeDCXLocalStorage.prototype._copyComponentMapping = function (sourceId, sourceStorageObject, targetId, targetStorageObject) {\n        var sourceMapping = sourceStorageObject['copyOnWrite#storageIds'];\n        if (!sourceMapping) {\n            return undefined;\n        }\n        \n        var targetMapping = targetStorageObject['copyOnWrite#storageIds'];\n        if (!targetMapping) {\n            targetMapping = targetStorageObject['copyOnWrite#storageIds'] = {};\n        }\n        \n        var assetName = sourceMapping[sourceId];\n        if (assetName) {\n            targetMapping[targetId] = assetName;\n        }\n        return assetName;\n    };\n    \n    AdobeDCXLocalStorage.prototype._componentPathFromName = function (fileName) {\n        return this._compositePath + '/components/' + fileName;\n    };\n    \n    /** Returns a new file path for the given component. */\n    AdobeDCXLocalStorage.prototype._newFileNameForComponent = function (component) {\n        var fileName = dcxUtil.generateUuid();\n        \n        if (this._preserveFileExtensions) {\n            var extension = component.path ? dcxUtil.filePathComponents(component.path).extension : null;\n            if (extension) {\n                fileName = fileName + '.' + extension;\n            }\n        }\n        \n        return fileName;\n    };\n    \n    /** Updates or removes the path for the component in storageObject. */\n    AdobeDCXLocalStorage.prototype._setComponentName = function (component, storageObject, name) {\n        var map = storageObject['copyOnWrite#storageIds'];\n        if (!map) {\n            map = storageObject['copyOnWrite#storageIds'] = {};\n        }\n        \n        map[component.id] = name;\n    };\n    \n    AdobeDCXLocalStorage.prototype._gatherComponentAssetNames = function (manifestPaths, oldestTimeStamp, callback) {\n        try {\n            var assetNames = {};\n            var oldestManifestTimeStamp = oldestTimeStamp || dcxUtil.timeStamp(true);\n\n            var i, count = manifestPaths.length;\n            var requestCount = count;\n            var manifestCount = 0;\n            var asyncError;\n            \n            var addFromData = function (data) {\n                if (data) {\n                    data = data['copyOnWrite#storageIds'];\n                    var keys = Object.keys(data), i;\n                    for (i = 0; i < keys.length; i++) {\n                        var fileName = data[keys[i]];\n                        assetNames[fileName] = true;\n                    }\n                }\n            };\n\n            // Gets called once for each manifest path. Determines if the manifest exists, what its modification time\n            // stamp is and reads its data to add its component file names to the assetNames lookup.\n            var processManifest = function (manifestPath) {\n                AdobeDCXFS.exists(manifestPath, function (exists) {\n                    if (exists) {\n                        manifestCount++;\n                        AdobeDCXFS.info(manifestPath, function (error, info) {\n                            if (!error) {\n                                try {\n                                    var timeStamp = info.mtime.getTime();\n                                    if (timeStamp < oldestManifestTimeStamp) {\n                                        oldestManifestTimeStamp = timeStamp;\n                                    }\n                                    AdobeDCXFS.readFile(manifestPath, 'utf8', function (error, data) {\n                                        requestCount--;\n                                        if (!error) {\n                                            try {\n                                                data = JSON.parse(data);\n                                                addFromData(data.local);\n                                            } catch (x) {\n                                                error = x;\n                                            }\n                                        }\n                                        if (error && !asyncError) {\n                                            asyncError = error;\n                                        }\n                                        if (requestCount === 0) {\n                                            callback(asyncError, manifestCount, assetNames, oldestManifestTimeStamp);\n                                        }\n                                    });\n                                } catch (x) {\n                                    error = x;\n                                }\n                            }\n                            if (error) {\n                                requestCount--;\n                                if (!asyncError) {\n                                    asyncError = error;\n                                }\n                                if (requestCount === 0) {\n                                    callback(asyncError);\n                                }\n                            }\n                        });\n                    } else {\n                        requestCount--;\n                        if (requestCount === 0) {\n                            callback(asyncError, manifestCount, assetNames, oldestManifestTimeStamp);\n                        }\n                    }\n                });\n            };\n\n            for (i = 0; i < count; i++) {\n                processManifest(manifestPaths[i]);\n            }\n            \n            // add data from in-memory branches and  elements\n            count = this._inMemoryBranchesAndElements.length;\n            for (i = 0; i < count; i++) {\n                addFromData(this._inMemoryBranchesAndElements[i]._local());\n            }\n        } catch (x) {\n            callback(x);\n        }\n    };\n    \n    AdobeDCXLocalStorage.prototype._deleteComponentAsset = function (fileName, callback) {\n        AdobeDCXFS.deleteFile(this._componentPathFromName(fileName), callback);\n    };\n    \n    return AdobeDCXLocalStorage;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* An AdobeDCXComposite represents a DCX composite.\n*\n* <p>The constructor for AdobeDCXComposite is private. Refer to {@link module:AdobeDCX} to learn how \n* to create instances of AdobeDCXComposite.\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXComposite\n*/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCXComposite',['require','exports','module','./AdobeDCXError','./AdobeDCXBranch','./AdobeDCXPushJournal','./AdobeDCXLocalStorage','./AdobeDCXFS','./AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError');\n    var AdobeDCXBranch = require('./AdobeDCXBranch');\n    var AdobeDCXPushJournal = require('./AdobeDCXPushJournal');\n    var AdobeDCXLocalStorage = require('./AdobeDCXLocalStorage');\n    var AdobeDCXFS = require('./AdobeDCXFS');\n    var dcxUtil = require('./AdobeDCXUtil');\n    \n    var COLLABORATION = {\n        PRIVATE: undefined,\n        SHARED_BY_USER: 'sharedByUser',\n        SHARED_WITH_USER: 'sharedWithUser'\n    };\n    /**\n     * The constructor for AdobeDCXComponent is private. Component instances are getting instantiated \n     * on an as needed-bases.\n     * @private\n     * @alias module:AdobeDCXComposite\n     * @param {String} name    \n     * @param {String} type    \n     * @param {String} path    \n     * @param {String} id      \n     * @param {String} href    \n     * @param {Object} options  \n     */\n    function AdobeDCXComposite(name, type, path, id, href, options) {\n        href = dcxUtil.ensureRelativeHrefStartsWithSlash(href);\n        this._options = options || {};\n        if (path) {\n            // locally persisted composite\n            this._setPath(path);\n        } else if (href) {\n            // exists on server but not yet locally\n            this._href = href;\n            if (name) {\n                this._name = name;\n            }\n            if (type) {\n                this._type = type;\n            }\n            if (id) {\n                this._id = id;\n            }\n        } else if (type) {\n            // brand new composite\n            this._current = new AdobeDCXBranch();\n            if (name) {\n                this._current._data.name = name;\n            }\n            this._current._data.type = type;\n            \n            if (id) {\n                this._current.compositeId = id;\n            }\n        }\n        \n        this._autoRemoveUnusedLocalFiles = true;\n        \n        if (this._options.xhrBaseBranchSupport) {\n            this._baseBranchData = undefined;\n            this._pushedBranchData = undefined;\n            this._pulledBranchData = undefined;\n        }\n        \n        this._collaborationType = COLLABORATION.PRIVATE;\n    }\n    \n    /**\n     * <p>Creates and returns a new composite object that is a copy of compositeBranchOrElement.</p>\n     * \n     * <p>Note that this function currently doesn't support copying the local component files of \n     * composites with local storage. The resulting composite will be in memory only and you can \n     * push it to the server (after committing it to disk), which will result in the component files \n     * being copied on the server. In order to get the components downloaded to local storage you \n     * will then need to call downloadComponents().</p>\n     * \n     * <p>Because of the restriction noted above you must not call this function with a composite\n     * that contains new or updated components.</p>\n     * \n     * @param   {Object}            compositeOrBranchOrElement As the name implies this param is expected to be\n     *                                                         either a composite (with a valid current branch),\n     *                                                         a branch or an element. Furthermore it may (at\n     *                                                         this point in time) not contain an new or modified\n     *                                                         components.\n     * @param   {String}            [name]                     An optional new name for the new composite. If undefined\n     *                                                         the composite will have the same name as the original.\n     * @param   {String}            [type]                     An optional new type for the new composite. If undefined\n     *                                                         the composite will have the same type as the original.\n     * @param   {String}            [path]                     The optional local file path for the composite.\n     * @param   {String}            [id]                       An optional new id for the new composite. If undefined\n     *                                                         the composite will get a random new id.\n     * @param   {String}            [href]                     The new href of the composite\n     * @param   {Object}            [options]                  See constructor.\n     * @returns {AdobeDCXComposite} The new composite\n     */\n    AdobeDCXComposite.newCompositeAsCopyOf = function (compositeOrBranchOrElement, name, type, path, id, href, options) {\n        \n        var core = compositeOrBranchOrElement._core;\n        \n        if (!core) {\n            if (compositeOrBranchOrElement.current) {\n                core = compositeOrBranchOrElement.current._core;\n            }\n        }\n        if (!core) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS,\n                                    'compositeBranchOrElement must be a branch, an element or a composite with a current branch.');\n        }\n        \n        var composite = new AdobeDCXComposite(undefined, undefined, undefined, undefined, undefined, options);\n        if (path) {\n            composite.path = path;\n        }\n        \n        composite._current = AdobeDCXBranch._newBranchAsCopyOfCore(core, this._localStorage);\n        composite.id = id || dcxUtil.generateUuid();\n        if (name) {\n            composite.name = name;\n        }\n        if (type) {\n            composite.type = type;\n        }\n        if (href) {\n            composite.href = href;\n        }\n        \n        return composite;\n    };\n    \n    /**\n     * Constants for the collaborationType property.\n     */\n    AdobeDCXComposite.COLLABORATION = COLLABORATION;\n    \n    //******************************************************************************\n    // Getters/setters for properties\n    //******************************************************************************\n    \n    Object.defineProperties(AdobeDCXComposite.prototype, {\n        /**\n         * The id of the composite.\n         * \n         * <p>While not strictly read-only most clients do not ever have to modify this property.</p>\n         * @type {String}\n         */\n        id: {\n            get: function () {\n                return (this._current ? this._current.compositeId : this._id);\n            },\n            set: function (id) {\n                if (typeof id !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else {\n                    if (this._current) {\n                        this._current.compositeId = id;\n                    }\n                    this._id = id;\n                }\n            }\n        },\n        /**\n         * The name of the composite.\n         * \n         * @type {String}\n         */\n        name: {\n            get: function () {\n                return (this._current ? this._current.name : this._name);\n            },\n            set: function (name) {\n                if (typeof name !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else {\n                    if (this._current) {\n                        this._current.name = name;\n                    }\n                    this._name = name;\n                }\n            }\n        },\n        /**\n         * The type of the composite.\n         * \n         * @type {String}\n         */\n        type: {\n            get: function () {\n                return (this._current ? this._current.type : this._type);\n            },\n            set: function (type) {\n                if (typeof type !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else {\n                    if (this._current) {\n                        this._current.type = type;\n                    }\n                    this._type = type;\n                }\n            }\n        },\n        /**\n         * The href of the composite that can be used to pull and push the composite. Can be either\n         * relative to the service endpoint or absolute\n         * <strong>Do not modify this for a bound composite.</strong>\n         * @type {String}\n         */\n        href: {\n            get: function () {\n                return (this._current ? this._current.compositeHref : this._href);\n            },\n            set: function (href) {\n                if (typeof href !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else {\n                    href = dcxUtil.ensureRelativeHrefStartsWithSlash(href);\n                    if (this._current) {\n                        this._current.compositeHref = href;\n                    }\n                    this._href = href;\n                }\n            }\n        },\n        /**\n         * Whether (and how) the composite is shared. See \n         * {@link module:AdobeDCX.COLLABORATION|AdobeDCX.COLLABORATION}.\n         * It is the client's responsibility to correctly set this property so that DCX can push\n         * the composite correctly.\n         * <p><strong>Composites with a collaboration type of AdobeDCX.COLLABORATION.SHARED_WITH_USER \n         * must not be deleted. Use AdobeStorageSession.leaveSharedComposite() to remove a shared \n         * composite from the user's sync group.</p>\n         * @type {String}\n         * @default [COLLABORATION.PRIVATE]\n         */\n        collaborationType: {\n            get: function () {\n                return (this._current ? this._current._collaborationType : this._collaborationType);\n            },\n            set: function (value) {\n                if (value !== COLLABORATION.PRIVATE && value !== COLLABORATION.SHARED_BY_USER\n                          && value !== COLLABORATION.SHARED_WITH_USER) {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Invalid value: .' + value);\n                } else {\n                    if (this._current) {\n                        this._current._collaborationType = value;\n                    }\n                    this._collaborationType = value;\n                }\n            }\n        },\n        /**\n         * <strong>NJS-only</strong>\n         *\n         * <p>The local file path of the composite.</p>\n         * \n         * @type {String}\n         */\n        path: {\n            get: function () {\n                return this._path;\n            },\n            set: function (path) {\n                if (typeof path !== 'string') {\n                    throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Expecting a string.');\n                } else {\n                    this._setPath(path);\n                }\n            }\n        },\n        /**\n         * Whether the composite is bound to a composite on a server. If <em>false</em> for newly\n         * created empty composites that have never been pulled from or pushed to the server.\n         * @readonly\n         * @type {Boolean}\n         */\n        isBound: {\n            get: function () {\n                return (this._current && this._current.isBound) || (!this._current && this._href);\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property isBound. Use resetIdentity or resetBinding instead.');\n            }\n        },\n        /**\n         * Whether the composite has local storage.\n         * @readonly\n         * @type {Boolean}\n         */\n        hasLocalStorage: {\n            get: function () {\n                return this._localStorage;\n            },\n            set: function () {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Cannot set the property hasLocalStorage.');\n            }\n        },\n        /**\n         * <strong>NJS-only</strong>\n         *\n         * <p>Whether to automatically remove unused local files.</p>\n         * @type {Boolean}\n         */\n        autoRemoveUnusedLocalFiles: {\n            get: function () {\n                if (!this._localStorage) {\n                    throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n                }\n                return this._autoRemoveUnusedLocalFiles;\n            },\n            set: function (autoRemoveUnusedLocalFiles) {\n                if (!this._localStorage) {\n                    throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n                }\n                this._autoRemoveUnusedLocalFiles = autoRemoveUnusedLocalFiles;\n            }\n        },\n        /**\n         * <strong>NJS-only</strong>\n         *\n         * <p>A file path to a local directory where the client can store custom data that\n         * will not be pushed to the server.</p>\n         * \n         * @readonly\n         * @type {String}\n         */\n        clientDataStoragePath: {\n            get: function () {\n                if (!this._localStorage) {\n                    throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n                }\n                return this._localStorage.clientDataPath();\n            },\n            set: function (path) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Property \"clientDataStoragePath\" is read-only.');\n            }\n        },\n        /**\n         * The editable current branch the composite. Is undefined in case of a composite that hasn't \n         * been pulled from the server yet.\n         * @readonly\n         * @type {AdobeDCXBranch}\n         */\n        current: {\n            get: function () {\n                return this._current;\n            },\n            set: function (branch) {\n                throw new AdobeDCXError(AdobeDCXError.READ_ONLY, 'Property \"current\" is read-only.');\n            }\n        }\n    });\n    \n    \n    //******************************************************************************\n    // Local Storage\n    //******************************************************************************\n    \n    /**\n     * Callback function used for operations that return a branch.\n     * @callback branchCallback\n     *    @param {Error}           error\n     *    @param {AdobeDCXBranch}  branch\n     */\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Loads current from local storage. Notice that this method will overwrite the contents of\n     * the <em>current</em> property of the composite. This means that you will lose any uncommitted\n     * edits to it.</p>\n     * @param {branchCallback} callback Gets called upon completion or failure.\n     */\n    AdobeDCXComposite.prototype.loadCurrentFromLocalStorage = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n\n        var self = this;\n        this._loadBranch(this._localStorage.currentManifestPath(), false, function (error, branch) {\n            if (!error && branch) {\n                try {\n                    self._current = branch;\n                    self._currentBranchCommittedAtDate = dcxUtil.timeStamp(true);\n                } catch (x) {\n                    error = x;\n                }\n            }\n            callback(error, error ? undefined : branch);\n        });\n    };\n    \n    /**\n     * Callback function used for operations that don't return anything other than a potential error.\n     * @callback errorCallback\n     *    @param {Error}           error\n     */\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Writes current to local storage.</p>\n     * @param   {errorCallback} callback Gets called on completion.\n     */\n    AdobeDCXComposite.prototype.commitChanges = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        if (!this._current) {\n            return callback(new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Current branch is not in memory.'));\n        }\n            \n        // Store this in composite so that we can access it in the closure below.\n        var self = this;\n        AdobeDCXFS.writeFileAtomically(this._localStorage.currentManifestPath(), this._current.localData, 'utf8', function (error) {\n            if (!error) {\n                try {\n                    self._currentBranchCommittedAtDate = dcxUtil.timeStamp(true);\n                    self._current._isDirty = false;\n                } catch (x) {\n                    error = x;\n                }\n            }\n            callback(error);\n        });\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Returns a path that can be used as a temporary file path for component assets.</p>\n     *\n     * @returns {String} path.\n     */\n    AdobeDCXComposite.prototype.tempAssetPath = function () {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        return this._localStorage.tempPathForComponent();\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Deletes temp files.</p>\n     *\n     * @param {errorCallback} callback Optional. Gets called on completion.\n     */\n    AdobeDCXComposite.prototype.deleteTempFiles = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        this._localStorage.deleteTempFiles(function (error) {\n            if (callback) {\n                callback(error);\n            }\n        });\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Deletes unused local files such as components that are no longer referenced by any branch \n     * of the composite.</p>\n     * \n     * <p>This method is only required to be called when the client has set the \n     * autoRemoveUnusedLocalFiles property to false.\n     *\n     * @param {errorCallback} callback Gets called upon completion.\n     */\n    AdobeDCXComposite.prototype.removeUnusedLocalFiles = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        this._localStorage.removeUnusedLocalFiles(this._currentBranchCommittedAtDate, callback);\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Deletes the directory at the path of the composite with all its contents.</p>\n     *\n     * @param   {errorCallback} callback Gets called on completion.\n     */\n    AdobeDCXComposite.prototype.removeLocalStorage = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        if (!this._path) {\n            return callback(new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'No path set.'));\n        }\n\n        AdobeDCXFS.deleteDirectory(this._path, callback);\n    };\n    \n    //******************************************************************************\n    // Branches\n    //******************************************************************************\n    \n    /**\n     * Loads the base manifest and instantiates a read-only branch if the manifest exists.\n     *\n     * <p>When running in a browser (<strong>XHR</strong>) this method can only be called\n     * if the AdobeDCX instance has been initialized with the <em>xhrBaseBranchSupport</em> option.</p>\n     *\n     * @param {branchCallback} callback Gets called on success or failure.\n     */\n    AdobeDCXComposite.prototype.loadBaseBranch = function (callback) {\n        if (!this._localStorage && !this._baseBranchData) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        if (this._localStorage) {\n            this._loadBranch(this._localStorage.currentBaseManifestPath(), true, callback);\n        } else {\n            var error, branch;\n            try {\n                branch = new AdobeDCXBranch(undefined, true).parse(this._baseBranchData);\n            } catch (x) {\n                error = x;\n            }\n            callback(error, branch);\n        }\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Loads the pulled manifest and instantiates a writeable branch if the manifest exists.</p>\n     *\n     * @param {branchCallback} callback Gets called on success or failure.\n     */\n    AdobeDCXComposite.prototype.loadPulledBranch = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        this._loadBranch(this._localStorage.pulledManifestPath(), false, callback);\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Loads the pushed manifest and instantiates a writeable branch if the manifest exists.</p>\n     *\n     * @param {branchCallback} callback Gets called on success or failure.\n     */\n    AdobeDCXComposite.prototype.loadPushedBranch = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        this._loadBranch(this._localStorage.pushedManifestPath(), false, callback);\n    };\n    \n    /**\n     * Accepts the given merged branch as the new current branch, discards any temporary pull data\n     * and also updates the base manifest. Is a no-op if no branch is provided and if there\n     * is no pulled manifest in local storage (as may be the case if a pull didn't find any\n     * modification on the server).\n     *\n     * @example\n     * // NJS\n     * dcx.compositeXfer.pullComposite(composite, session, function (error, pulledBranch) {\n     *      if (!error) {\n     *          // The pull has succeeded. Now you need to incorporate the changes from the server \n     *          // into your current branch.\n     *          // Start the merge by making a mutable copy of pulledBranch\n     *          var mergedBranch = pulledBranch.copy();\n     *          // Now merge any changes you have made to current since the last successful push or\n     *          // pull. You might want to also load the base branch to help you figure out what has\n     *          // changed in either branch.\n     *          ...\n     *          // When done merging you need to make this call:\n     *          composite.resolvePullWithBranch(mergedBranch, function (error, newCurrent) {\n     *              if (!error) {\n     *                  // Now you are done!\n     *              }\n     *          });\n     *      }\n     * });\n     *\n     * @example\n     * // XHR\n     * dcx.compositeXfer.pullCompositeManifestOnly(composite, session, function (error, pulledBranch) {\n     *      if (!error) {\n     *          // The pull has succeeded. Now you need to incorporate the changes from the server \n     *          // into your current branch. If you follow the recommendations for working in an\n     *          // online environment you will not have modified current so you can just call:\n     *          composite.resolvePullWithBranch(pulledBranch);\n     *      }\n     * });\n     *\n     *\n     * <p><strong>The branch passed in must be derived from the pulled branch.</strong></p>\n     *\n     * @param {AdobeDCXBranch} branch     A branch which should become the new current branch. It \n     *                                    should be the result of merging the previously pulled\n     *                                    branch with any changes in current.\n     * @param {branchCallback} [callback] Optional if running in an <strong>XHR</strong>\n     *                                    environment. Gets called on completion.\n     * @return {AdobeDCXBranch} Only returns the new current branch if called without\n     *                                     a callback.\n     */\n    AdobeDCXComposite.prototype.resolvePullWithBranch = function (branch, callback) {\n        if (!branch) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Need a branch.');\n        }\n        if (branch === this._current) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Cannot resolve current.');\n        }\n        if (this._localStorage && !callback) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Need a callback function.');\n        }\n        if (this._localStorage) {\n            var self = this;\n            self._localStorage.resolvePulledBranch(branch, function (error) {\n                if (!error) {\n                    try {\n                        self._current = branch;\n                        if (self._autoRemoveUnusedLocalFiles) {\n                            // Trigger garbage collection.\n                            self._localStorage.removeUnusedLocalFiles(self._currentBranchCommittedAtDate, function (error) {\n                               // TODO: We might want to log any failures here.\n                            });\n                        }\n                    } catch (x) {\n                        error = x;\n                    }\n                }\n\n                callback(error, error ? undefined : self._current);\n            });\n        } else {\n            if (this._options.xhrBaseBranchSupport) {\n                // We need to preserve the pulled branch as base branch.\n                // The pull logic in the the xfer class is responsible for setting this._pulledBranchData.\n                this._baseBranchData = this._pulledBranchData;\n                this._pulledBranchData = undefined;\n            }\n            this._current = branch;\n            if (callback) {\n                callback(undefined, this._current);\n            } else {\n                return this._current;\n            }\n        }\n    };\n    \n    /**\n     * Updates the current branch (both in memory and -- if applicable -- in local storage) with the \n     * results of the most recent push, discards any temporary push data and updates base. Is a\n     * no-op if there are no push results (because e.g. there were no changes to push).\n     *\n     * @example\n     * // NJS\n     * dcx.compositeXfer.pushComposite(composite, false, session, function (error) {\n     *      if (!error) {\n     *          // The push has succeeded. You now need to accept it to update your current branch\n     *          composite.acceptPush(function (error) {\n     *              if (!error) {\n     *                  // Now you are done!\n     *              }\n     *          });\n     *      }\n     * });\n     *\n     * @example\n     * // XHR\n     * dcx.compositeXfer.pushComposite(composite, false, session, function (error) {\n     *      if (!error) {\n     *          // The push has succeeded. If you want to continue to work with the composite you\n     *          // must accept the push -- otherwise you are done now\n     *          composite.acceptPush();\n     *      }\n     * });\n     *\n     * @param   {errorCallback} [callback]  Optional when calling in an <strong>XHR</strong> \n     *                                      environment. Gets called on completion.\n     * @returns {AdobeDCXBranch}            Only returns the new current branch if called without\n     *                                      a callback.    \n     */\n    AdobeDCXComposite.prototype.acceptPush = function (callback) {\n        if (this._localStorage && !callback) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Need a callback function.');\n        }\n        \n        // In order to accept we need three things:\n        // 1. current (which should be in memory)\n        // 2. The committed version of current (only if we have local storage)\n        // 3. The push journal\n        // When running in a browser we have everything we need in memory, in a NJS environment,\n        // however, we need to load #2 and #3, before we can accept\n        var pushJournal, committedCurrent;\n        \n        var self = this;\n        \n        var finalize = function (error) {\n            if (!error) {\n                // If pushJournal is undefined this means that it doesn't exist, which is OK\n                if (pushJournal) {\n                    try {\n                        if (self._localStorage) {\n                            pushJournal.applyToBranch(committedCurrent);\n                            self._localStorage.acceptPushedBranch(committedCurrent, function (error) {\n                                if (!error) {\n                                    try {\n                                        pushJournal.applyToBranch(self._current, /*preserveDirtyState*/true);\n                                        if (self._autoRemoveUnusedLocalFiles) {\n                                            // Trigger garbage collection.\n                                            self._localStorage.removeUnusedLocalFiles(self._currentBranchCommittedAtDate, function (error) {\n                                               // TODO: We might want to log any failures here.\n                                            });\n                                        }\n                                    } catch (x) {\n                                        error = x;\n                                    }\n                                }\n                                callback(error);\n                            });\n                        } else {\n                            pushJournal.applyToBranch(self._current, /*preserveDirtyState*/true);\n                            if (self._options.xhrBaseBranchSupport) {\n                                // We need to preserve the pulled branch as base branch.\n                                // The push logic in the the xfer class is responsible for setting self._pushedBranchData.\n                                self._baseBranchData = self._pushedBranchData;\n                                self._pushedBranchData = undefined;\n                            }\n                            self._pushJournal = undefined;\n                            if (callback) {\n                                callback();\n                            }\n                        }\n                    } catch (x) {\n                        error = x;\n                    }\n                } else if (callback) {\n                    callback();\n                }\n            }\n            if (error) {\n                if (callback) {\n                    callback(error);\n                } else {\n                    throw error;\n                }\n            }\n        };\n        \n        if (this._localStorage) {\n            // Initiate loads of the journal and the committed current branch. Whichever finishes\n            // last will call finalize().\n            var asyncError, pending = 2;\n            AdobeDCXPushJournal.readJournal(self._localStorage.pushJournalPath(), self, false, function (error, journal) {\n                pending--;\n                if (asyncError) {\n                    // Loading the current branch has failed.\n                    finalize();\n                } else {\n                    if (error) {\n                        // We do not consider a missing push journal an error because that can happen\n                        // if pushComposite doesn't find any changes to push.\n                        if (error.code !== 'ENOENT') {\n                            asyncError = new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Failed to load push journal.', error);\n                        }\n                    } else {\n                        pushJournal = journal;\n                    }\n                    if (!pending) {\n                        finalize();\n                    }\n                }\n            });\n            this._loadBranch(this._localStorage.currentManifestPath(), false, function (error, branch) {\n                pending--;\n                if (asyncError) {\n                    // Loading the push journal has failed.\n                    finalize();\n                } else {\n                    if (error) {\n                        asyncError = new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Failed to load current manifest.', error);\n                    } else {\n                        committedCurrent = branch;\n                    }\n                    if (!pending) {\n                        finalize();\n                    }\n                }\n            });\n        } else {\n            // We have everything we need in memory.\n            pushJournal = this._pushJournal;\n            return finalize();\n        }\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Discards the last pull.</p>\n     * \n     * @param {errorCallback} callback Gets called on completion.\n     */\n    AdobeDCXComposite.prototype.discardPulledBranch = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        var self = this;\n        \n        this._localStorage.discardPulledBranch(function (error) {\n            if (!error) {\n                try {\n                    if (self._autoRemoveUnusedLocalFiles) {\n                        // Trigger garbage collection.\n                        self._localStorage.removeUnusedLocalFiles(self._currentBranchCommittedAtDate, function (error) {\n                           // TODO: We might want to log any failures here.\n                        });\n                    }\n                } catch (x) {\n                    error = x;\n                }\n                callback(error);\n            }\n            \n            if (error) {\n                callback(error);\n            }\n        });\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Discards the last push.</p>\n     * \n     * @param {errorCallback} callback Gets called on completion.\n     */\n    AdobeDCXComposite.prototype.discardPushedBranch = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        var self = this;\n        \n        this._localStorage.discardPushedBranch(function (error) {\n            if (!error) {\n                try {\n                    if (self._autoRemoveUnusedLocalFiles) {\n                        // Trigger garbage collection.\n                        self._localStorage.removeUnusedLocalFiles(self._currentBranchCommittedAtDate, function (error) {\n                           // TODO: We might want to log any failures here.\n                        });\n                    }\n                } catch (x) {\n                    error = x;\n                }\n                callback(error);\n            }\n            \n            if (error) {\n                callback(error);\n            }\n        });\n    };\n    \n    //******************************************************************************\n    // Miscellaneous\n    //******************************************************************************\n    \n    /**\n     * Removes all service-related data from the current banch and resets all other branches so that \n     * the composite can be pushed again to the same or a different service.\n     * @param {errorCallback} [callback] Optional if called from an <strong>XHR</strong> \n     *                                   environment. Gets called on success or failure.\n     */\n    AdobeDCXComposite.prototype.resetBinding = function (callback) {\n        delete this._href;\n        if (this._current) {\n            this._current._resetBinding();\n        }\n        if (this._localStorage) {\n            this._discardEveryBranchButCurrent(callback);\n        } else {\n            this._baseBranchData = undefined;\n            this._pushedBranchData = undefined;\n            this._pulledBranchData = undefined;\n            if (callback) {\n                callback();\n            }\n        }\n    };\n    \n    /**\n     * Assigns a new id to the current branch and resets all other branches. Also removes all \n     * service-related data from the current branch so that it can be pushed again to the same or \n     * a different service.\n     * @param {errorCallback} [callback] Optional if called from an <strong>XHR</strong> \n     *                                   environment. Gets called on success or failure.\n     */\n    AdobeDCXComposite.prototype.resetIdentity = function (callback) {\n        var self = this;\n        delete this._href;\n        if (this._current) {\n            this._current._resetIdentity();\n            this._id = this._current.compositeId;\n        } else {\n            this._id = dcxUtil.generateUuid();\n        }\n        if (this._localStorage) {\n            this._discardEveryBranchButCurrent(callback);\n        } else {\n            this._baseBranchData = undefined;\n            this._pushedBranchData = undefined;\n            this._pulledBranchData = undefined;\n            if (callback) {\n                callback();\n            }\n        }\n    };\n    \n    //******************************************************************************\n    // Private - Branches\n    //******************************************************************************\n    \n    /**\n     * Loads the manifest and instantiates a branch if it exists.\n     * @private\n     * @param {String}   manifestPath The path to load the manifest from.\n     * @param {Boolean}  readOnly     Whether the new branch should be read-only.\n     * @param {branchCallback} callback     Gets called on success or failure. Signature: function (error, branch).\n     */\n    AdobeDCXComposite.prototype._loadBranch = function (manifestPath, readOnly, callback) {\n        if (typeof callback !== 'function') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"callback\" must be a function.');\n        }\n        var self  = this;\n        AdobeDCXFS.exists(manifestPath, function (exists) {\n            if (!exists) {\n                callback();\n            } else {\n                AdobeDCXFS.readFile(manifestPath, 'utf8', function (error, data) {\n                    var branch;\n                    if (!error) {\n                        try {\n                            branch = new AdobeDCXBranch(undefined, readOnly).parse(data);\n                            branch._localStorage = self._localStorage;\n                        } catch (x) {\n                            error = x;\n                        }\n                    }\n                    callback(error, branch);\n                });\n            }\n        });\n    };\n    \n    //******************************************************************************\n    // Private\n    //******************************************************************************\n    \n    /**\n     * Discards all branches with the exception of current from both disk and memory.\n     * @private\n     * @param {errorCallback} callback Gets called on success or failure. In the latter case an error object is provided.\n     */\n    AdobeDCXComposite.prototype._discardEveryBranchButCurrent = function (callback) {\n        if (!this._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.NO_LOCAL_STORAGE, 'No local storage.');\n        }\n        \n        var self = this;\n        var branchesToDiscard = 3;\n        var asyncError;\n        \n        // Callback for discards\n        var oneDown = function (error) {\n            if (error && !asyncError) {\n                asyncError = error;\n            }\n            branchesToDiscard--;\n            if (branchesToDiscard === 0) {\n                if (!asyncError && self._autoRemoveUnusedLocalFiles) {\n                    // Trigger garbage collection.\n                    self._localStorage.removeUnusedLocalFiles(self._currentBranchCommittedAtDate, function (error) {\n                       // TODO: We might want to log any failures here.\n                    });\n                }\n                callback(asyncError);\n            }\n        };\n        \n        // Discard all the branches in parallel\n        this._localStorage.discardPushedBranch(oneDown);\n        this._localStorage.discardPulledBranch(oneDown);\n        this._localStorage.discardBaseBranch(oneDown);\n    };\n    \n    /** Sets the path property and creates or updates local storage. */\n    /**\n     * @private\n     * @param {String} path \n     */\n    AdobeDCXComposite.prototype._setPath = function (path) {\n        if (this._localStorage) {\n            this._localStorage.compositePath = path;\n        } else if (AdobeDCXFS.canUseFileSystem) {\n            this._localStorage = new AdobeDCXLocalStorage(path, this._options.preserveFileExtensions);\n            if (this._current) {\n                this._current._localStorage = this._localStorage;\n            }\n        }\n        this._path = path;\n    };\n    \n    return AdobeDCXComposite;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define, console, Int8Array */\n\n/**\n@class AdobeStorageSession\n**/\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeStorageSession',['require','exports','module','./AdobeDCXError','./AdobeDCXComposite','./AdobeDCXUtil','./AdobeNetworkHTTPService'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXError = require('./AdobeDCXError');\n    var AdobeDCXComposite = require('./AdobeDCXComposite');\n    var dcxUtil = require('./AdobeDCXUtil');\n    var AdobeNetworkHTTPService = require('./AdobeNetworkHTTPService');\n    \n    var merge = dcxUtil.merge;\n    var appendPathElements = dcxUtil.appendPathElements;\n    \n    var ifMatchHeader = 'If-Match';\n    var ifNoneMatchHeader = 'If-None-Match';\n    var adobeDCXManifestType = 'application/vnd.adobe.dcx-manifest+json';\n    \n    \n    var noReWrap = {};\n    noReWrap[AdobeDCXError.SERVICE_IS_INACTIVE] = 1;\n    noReWrap[AdobeDCXError.NOT_IMPLEMENTED] = 1;\n    noReWrap[AdobeDCXError.EXCEEDS_QUOTA] = 1;\n    noReWrap[AdobeDCXError.RETRYABLE_SERVER_ERROR] = 1;\n    noReWrap[AdobeDCXError.TIMED_OUT] = 1;\n    noReWrap[AdobeDCXError.TERMINATED_INPUTSTREAM] = 1;\n    noReWrap[AdobeDCXError.WRONG_ENDPOINT] = 1;\n    noReWrap[AdobeDCXError.OUT_OF_SPACE] = 1;\n    \n    function wrapError(code, message, error, response) {\n        // Don't re-wrap certain error codes\n        if (!error || !noReWrap[error.code]) {\n            // If status code is a 5xx error, return suitable error code\n            if (response) {\n                var status = response.statusCode;\n                if (status >= 500 && status < 600) {\n                    if (status === 501) {\n                        code = AdobeDCXError.NOT_IMPLEMENTED;\n                        message = \"Unimplemented request\";\n                    } else if (status === 507) {\n                        code = AdobeDCXError.EXCEEDS_QUOTA;\n                        message = \"Quota exceeded\";\n                    } else {\n                        code = AdobeDCXError.RETRYABLE_SERVER_ERROR;\n                        message = \"Server error\";\n                    }\n                }\n            }\n            error = new AdobeDCXError(code, message, error);\n        }\n        if (response) {\n            error.response = response;\n        }\n        return error;\n    }\n    \n    function networkError(message, error, response) {\n        return wrapError(AdobeDCXError.NETWORK_ERROR, message, error, response);\n    }\n   \n    function unexpectedResponse(message, error, response) {\n        return wrapError(AdobeDCXError.UNEXPECTED_RESPONSE, message, error, response);\n    }\n    \n    //******************************************************************************\n    // Public API\n    //******************************************************************************\n   \n    /** \n    @constructor\n    @param httpService the HTTP service\n    @param server      the url for the storage server\n    */\n    function AdobeStorageSession(httpService, server) {\n        this._service = httpService;\n        this._server = server;\n        this._endPoint = dcxUtil.endPointOf(server);\n        \n        if (!this._endPoint) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Could not determine endpoint from: ' + server);\n        }\n        \n        this.SYNC_ASYNC_DEFAULT_DELAY = 5;\n        this.ASYNC_DEFAULT_DELAY = 1;\n        this.DEFAULT_POLL_DELAY = 10;\n    }\n    \n    // Export error wrapper\n    AdobeStorageSession.wrapError = wrapError;\n    AdobeStorageSession.FileContent = AdobeNetworkHTTPService.FileContent;\n    AdobeStorageSession.StreamProvider = AdobeNetworkHTTPService.StreamProvider;\n    \n    /**\n     * Given an href string this method returns true if it is either relative or it refers\n     * to the same endpoint as the session's server.\n     * @param {String} href The href to check\n     */\n    AdobeStorageSession.prototype.isValidHref = function (href) {\n        var endPoint = dcxUtil.endPointOf(href);\n        \n        return !endPoint || endPoint === this._endPoint;\n    };\n\n    /**\n     Get the contents of a collection.\n     If the results are paged, this collects all of the pages, appending the children.\n     \n     @return         the requestDescriptor for this request.\n     @param href     the url for the collection.\n     @param etag     the entity tags for this request\n     @param callback called on completion. Signature: callback(error, resultJson, etag, responseHeaders)\n     */\n    AdobeStorageSession.prototype.getCollection = function (href, etag, callback) {\n        href = this._resolveUrl(href);\n        if (!href) {\n            return callback(new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + href));\n        }\n        \n        href += '?order=asc&orderby=name';\n        var result;\n        var headers = {};\n        if (etag) {\n            headers[ifNoneMatchHeader] = etag;\n        }\n        var self = this;\n        // TODO: handle etags request\n        function respHandler(error, response) {\n            if (error) {\n                return callback(networkError('Error retrieving a collection', error, response));\n            }\n            if (response.statusCode === 200) {\n                var buf = response.responseText || response.response;\n                var json = JSON.parse(buf); // TODO: catch parse error\n                if (result) {\n                    result.children = result.children.concat(json.children);\n                } else {\n                    result = json;\n                }\n                var nextStart = response.headers[\"x-children-next-start\"];\n                if (nextStart) {\n                    var href2 = href + '&start=' +  nextStart;\n                    self._service.invoke('GET', href2, headers, undefined, { responseType: 'text' }, respHandler);\n                } else {\n                    callback(undefined, result, response.headers.etag, response.headers);\n                }\n            } else {\n                if (response.statusCode === 304) {\n                    // null signifies \"not modified\"\n                    callback(undefined, null, response.headers.etag, response.headers);\n                } else {\n                    callback(unexpectedResponse('Unexpected status code while getting a collection', undefined, response));\n                }\n            }\n        }\n        var req = this._service.invoke('GET', href, headers, undefined, { responseType: 'text' }, respHandler);\n        return req;\n    };\n    \n    /**\n    Gets an asset from the storage service.\n        \n    @return              the http requestDescriptor.\n    @param href          the URL of the asset to retrieve.\n    @param etagOrHeaders if a string, the etag to use, if an object a set of additional headers, if undefined. ignored\n    @param callback      called back when the asset has been fetched. Signature: callback(error, httpResponse).\n    */\n    AdobeStorageSession.prototype.getAsset = function (href, etagOrHeaders, responseType, callback) {\n        href = this._resolveUrl(href);\n        if (!href) {\n            return callback(new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + href));\n        }\n        \n        var result, requestDesc;\n        var headers = {};\n        if (typeof etagOrHeaders === 'string') {\n            headers[ifNoneMatchHeader] = etagOrHeaders;\n        } else {\n            merge(headers, etagOrHeaders);\n        }\n        function respHandler(error, response) {\n            if (error) {\n                return callback(networkError('Error downloading an asset', error, response));\n            }\n            if (response.statusCode === 200) {\n                callback(undefined, response);\n            } else {\n                if (response.statusCode === 304) {\n                    callback(undefined, response);\n                } else {\n                    callback(unexpectedResponse('Unexpected response getting an asset', error, response));\n                }\n            }\n        }\n        requestDesc = this._service.invoke('GET', href, headers, undefined, { responseType: responseType }, respHandler);\n        requestDesc.progress = dcxUtil.noOp;\n        return requestDesc;\n    };\n    \n    /**\n     * Gets a component from the server.\n     * NOTE that this does not specify an If-Match header. We want to get the component\n     * whether the etags match or not, for instance when we don't have the local file present.\n     * @param   {AdobeDCXComponent} component    The component to download.\n     * @param   {String}            responseType The expected data type of the response.\n     * @param   {Function}          callback     Callback \n     * @returns {Object}            the requestDescriptor for the request.\n     */\n    AdobeStorageSession.prototype.getComponent = function (component, responseType, callback) {\n        var href = this.getComponentHref(component, component.version);\n        return this.getAsset(href, undefined, responseType, callback);\n    };\n\n    /**\n    Get asset data in specified responseType result\n    \n    @return               the requestDescriptor for the request.\n    @param assetPath      the path of the asset.\n    @param responseType   desired response type\n    @param etagOrHeaders  if a string, the etag to use, if an object a set of additional headers, if undefined. ignored\n    @param callback       completion function. Signature: callback(error, buffer, etag, response);\n        the buffer is \"null\" if the etags match.\n    */\n    AdobeStorageSession.prototype.getAssetAsType = function (assetPath, responseType, etagOrHeaders, callback) {\n        var sink;\n        function onComplete(error, response) {\n            if (error) {\n                return callback(error);  // error is already wrapped\n            }\n            if (response.statusCode === 200) {\n                var buf = response.response || response.responseText;\n                callback(undefined, buf, response.headers.etag, response);\n            } else if (response.statusCode === 304) {\n                // null signals \"no change\"\n                callback(undefined, null, response.headers.etag, response);\n            } else {\n                callback(unexpectedResponse('Unexpected response getting asset', error, response));\n            }\n        }\n        return this.getAsset(assetPath, etagOrHeaders, responseType, onComplete);\n    };\n\n    /**\n     Get sync groups.\n     \n     @return         the requestDescriptor for this request\n     @param etag     the entity tags for this request\n     @param callback called on completion. Signature: callback(error, resultJson, etag)\n     */\n    AdobeStorageSession.prototype.getSyncGroups = function (etag, callback) {\n        var href = appendPathElements(this._server, 'assets');\n        return this.getCollection(href, etag, callback);\n    };\n    \n    /**\n     Get a sync group.\n     \n     @return          the requestDescriptor for this request\n     @param groupName\n     @param etag      the entity tags for this request\n     @param callback  called on completion. Signature: callback(error, resultJson, etag)\n     */\n    AdobeStorageSession.prototype.getSyncGroup = function (groupName, etag, callback) {\n        var href = appendPathElements(this._server, 'assets', groupName);\n        return this.getCollection(href, etag, callback);\n    };\n    \n    AdobeStorageSession.prototype.getCompositeManifest = function (composite, etag, callback) {\n        var href = composite.href;\n        if (href) {\n            href = this._resolveUrl(href);\n        }\n        if (href) {\n            href = appendPathElements(href, 'manifest');\n        } else {\n            return callback(new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + href));\n        }\n        return this.getAssetAsType(href, 'text', etag, callback);\n    };\n    \n    /**\n     Issue a simple HEAD request.\n     @return         the requestDesc\n     @param href     the URL\n     @param callback signature: callback(error, response)\n     */\n    AdobeStorageSession.prototype.headRequest = function (href, callback) {\n        return this._service.invoke('HEAD', href, {}, undefined, undefined, function (error, response) {\n            if (error) {\n                return callback(error);   // return raw error from http\n            }\n            callback(error, response);\n        });\n    };\n    \n    /**\n     Create a composite.\n     @param composite the composite.\n     @param overwrite whether to force an overwrite.\n     @param callback signature: callback(error, httpResponse)\n     */\n    AdobeStorageSession.prototype.createCompositeDirectory = function (composite, overwrite, callback) {\n        var self = this;\n        var compositeFullHref = this._resolveUrl(composite.href);\n        if (!compositeFullHref) {\n            return callback(new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + compositeFullHref));\n        }\n        function doCreateComposite(composite, overwrite, callback) {\n            var headers = {\n                    // See: https://sdk.ccstorage.adobe.io/sdks/ccstorage/v1/assets/put_syncgroup_resource_content\n                    'Content-Type': 'application/vnd.adobe.directory+json',\n                    'X-Update': 'content'\n                };\n            if (overwrite) {\n                headers[ifMatchHeader] = '*';\n            }\n            self._service.invoke('PUT', compositeFullHref, headers, undefined, undefined, function (error, response) {\n                if (error) {\n                    return callback(networkError('Error Creating composite directory', error, response));\n                }\n                if (response.statusCode === 409) {\n                    error = new AdobeDCXError(AdobeDCXError.ALREADY_EXISTS, error);\n                    error.response = response;\n                    return callback(error);\n                }\n                callback(undefined, response);\n            });\n        }\n        doCreateComposite(composite, overwrite, function (error, response) {\n            if (error) {\n                return callback(error); // error is already wrapped\n            }\n            var statusCode = response.statusCode;\n            if (statusCode === 200 || statusCode === 201) {\n                callback(undefined, response);\n            } else if (statusCode === 404) {\n                // Sync group doesn't exist yet, so try to create it\n                // Note: aborted requests don't produce responses\n                var groupHref = dcxUtil.parentDirectory(compositeFullHref);\n                self._service.invoke('PUT', groupHref, {}, undefined, undefined, function (error, response) {\n                    if (error) {\n                        return callback(networkError('Error creating composite directory', error, response));\n                    }\n                    var statusCode = response.statusCode;\n                    if (statusCode === 200 || statusCode === 201 || statusCode === 409) {\n                        // Now try creating composite again\n                        doCreateComposite(composite, overwrite, function (error, response) {\n                            if (error) {\n                                return callback(error);\n                            }\n                            var statusCode = response.statusCode;\n                            if (statusCode === 200 || statusCode === 201) {\n                                callback(undefined, response);\n                            } else {\n                                callback(networkError('Error creating composite directory', error, response));\n                            }\n                        });\n                    } else {\n                        callback(unexpectedResponse('Unexpected response creating composite directory', error, response));\n                    }\n                });\n            } else {\n                callback(unexpectedResponse('Unexpected response creating composite directory', error, response));\n            }\n        });\n    };\n    \n    /**\n     Delete a composite directory.\n     @param composite the cpmposite.\n     @callback signature: callback(error, response)\n     */\n    AdobeStorageSession.prototype.deleteCompositeDirectory = function (composite, callback) {\n        var self = this;\n        var href = this._resolveUrl(composite.href);\n        if (!href) {\n            return callback(new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + href));\n        }\n        var headers = {\n                'If-Match': '*'\n            };\n        href += '?recursive=true&invocation_mode=sync,async';\n        \n        var requestDesc = this._service.invoke('DELETE', href, headers, undefined, undefined, function (error, response) {\n            if (error) {\n                return callback(networkError('Error deleting composite directory', error, response));\n            }\n            var statusCode = response.statusCode;\n            if (statusCode === 200 || statusCode === 204 || statusCode === 404) {\n                return callback(undefined, response);\n            }\n            if (statusCode === 202) {\n                return self._handle202Response(response, requestDesc, self.SYNC_ASYNC_DEFAULT_DELAY, callback);\n            }\n            callback(unexpectedResponse('Unexpected response deleting composite directory', error, response));\n        });\n    };\n    \n    /**\n     Removes the shared composite from the user's view of assets on the server.\n     @param composite the cpmposite.\n     @callback signature: callback(error, response)\n     */\n    AdobeStorageSession.prototype.leaveSharedComposite = function (composite, callback) {\n        if (composite.collaborationType !== AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Composite\\'s collaboration type must be sharedWithUser.');\n        }\n        \n        // For now we just call delete composite but this implementation may diverge in the future\n        return this.deleteCompositeDirectory(composite, callback);\n    };\n\n    /**\n     Upload a component\n     @return              the requestDescriptor for this request.\n     @param component     the component\n     @param isNew         whether the component is new\n     @param isSharedComposite   whether the composite of the component is shared with this user\n     @param cancelToken   the cancelToken\n     @param data          the data to upload or, if a string, a filenams\n     @param callback      signature: callback(error, httpResponse, responseData)\n     */\n    AdobeStorageSession.prototype.uploadComponent = function (component, isNew, isSharedComposite,\n                                                               cancelToken, data, callback) {\n        if (!component._owner || !component._owner.compositeHref) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Component must be part of a branch of a bound composite.');\n        }\n        return this.uploadAssetForComponentId(component.id, component.type, component._owner.compositeHref,\n                                              isNew, isSharedComposite, cancelToken, data, callback);\n    };\n    \n\n    /**\n     Upload a component asset\n     @return                    the requestDescriptor for this request.\n     @param componentId         the id of the component\n     @param componentType       the content type of the component\n     @param compositeHref       the href of the composite\n     @param isNew               whether the component is new\n     @param isSharedComposite   whether the composite of the component is shared with this user\n     @param cancelToken         the cancelToken\n     @param data                the data to upload or, if a string, a filenams\n     @param callback            signature: callback(error, httpResponse, responseData)\n     */\n    AdobeStorageSession.prototype.uploadAssetForComponentId = function (componentId, componentType,\n                                                                         compositeHref, isNew,\n                                                                         isSharedComposite, cancelToken,\n                                                                         data, callback) {\n        var self = this;\n        // PUT of a component that exists on the server must have If-Match: '*' (or matching etag) and a component that doesn't exist\n        // mustn't have one. However we might be wrong! So we try the expected thing first and then the other.\n        var href = this._constructComponentHref(compositeHref, componentId);\n        if (isSharedComposite) {\n            // TODO: We need to implement a more robust way of adding query params to URLs. For now\n            // this (and the other occurrences of this pattern) works OK but as soon as we add more\n            // query params we will run into trouble.\n            href += '?intermediates=false';\n        }\n        var headers = {};\n        if (componentType) {\n            headers['Content-Type'] = componentType;\n        }\n        function doUpload(isNew, callback) {\n            if (isNew) {\n                delete headers[ifMatchHeader];\n            } else {\n                headers[ifMatchHeader] = '*';\n            }\n            var requestDesc = self._service.invoke('PUT', href, headers, data, undefined, function (error, response) {\n                if (error) {\n                    return callback(networkError('Error uploading component', error, response));\n                }\n                var statusCode = response.statusCode;\n                \n                if (statusCode === 200 || statusCode === 201 || statusCode === 204) {\n                    var responseData;\n\n                    try {\n                        responseData = JSON.parse(response.responseText || response.response);\n                    } catch (x) {\n                        error = new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Invalid JSON returned by server\", x);\n                        error.response = response;\n                        return callback(error, response, responseData);\n                    }\n                    callback(undefined, response, responseData);\n                } else if (statusCode === 507) {\n                    error = new AdobeDCXError(AdobeDCXError.EXCEEDS_QUOTA, \"Exceeds quota\", error);\n                    error.response = response;\n                    callback(error);\n                } else {\n                    error = unexpectedResponse('Unexpected response uploading component', error);\n                    error.response = response;\n                    callback(error);\n                }\n                \n            });\n            requestDesc.token = cancelToken;\n            return requestDesc;\n        }\n        var requestDesc = doUpload(isNew, function (error, response, responseData) {\n            if (error) {\n                response = error.response;\n                if (!response) {\n                    return callback(error);  // error is already wrapped\n                }\n                var statusCode = response.statusCode;\n                if (statusCode === 404 || statusCode === 409 || statusCode === 412) {\n                    // Our newness assumption turned out to be wrong, so try the other\n                    doUpload(!isNew, callback);\n                } else {\n                    callback(error);\n                }\n                return;\n            }\n            callback(undefined, response, responseData);\n        });\n        return requestDesc;\n    };\n\n    /**\n     Copy an existing server asset to a component (server-to-server copy)\n     @return              the requestDescriptor for this request.\n     @param componentId         the id of the component\n     @param compositeHref       the URI-encoded href of the composite\n     @param componentType       the content type of the component\n     @param isNew whether       the component is new\n     @param isSharedComposite   whether the composite of the component is shared with this user\n     @param cancelToken         the cancelToken\n     @param assetHref           the server href of the asset to copy (should include version info if appropriate)\n     @param callback            signature: callback(error, httpResponse, responseData)\n     */\n    AdobeStorageSession.prototype.copyAssetToComponentId = function (componentId, componentType, compositeHref, isNew, isSharedComposite,\n                                                                    cancelToken, assetHref, callback) {\n        var relativeAssetHref = this._makeRelativeUrl(assetHref);\n        if (!relativeAssetHref) {\n            return callback(new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Cannot copy asset: ' + assetHref));\n        }\n        \n        var self = this;\n        // PUT of a component that exists on the server must have If-Match: '*' (or matching etag) and a component that doesn't exist\n        // mustn't have one. However we might be wrong! So we try the expected thing first and then the other.\n        var href = this._constructComponentHref(compositeHref, componentId);\n        // Set the invocation mode (to signal that we properly respond to a 202 response) and the\n        // source query param\n        href = href + '?invocation_mode=sync,async';\n        if (isSharedComposite) {\n            // TODO: We need to implement a more robust way of adding query params to URLs. For now\n            // this (and the other occurrences of this pattern) works OK but as soon as we add more\n            // query params we will run into trouble.\n            href += '&intermediates=false';\n        }\n        \n        var headers = {};\n        if (componentType) {\n            headers['Content-Type'] = componentType;\n        }\n        // Set the link header to the asset to be copied\n        headers.Link = '<' + relativeAssetHref + '>;rel=source';\n        \n        // Issues the actual copy request and handles any asynchronous responses.\n        function doCopy(isNew, isRetry, callback) {\n            if (isNew) {\n                delete headers[ifMatchHeader];\n            } else {\n                headers[ifMatchHeader] = '*';\n            }\n            var requestDesc = self._service.invoke('PUT', href, headers, undefined, { responseType: 'text' }, function (error, response) {\n                if (error) {\n                    return callback(networkError('Error uploading component', error, response));\n                }\n                var statusCode = response.statusCode;\n                if (statusCode === 200 || statusCode === 201 || statusCode === 204) {\n                    callback(undefined, response, isRetry);\n                } else if (statusCode === 202) {\n                    // The server has determined that this request requires asynchronous processing.\n                    self._handle202Response(response, requestDesc, self.SYNC_ASYNC_DEFAULT_DELAY, function (error, respone) {\n                        callback(error, respone, isRetry);\n                    });\n                } else {\n                    callback(unexpectedResponse('Unexpected response copying a component asset', error, response), response, isRetry);\n                }\n                \n            });\n            requestDesc.token = cancelToken;\n            return requestDesc;\n        }\n        \n        var doCopyCallback = function (error, response, isRetry) {\n            var data;\n            if (error) {\n                response = error.response;\n                if (!response) {\n                    return callback(error);  // error is already wrapped\n                }\n                var statusCode = response.statusCode;\n                if (!isRetry && (statusCode === 404 || statusCode === 409 || statusCode === 412)) {\n                    // Our newness assumption turned out to be wrong, so try the other\n                    doCopy(!isNew, /*isRetry*/true, doCopyCallback);\n                } else if (statusCode === 507) {\n                    error = new AdobeDCXError(AdobeDCXError.EXCEEDS_QUOTA, \"Exceeds quota\", error);\n                    error.response = response;\n                    callback(error);\n                } else {\n                    callback(error);\n                }\n                return;\n            }\n            try {\n                data = JSON.parse(response.responseText || response.response);\n            } catch (x) {\n                error = new AdobeDCXError(AdobeDCXError.INVALID_DATA, \"Invalid JSON returned by server\", x);\n                error.response = response;\n                return callback(error);\n            }\n            callback(undefined, response, data);\n        };\n        \n        // TODO: Note that at this time the storage service does not support updating assets via s2s, so\n        // we set the isRetry param to true in order to prevent the code from retrying with\n        // with a different newness assumption. This needs to get changed when we get the update\n        // s2s support.\n        var requestDesc = doCopy(isNew, /*isRetry*/true, doCopyCallback);\n        return requestDesc;\n    };\n    \n    /**\n     Upload the manifest.\n     @return the requestDescriptor for this request.\n     @param branch the branch.\n     @param manifestData the data for the manifest.\n     @param overwrite whther to force an overwrite.\n     @param callback signature: callback(error, httpResponse)\n     */\n    AdobeStorageSession.prototype.updateManifest = function (branch, manifestData, overwrite, callback) {\n        var manifestHref = this.getBranchManifestHref(branch);\n        var headers = {\n            'Content-Type': adobeDCXManifestType\n        };\n        var etag = branch.manifestEtag;\n        if (overwrite) {\n            headers['If-Match'] = '*';\n        } else if (etag) {\n            headers['If-Match'] = etag;\n        }\n        var requestDesc = this._service.invoke('PUT', manifestHref, headers, manifestData, undefined, function (error, response) {\n            if (error) {\n                return callback(networkError('Error updating manifest', error, response));\n            }\n            var statusCode = response.statusCode;\n            if (response.headers.etag && (statusCode === 200 || statusCode === 201 || statusCode === 204)) {\n                callback(undefined, response);\n            } else if (statusCode === 412) {\n                error = new AdobeDCXError(AdobeDCXError.UPDATE_CONFLICT, \"Manifest has been changed\");\n                error.response = response;\n                callback(error);\n            } else {\n                callback(unexpectedResponse('Unexpected response updating manifest', error, response));\n            }\n        });\n        return requestDesc;\n    };\n    \n    /**\n    Gets the href for a composite, creating one if necessary.\n    @param composite the composite.\n    @param syncgroup the syncgroup mane\n    */\n    AdobeStorageSession.prototype.getHrefForComposite = function (composite, syncgroup) {\n        var type = composite.type;\n        if (!type) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Composite needs a type');\n        }\n        if (!composite.id) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Composite needs an id');\n        }\n        if (composite.href) {\n            return composite.href;\n        }\n        var href = this._resolveUrl(appendPathElements('assets', syncgroup, composite.id));\n        return href;\n    };\n\n    AdobeStorageSession.prototype.getCompositeManifestHref = function (composite) {\n        var href = this._resolveUrl(composite.href);\n        if (!href) {\n            throw new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + href);\n        }\n        return appendPathElements(href, \"manifest\");\n    };\n    \n    AdobeStorageSession.prototype.getBranchManifestHref = function (branch) {\n        var href = this._resolveUrl(branch.compositeHref);\n        if (!href) {\n            throw new AdobeDCXError(AdobeDCXError.WRONG_ENDPOINT, 'Wrong endpoint: ' + href);\n        }\n        return appendPathElements(href, \"manifest\");\n    };\n\n    AdobeStorageSession.prototype.getComponentHref = function (component, version) {\n        var owner = component._owner;\n        if (!owner || !owner.compositeHref) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Component must be part of a branch of a bound composite.');\n        }\n        return (owner._core && owner._core._getSourceHrefOfComponent(component)) ||\n            this._constructComponentHref(owner.compositeHref, component.id, version);\n    };\n    \n    //******************************************************************************\n    // Internal Methods\n    //******************************************************************************\n\n    AdobeStorageSession.prototype._constructComponentHref = function (compositeHref, componentId, componentVersion) {\n        var href = appendPathElements(this._resolveUrl(compositeHref), componentId);\n        if (href && typeof componentVersion !== 'undefined') {\n            href += ';version=' + componentVersion;\n        }\n        return href;\n    };\n    \n    \n    /**\n     * A _very_ naive URL resolver whose function is to prepend the a base to a relative URL\n     * or to simply return the href directly if it's absolute.\n     * Nothing is done about . or .. elements.\n     * @private\n     */\n    AdobeStorageSession.prototype._resolveUrl = function (href) {\n        var endPoint = dcxUtil.endPointOf(href);\n        \n        if (endPoint) {\n            // the href is an absolute URI so we need to ensure that it points to the right endpoint\n            if (endPoint !== this._endPoint) {\n                return undefined;\n            }\n            // href is absolute and host matches\n            return href;\n        }\n        \n        // the href is relative so we just append it to our base\n        return dcxUtil.appendPathElements(this._server, href);\n    };\n    \n    /**\n     * @private\n     * @param {[[Type]]} href [[Description]]\n     */\n    AdobeStorageSession.prototype._makeRelativeUrl = function (href) {\n        var endPoint = dcxUtil.endPointOf(href);\n        \n        if (endPoint) {\n            if (endPoint !== this._endPoint) {\n                return undefined;\n            }\n            \n            var uriItems = dcxUtil.parseURI(href);\n\n            if (uriItems.scheme || uriItems.authority) {\n\n                href = uriItems.path;\n                if (uriItems.query) {\n                    href += '?' + uriItems.query;\n                }\n                if (uriItems.fragment) {\n                    href += '#' + uriItems.fragment;\n                }\n            }\n        }\n        \n        return href;\n    };\n    \n    //******************************************************************************\n    // Internal Methods for Asynchronous Requests\n    //******************************************************************************\n\n    /**\n    Helper function to parse a response when polling for asynchronous results.\n    The body returned from these requests includes the response to the original request\n    including its own status code and headers.\n    \n    @notice This methods throws if it fails to parse at least the status code.\n    \n    @param asyncResponse The respone received from a successful (status code 200) poll request.\n    @return A fake response object with a statusCode and headers property set.\n    \n    @notice For now this methods drops the response body of the embedded response.\n    */\n    AdobeStorageSession.prototype._parseAsyncResponse = function (asyncResponse) {\n        var body = asyncResponse.responseText || asyncResponse.response;\n        if (!body) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'No body data.');\n        }\n        var response = {};\n\n        // We are not using split(CRLF) but rather use a combination of indexOf() and slice() calls to inspect\n        // the response line by line since the body of the response could be very big and we are only interested \n        // in the first few lines containing the status code and response headers.\n\n        // Get the first line (i.e. the status line)\n        var endOfLine = body.indexOf('\\n');\n        if (endOfLine === -1) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'Could not find status line.');\n        }\n        var line = body.slice(0, body.charCodeAt(endOfLine - 1) === 13 ? endOfLine - 1 : endOfLine);\n        var parts = line.split(' '); // The status line contains multiple elements separated by spaces\n        response.statusCode = parseInt(parts[1], 10); // The status code is the second element\n        if (!response.statusCode) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_DATA, 'Could not find status code.');\n        }\n        if (parts.length > 2) {\n            response.statusText = parts[2];\n        }\n        \n        // Now we extract the headers by removing the first line and chopping off the response body (if there is one)\n        var endOfHeaders = body.search(/\\r?\\n\\r?\\n/);\n        if (endOfHeaders === -1) {\n            endOfHeaders = body.length;\n        }\n        var allHeaders = body.slice(endOfLine + 1, endOfHeaders);\n        response.headers = dcxUtil.parseHeaders(allHeaders);\n        \n        // The remainder should be the response\n        var bodyStartsAt = body.charAt(endOfHeaders) === '\\r' ? endOfHeaders + 2 : endOfHeaders + 1;\n        response.response = body.slice(bodyStartsAt);\n\n        return response;\n    };\n        \n    /**\n    Issues and handles the responses to an async poll reuqest.\n    Calls itself recursively if it gets another 202 response.\n    \n    @param pollHref The href returned by the original 202 response.\n    @param pollFrequencyInSeconds Self explanatory.\n    @param requestDesc The request descriptor to reuse.\n    @param callback Gets called upon success or failure. Signature: function (error, response)\n    */\n    AdobeStorageSession.prototype._pollForAsyncResponse = function (pollHref, pollFrequencyInSeconds, requestDesc, callback) {\n        var self = this;\n        var when = Date.now() + (pollFrequencyInSeconds * 1000);\n        var options = { responseType: 'text',\n                        reuseRequestDesc: requestDesc,\n                        noSoonerThen: when\n                      };\n        requestDesc = this._service.invoke('GET', pollHref, undefined, undefined, options, function (error, response) {\n            if (error) {\n                return callback(networkError('Error polling for an asynchronous reponse', error, response));\n            }\n            var statusCode = response.statusCode;\n            if (statusCode === 202) {\n                // poll again\n                var retryAfter = response.headers['retry-after'];\n                if (retryAfter) {\n                    retryAfter = parseInt(retryAfter, 10);\n                }\n                self._pollForAsyncResponse(pollHref, retryAfter || self.DEFAULT_POLL_DELAY, requestDesc, callback);\n            } else if (statusCode === 200) {\n                // extract the status code and other headers from the response body and fake a response using the original reponse\n                try {\n                    response = self._parseAsyncResponse(response);\n                } catch (x) {\n                    return callback(unexpectedResponse('Error parsing response body.', x, response));\n                }\n                statusCode = response.statusCode;\n                if (statusCode === 200 || statusCode === 201 || statusCode === 204) {\n                    callback(undefined, response);\n                } else {\n                    callback(unexpectedResponse('Unexpected response copying a component asset', error, response));\n                }\n\n            } else {\n                callback(unexpectedResponse('Unexpected response polling for an asynchronous response', error, response));\n            }\n\n        });\n    };\n    \n        \n    /**\n    Handles a 202 response by scheduling a poll request reusing the same requestDesc.\n    \n    @param response The original 202 response.\n    @param requestDesc The request descriptor to reuse.\n    @param defaultSecondsToWaitForRetry Integer >= 0. If the reply doesn't contain a retry-after directive this is being used as the initial polling delay.\n    @param callback Gets called upon success or failure. Signature: function (error, response)\n    */\n    AdobeStorageSession.prototype._handle202Response = function (response, requestDesc, defaultSecondsToWaitForRetry, callback) {\n        var parsedResponse, responseText = response.responseText || response.response;\n        try {\n            parsedResponse = JSON.parse(responseText);\n        } catch (x) {\n            return callback(unexpectedResponse('Error parsing 202 response body.', x, response));\n        }\n        var pollHref = parsedResponse.href;\n        if (!pollHref) {\n            return callback(unexpectedResponse('202 response missing an href.', undefined, response));\n        }\n        var pollFrequencyInSeconds = response.headers['retry-after'];\n        if (pollFrequencyInSeconds) {\n            pollFrequencyInSeconds = parseInt(pollFrequencyInSeconds, 10);\n        } else {\n            pollFrequencyInSeconds = defaultSecondsToWaitForRetry;\n        }\n        this._pollForAsyncResponse(this._resolveUrl(pollHref), pollFrequencyInSeconds, requestDesc, callback);\n    };\n    \n    \n    return AdobeStorageSession;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, consol, Int8Array */\n\n/**\n* AdobeDCXCompositeXfer is a static class that implements methods for transfering DCX composites to\n* (push) and from (pull) the service.\n*\n* <p>You do not need to require() the class since a reference to it is available via your instance\n* of {@link module:AdobeDCX}.\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCXCompositeXfer\n*/\n\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('components/dcx-js/src/AdobeDCXCompositeXfer',['require','exports','module','./AdobeDCXComposite','./AdobeDCXComponent','./AdobeDCXBranch','./AdobeDCXError','./AdobeDCXPushJournal','./AdobeStorageSession','./AdobeDCXUtil','./AdobeDCXFS'],function (require, exports, module) {\n    'use strict';\n    \n    var AdobeDCXComposite = require('./AdobeDCXComposite');\n    var AdobeDCXComponent = require('./AdobeDCXComponent');\n    var AdobeDCXBranch = require('./AdobeDCXBranch');\n    var AdobeDCXError = require('./AdobeDCXError');\n    var AdobeDCXPushJournal = require('./AdobeDCXPushJournal');\n    var AdobeStorageSession = require('./AdobeStorageSession');\n    var dcxUtil = require('./AdobeDCXUtil');\n    var dcxFs = require('./AdobeDCXFS');\n    \n    var FileContent = AdobeStorageSession.FileContent;\n        \n    var STATES = AdobeDCXComponent.STATES;\n    var ALL_COMPONENTS = 'all';\n    var MINIMUM_COMPONENTS = 'min';\n    var NO_COMPONENTS = 'none';\n    \n    // forward declarations\n    var internalUploadComponent, internalCopyComponent;\n    \n    /**\n     * @private\n     * @param   {String} message  \n     * @param   {Error}  error    \n     * @param   {Object} response \n     * @returns {Error}  \n     */\n    function unexpectedResponse(message, error, response) {\n        return AdobeStorageSession.wrapError(AdobeDCXError.UNEXPECTED_RESPONSE, message, error, response);\n    }\n    \n    /**\n     * Callback for monitoring progress of the various transfer functions.\n     * @callback progressCallback\n     *    @param {Integer} bytesCompleted\n     *    @param {Integer} totalBytes\n     */\n       \n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    // XferContext\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    /**\n     * An XferContext object is returned when a transfer is initiated.\n     * Clients can use it to abort the transfer or register a progress handler with the context.\n     *\n     * @typedef {Object} XferContext\n     * @property {Integer}          [bytesTransfered]   The current number of bytes transfered.\n     * @property {Integer}          [bytesTotal]        The total number of bytes to transfer.\n     * @property {progressCallback} [onProgress]        Set this to a progressCallback function if you \n     *                                                  want to receives progress callbacks.\n     * @property {Array}            [failedComponents]  Upon failure this it is an array of\n     *                                                  { component: component, error: error } for\n     *                                                  each component that failed to down or upload.\n     * @property {Function}         [abort]             Call this to abort the transfer. Takes an optional\n     *                                                  error object as param. If given than the callback\n     *                                                  of the transfer will be called.\n     */\n    function XferContext(storageSession, callback, cleanup) {\n        \n        this._storageSession = storageSession;\n        this._callback = callback;\n        this._cleanup = cleanup;\n        \n        this._componentsPending = 0;\n        this.bytesTransfered = 0;\n        this.bytesTotal = 0;\n        this.onProgress = dcxUtil.noOp;\n        \n        var self = this;\n        this._reportProgress = function (incr) {\n            if (incr > 0) {\n                self.bytesTransfered += incr;\n                var progress = self.onProgress;\n                if (progress) {\n                    progress(self.bytesTransfered, self.bytesTotal);\n                }\n            }\n        };\n    }\n    \n    /**\n     * Call the client callback. Repeated calls will get ignored.\n     * @private\n     */\n    XferContext.prototype._callCallback = function (error, result) {\n        var callback = this._callback;\n        if (callback) {\n            this._callback = undefined;\n            callback(error, result);\n        }\n    };\n    \n    /**\n     * Called when the xfer has either succeeded or failed.\n     * @private\n     */\n    XferContext.prototype._xferComplete = function (error, result) {\n        var cleanup = this._cleanup;\n        if (cleanup) {\n            this._cleanup = undefined;\n            cleanup(error, result); // cleanup must call callback\n        } else {\n            // No cleanup: call client callback directly\n            this._callCallback(error, result);\n        }\n    };\n    \n    /**\n     * Abort the transfer\n     * @param {Error} [error] If not undefined then the callback for the xfer gets\n     *                        invoked and passed this as the first (error) argument.\n     */\n    XferContext.prototype.abort = function (error) {\n        if (!this._aborted) {\n            this._aborted = true;\n            this._storageSession._service.abortAllWithToken(this);\n        }\n        if (!error) {\n            // No error provided: undefine client callback so that it doesn't get called and\n            // create a generic error so that our logic knows that the operation has failed.\n            this._callback = undefined;\n            error = new Error('Aborted'); // Create a generic error\n        }\n        this._xferComplete(error);\n    };\n    \n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    // Public Transfer APIs\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    /**\n     * Callback function used for operations that return a branch.\n     * @callback branchCallback\n     *    @param {Error}           error\n     *    @param {AdobeDCXBranch}  branch\n     */\n    \n    /**\n     * Callback function used for operations that don't return anything other than a potential error.\n     * @callback errorCallback\n     *    @param {Error}           error\n     */\n    \n    /**\n    \n     * Callback function used for operations that upload or copy components.\n     * @callback uploadCallback\n     *    @param {Error}   error\n     *    @param {Object}  uploadResults\n     */\n        \n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Initiate a pull of a complete composite. Downloads the necessary files and stores them locally</p>\n     * \n     * <p>Notice that in the case of an error returned to the callback function that error might \n     * represent multiple errors since components are downloaded in parallel and each download might\n     * fail individually. Clients can get to per-component error information by checking the\n     * failedComponents property on the error object. If set it will contain an array with one\n     * object per failed component download. Each component failure object has two properties:\n     * component and error.</p>\n     *\n     * @param   {AdobeDCXComposite}   composite      The composite to pull.\n     * @param   {AdobeStorageSession} storageSession The storage session.\n     * @param   {branchCallback}      callback       Gets called upon completion.\n     * @returns {XferContext}                        A context that can be used to monitor progress\n     *                                               or abort the pull.\n     */\n    exports.pullComposite = function (composite, storageSession, callback) {\n        if (!composite.hasLocalStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'No local storage. Use AdobeDCXCompositeXfer.pullCompositeManifestOnly() to pull down the composite without local storage.');\n        }\n        return this._pullComposite(composite, storageSession, ALL_COMPONENTS, callback);\n    };\n\n    /**\n     * <strong>NJS-only</strong>\n     *\n     * <p>Initiate a minimum pull of a composite.\n     * Only the smallest set of required components are downloaded.</p>\n     * \n     * <p>Notice that in the case of an error returned to the callback function that error might \n     * represent multiple errors since components are downloaded in parallel and each download might\n     * fail individually. Clients can get to per-component error information by checking the\n     * failedComponents property on the error object. If set it will contain an array with one\n     * object per failed component download. Each component failure object has two properties:\n     * component and error.</p>\n     *\n     * @param   {AdobeDCXComposite}   composite      The composite to pull.\n     * @param   {AdobeStorageSession} storageSession The session to use.\n     * @param   {branchCallback}      callback       Gets called upon completion.\n     * @returns {XferContext}                        A context that can be used to monitor progress\n     *                                               or abort the pull.\n     */\n    exports.pullMinimumComposite = function (composite, storageSession, callback) {\n        if (!composite.hasLocalStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'No local storage. Use AdobeDCXCompositeXfer.pullCompositeManifestOnly() to pull down the composite without local storage.');\n        }\n        return this._pullComposite(composite, storageSession, MINIMUM_COMPONENTS, callback);\n    };\n\n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Create a pull branch with just the manifest updated.</p>\n     * @param   {AdobeDCXComposite}   composite      The composite to pull.\n     * @param   {AdobeStorageSession} storageSession The session to use.\n     * @param   {branchCallback}      callback       Gets called upon completion.\n     * @returns {XferContext}                        A context that can be used to monitor progress\n     *                                               or abort the pull.\n     */\n    exports.pullCompositeManifestOnly = function (composite, storageSession, callback) {\n        return this._pullComposite(composite, storageSession, NO_COMPONENTS, callback);\n    };\n    \n    /**\n     * <strong>NJS-only</strong>\n     * \n     * <p>Downloads the files of the given list of components. Skips any components whose file\n     * in local storage is up to date.</p>\n     * \n     * <p>Notice that in the case of an error returned to the callback function that error might \n     * represent multiple errors since components are downloaded in parallel and each download might\n     * fail individually. Clients can get to per-component error information by checking the\n     * failedComponents property on the error object. If set it will contain an array with one\n     * object per failed component download. Each component failure object has two properties:\n     * component and error.</p>\n     * \n     * @param {Array}                          components      The list of components to download.\n     *                                                         Pass undefined to download all missing\n     *                                                         or updated components.\n     * @param {AdobeDCXBranch|AdobeDCXElement} branchOrElement The branch or element to download the \n     *                                                         components for.\n     * @param {AdobeStorageSession}            storageSession  The storage session to use.\n     * @param {branchCallback}                 callback        Gets called when all the downloads\n     *                                                         have completed or failed.\n     * @returns {XferContext}                  A context that can be used to monitor progress\n     *                                                           or abort the pull.\n     */\n    exports.downloadComponents = function (components, branchOrElement, storageSession, callback) {\n        function getBranchOf(item) {\n            return item._owner ? getBranchOf(item._owner) : item;\n        }\n        var branch = getBranchOf(branchOrElement);\n        var pullContext = new XferContext(storageSession, callback);\n        pullContext._referenceBranch = branch;\n        \n        exports._pullComponents(pullContext, branch, components || branchOrElement.allComponents());\n        \n        return pullContext;\n    };\n    \n    /**\n     * Push the composite.\n     * \n     * <p>Notice that in the case of an error returned to the callback function that error might \n     * represent multiple errors since components are uploaded in parallel and each upload might\n     * fail individually. Clients can get to per-component error information by checking the\n     * failedComponents property on the error object. If set it will contain an array with one\n     * object per failed component upload. Each component failure object has two properties:\n     * component and error.</p>\n     *\n     * @param   {AdobeDCXComposite}   composite         The composite.\n     * @param   {Boolean}             overwriteExisting Whether to overwrite an existing composite.\n     *                                                  Only set this to true for an unbound composite\n     *                                                  if a previous push has failed with an \n     *                                                  INVALID_STATE error indicating that there is\n     *                                                  already a composite with the same id <em>and</em>\n     *                                                  if you are sure that you want to overwrite it.\n     * @param   {AdobeStorageSession} storageSession    The storage session to use.\n     * @param   {errorCallback}       callback          Gets called upon completion.\n     * @returns {XferContext}                           A context that can be used to monitor and/or\n     *                                                  abort the push.    \n     */\n    exports.pushComposite = function (composite, overwriteExisting, storageSession, callback) {\n        var pushContext, localStorage = composite._localStorage;\n        \n        // Bottleneck to ensure that we clean up properly before calling the callback. Gets called\n        // from the pushContext object.\n        var cleanup = function (error, branch) {\n            if (pushContext._owner && composite.hasLocalStorage) {\n                localStorage.unregisterInMemoryBranchOrElement(pushContext._owner);\n            }\n            if (!composite.hasLocalStorage) {\n                var journal = pushContext._journal;\n                composite._pushJournal = journal.isEmpty ? undefined : journal;\n            }\n            pushContext._callCallback(error, branch);\n        };\n        \n        pushContext = new XferContext(storageSession, callback, cleanup);\n        pushContext._composite = composite;\n        pushContext._overwriteExisting = overwriteExisting;\n        var compositeIsNew = !composite.isBound;\n        pushContext._compositeIsNew = compositeIsNew;\n        \n        if (composite.hasLocalStorage) {\n            // We need to load current branch as well as the push journal\n            composite._loadBranch(localStorage.currentManifestPath(), false, function (error, branch) {\n                if (error) {\n                    return pushContext._xferComplete(error);\n                }\n                pushContext._owner = branch;\n                composite._localStorage.registerInMemoryBranchOrElement(branch);\n                \n                AdobeDCXPushJournal.readJournal(localStorage.pushJournalPath(), composite, /*createIfNecessary*/true, function (error, journal) {\n                    if (error) {\n                        return pushContext._xferComplete(error);\n                    }\n                    pushContext._journal = journal;\n                    \n                    exports._pushComposite(composite, pushContext);\n                });\n            });\n        } else {\n            // No local storage. Make an in-memory copy of the current branch and get the push journal.\n            var href = composite.href;\n            if (!href) {\n                return pushContext._xferComplete(new AdobeDCXError(AdobeDCXError.INVALID_STATE, \"New composite has no href\"));\n            }\n            \n            pushContext._owner = composite.current.copy();\n            \n            pushContext._journal = composite._pushJournal || new AdobeDCXPushJournal(composite);\n            \n            exports._pushComposite(composite, pushContext);\n        }\n\n        return pushContext;\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Uploads the given data as the asset for a new component in the current branch of the given \n     * composite. Does not add the component in the composite branch. Instead it returns \n     * (via the callback) an object containing the upload results which then can be used to\n     * add the component to the branch.</p>\n     *\n     * @param   {Buffer}                 data           The data buffer to upload.\n     * @param   {String}                 type           The content type of the component.\n     * @param   {AdobeDCXComposite}      composite      The composite to add the new component asset to.\n     * @param   {String}                 [componentId]  The id to use for the new component. Must be \n     *                                                  unique within the composite. If not provided \n     *                                                  the component will get assigned a random uuid.\n     * @param   {AdobeStorageSession}    storageSession The StorageSession to use for the upload.\n     * @param   {uploadCallback}         callback       Gets called when adding the component has either \n     *                                                  succeeded or failed.\n     * @returns {XferContext}                           A context that can be used to monitor and/or\n     *                                                  abort the upload.  \n     */\n    exports.uploadNewComponent = function (data, type, composite, componentId, storageSession, callback) {\n        // Check preconditions\n        if (composite._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'For in-browser use only. Use composite.current.addComponent() to add a new component asset');\n        }\n        \n        return internalUploadComponent(componentId || dcxUtil.generateUuid(), type, /*isNew*/ true,\n                                       composite.collaborationType === AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER,\n                                       data, composite.id, composite.href, storageSession, callback);\n    };\n    \n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Uploads the given data as the new asset for the given component. Does not update the \n     * component in the composite branch. Instead it returns (via the callback) an object \n     * containing the upload results which then can be used to update the component in the branch.</p>\n     *\n     * @param   {AdobeDCXComponent}   component      The component to upload the new asset for.\n     * @param   {Buffer}              data           The data buffer to upload.\n     * @param   {AdobeDCXComposite}   composite      The composite of the component.\n     * @param   {AdobeStorageSession} storageSession The StorageSession to use for the upload.\n     * @param   {uploadCallback}      callback       Gets called when adding the component has either \n     *                                               succeeded or failed.\n     * @returns {XferContext}                        A context that can be used to monitor and/or\n     *                                               abort the upload.  \n     */\n    exports.uploadComponent = function (component, data, composite, storageSession, callback) {\n        if (composite._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'For in-browser use only. Use composite.current.updateComponent() to update a component asset');\n        }\n        \n        return internalUploadComponent(component.id, component.type, /*isNew*/ false,\n                                       composite.collaborationType === AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER,\n                                        data, composite.id, composite.href, storageSession, callback);\n    };\n    \n    /**\n     * <strong>XHR-only</strong>\n     *\n     * <p>Copies the asset at the given href as the asset for a new component in the current branch of the given \n     * composite. Does not add the component in the composite branch. Instead it returns \n     * (via the callback) an object containing the copy results which then can be used to\n     * add the component to the branch.</p>\n     *\n     * @param   {String}                 assetHref      The href of the asset to copy\n     * @param   {String}                 type           The content type of the component.\n     * @param   {AdobeDCXComposite}      composite      The composite to add the new component asset to.\n     * @param   {String}                 [componentId]  The id to use for the new component. Must be \n     *                                                  unique within the composite. If not provided \n     *                                                  the component will get assigned a random uuid.\n     * @param   {AdobeStorageSession}    storageSession The StorageSession to use for the copy.\n     * @param   {uploadCallback}         callback       Gets called when copying the asset has either \n     *                                                  succeeded or failed.\n     * @returns {XferContext}                           A context that can be used to monitor and/or\n     *                                                  abort the copy.  \n     */\n    exports.copyAssetForNewComponent = function (assetHref, type, composite, componentId, storageSession, callback) {\n        // Check preconditions\n        if (composite._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'For in-browser use only. Use composite.current.addComponent() to add a new component asset');\n        }\n        \n        return internalCopyComponent(componentId || dcxUtil.generateUuid(), type, /*isNew*/ true,\n                                       composite.collaborationType === AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER,\n                                       assetHref, composite.id, composite.href, storageSession, callback);\n    };\n    \n    \n    /**\n     * <strong>XHR-only</strong>\n     * \n     * Returns a URL that points to the correct version of the component asset on the server.\n     * @param   {AdobeDCXComponent}   component      The existing component. Must be part of a \n     *                                               composite branch.\n     * @param   {AdobeStorageSession} storageSession The StorageSession to use.\n     * @returns {String}              The URL for this specific version of the component.\n     */\n    exports.getURLForComponent = function (component, storageSession) {\n        // Check preconditions\n        if (component._owner._localStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'For in-browser use only.');\n        }\n        return storageSession.getComponentHref(component, component.version);\n    };\n    \n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    // Pull - Internal\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    /**\n     * @private\n     */\n    exports._pullComposite = function (composite, storageSession, componentsToDownload, callback) {\n        \n        if (typeof composite.href !== 'string') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Composite must have an href');\n        }\n        var pullContext;\n        \n        // This function get called once the pull has either succeeded or failed. Cleans up and\n        // calls the client callback.\n        function finalizePull(error, branch) {\n            if (error) {\n                var pulledBranch = error.pulledBranch;\n                if (pulledBranch) {\n                    // If there's a pulled branch, save it even though this is only a partial success,\n                    // otherwise the storage mapping is lost for any components we did pull.\n                    pulledBranch.compositeState = STATES.unmodified;\n                    if (pulledBranch.hasLocalStorage) {\n                        dcxFs.writeFileAtomically(composite._localStorage.pulledManifestPath(), error.pulledBranch.localData, 'utf8', function (saveError) {\n                            // report the original error even if the save fails.\n                            pullContext._callCallback(error);\n                        });\n                    } else {\n                        pullContext._callCallback(error);\n                    }\n                } else {\n                    pullContext._callCallback(error);\n                }\n                return;\n            }\n            if (branch === null) {\n                // The composite on the server has no changes\n                return pullContext._callCallback(undefined, null);\n            }\n            // Various accessors will mark an unmodified manifest modified but even if the manifest\n            // comes to us marked as \"modified\" on the server, we want to treat it as unmodified.\n            branch.compositeState = STATES.unmodified;\n            // And, finally, save the pulled manifest\n            if (branch.hasLocalStorage) {\n                dcxFs.writeFileAtomically(composite._localStorage.pulledManifestPath(), branch.localData, 'utf8', function (error) {\n                    if (error) {\n                        return pullContext._callCallback(error);\n                    }\n                    branch._isDirty = false;\n                    pullContext._callCallback(undefined, branch);\n                });\n            } else {\n                if (composite._options.xhrBaseBranchSupport) {\n                    // make a copy of the pushed manifest data so that it can be used for a base branch\n                    composite._pulledBranchData = branch.localData;\n                }\n                pullContext._callCallback(undefined, branch);\n            }\n        }\n        \n        // Gets called after loading the branch (if local storage is available) or just with the current branch of the composite\n        var branchLoaded = function (error, existingPulledBranch) {\n            if (error) {\n                return pullContext._xferComplete(error);\n            }\n            var etag;\n            if (existingPulledBranch) {\n                etag = existingPulledBranch.manifestEtag;\n                pullContext._referenceBranch = existingPulledBranch;\n            } else if (composite.current) {\n                etag = composite.current.manifestEtag;\n                pullContext._referenceBranch = composite.current;\n            }\n            \n            // Now, using the etags from the stored or current manifest, if any, try to pull from the server\n            var req = storageSession.getCompositeManifest(composite, etag, function (error, manifestData, etag) {\n                if (error) {\n                    if (error.response && error.response.statusCode === 404) {\n                        return pullContext._xferComplete(new AdobeDCXError(AdobeDCXError.NO_COMPOSITE,\n                                                                           \"Composite missing or deleted\",\n                                                                           error.underlyingError || error));\n                    }\n                    return pullContext._xferComplete(error);\n                }\n                if (manifestData === null && !existingPulledBranch) {\n                    // This implies we had an etags match and there is nothing to pull\n                    return pullContext._xferComplete(undefined, null);\n                }\n                var branch;\n                if (manifestData) {\n                    try {\n                        branch = new AdobeDCXBranch().parse(manifestData);\n                        branch._localStorage = composite._localStorage;\n                        branch.compositeHref = composite.href;\n                        branch._collaborationType = composite.collaborationType;\n                        branch.manifestEtag = etag;\n                        if (branch.compositeState === STATES.committedDelete || branch.compositeState === STATES.pendingDelete) {\n                            // Finish the job!\n                            // Note that a composite on the server should never be marked pendingDelete, but if one is then clearly\n                            // somebody wanted it gone.\n                            pullContext._storageSession.deleteCompositeDirectory(composite, function (error) {\n                                if (error) {\n                                    return pullContext._xferComplete(new AdobeDCXError(AdobeDCXError.DELETED_COMPOSITE,\n                                                                                       \"Error deleting composite directory\", error));\n                                }\n                                return pullContext._xferComplete(new AdobeDCXError(AdobeDCXError.DELETED_COMPOSITE, \"Composite is deleted\"));\n                            });\n                        }\n                        if (pullContext._referenceBranch && branch.hasLocalStorage) {\n                            branch._updateLocalDataFromBranch(pullContext._referenceBranch);\n                        }\n                    } catch (e) {\n                        return pullContext._xferComplete(new AdobeDCXError(AdobeDCXError.INVALID_JSON, \"Corrupted manifest\", e));\n                    }\n                } else {\n                    // We got a 304 but we had previously pulled a manifest that we never resolved.\n                    branch = existingPulledBranch;\n                }\n                // clean up deleted and modified components\n                var i, component, components = branch.allComponents();\n                for (i = 0; i < components.length; ++i) {\n                    component = components[i];\n                    if (component.state === STATES.pendingDelete || component.state === STATES.committedDelete) {\n                        // Get rid of any deleted components\n                        branch.removeComponent(component);\n                    } else {\n                        component.state = STATES.unmodified;\n                    }\n                }\n                components = undefined;\n\n                if (componentsToDownload === ALL_COMPONENTS) {\n                    components = branch.allComponents();\n                } else if (componentsToDownload === MINIMUM_COMPONENTS) {\n                    component = branch.getComponentWithAbsolutePath('/META-INF/metadata.xml');\n                    if (component) {\n                        components = [component];\n                    }\n                }\n\n                if (components) {\n                    exports._pullComponents(pullContext, branch, components);\n                } else {\n                    // We are done\n                    pullContext._xferComplete(undefined, branch);\n                }\n            });\n            if (req) {\n                req.token = pullContext; // for aborting\n                req.progress = pullContext._reportProgress;\n            }\n        };\n        \n        // Create the pull context that the client can use to trakc progress and/or abort the pull\n        pullContext = new XferContext(storageSession, callback, finalizePull);\n        pullContext._composite = composite;\n        \n        if (composite.hasLocalStorage) {\n            // First try loading the pulled branch from disk\n            composite.loadPulledBranch(branchLoaded);\n        } else {\n            // Nothing to load\n            branchLoaded();\n        }\n        \n        return pullContext;\n    };\n    \n    /**\n     * @private\n     */\n    exports._pullComponents = function (pullContext, pulledBranch, components) {\n        if (!pulledBranch.hasLocalStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'No local storage.');\n        }\n        var storageSession = pullContext._storageSession;\n        \n        // Gets called once per component that is accounted for in pullContext._componentsPending.\n        // Records errors and -- once pullContext._componentsPending hits 0 -- calls the callback.\n        function componentDone(error, component) {\n            pullContext._componentsPending -= 1;\n            if (error) {\n                // Record the error in the pullContext and continue\n                pullContext.failedComponents = pullContext.failedComponents || [];\n                pullContext.failedComponents.push({ component: component, error: error });\n            }\n            if (pullContext._componentsPending === 0 && !pullContext._aborted) {\n                var failedComponents = pullContext.failedComponents;\n                if (failedComponents) {\n                    error = new AdobeDCXError(AdobeDCXError.COMPONENT_DOWNLOAD_ERROR, \"Failed to download all components\");\n                    // See whether we have an out of disk space error somewhere and report that instead of\n                    // the generic error code above\n                    var i, c = failedComponents.length;\n                    for (i = 0; i < c; i++) {\n                        var componentError = failedComponents[i].error;\n                        if (componentError.code === AdobeDCXError.OUT_OF_SPACE) {\n                            error = new AdobeDCXError(componentError.code, componentError.message);\n                            break;\n                        }\n                    }\n                    error.pulledBranch = pulledBranch;\n                    error.failedComponents = failedComponents;\n                    return pullContext._xferComplete(error);\n                }\n                // Success!\n                pullContext._xferComplete(undefined, pulledBranch);\n            }\n        }\n        // Gets called for each component that we need to download.\n        function doLoadComponent(component) {\n            if (pullContext._aborted) {\n                return;\n            }\n            pullContext.bytesTotal += (component.length || 0);\n            var localStorage = component._owner._localStorage;\n            var filePath = localStorage.tempPathForComponent(component);\n            var parentDir = dcxUtil.parentDirectory(filePath);\n            dcxFs.ensureDirectoryExists(parentDir, function (error) {\n                if (error) {\n                    return pullContext.abort(error);\n                }\n                var res = exports._pullComponent(component, filePath, storageSession, componentDone);\n                res.progress = pullContext._reportProgress;\n                res.token = pullContext; // for aborting\n            });\n        }\n        // Gets called for each component that hasn't been modified. Figures out whether its file\n        // exists locally and calls doLoadComponent() if not. Otherwise it calls componentDone().\n        function loadIfNoLocalAsset(component) {\n            // This function exists to bind the component as a stable value.\n            // If this were inlined below, 'component' would change as the loop iterates.\n            pulledBranch.assetOfComponent(component, function (error, path) {\n                if (typeof path !== 'string') {\n                    // It's important that we load the component wheter the etags match or not. See pullComponent.\n                    doLoadComponent(component);\n                } else {\n                    componentDone(undefined, component);\n                }\n            });\n        }\n        \n        // We iterate over all components and call either doLoadComponent (if it has been modfied)\n        // or loadIfNoLocalAsset (if not)\n        var i;\n        pullContext._componentsPending = components.length;\n        for (i = 0; i < components.length; ++i) {\n            var component = components[i];\n            var etag;\n            // Deleted and modified components were already cleaned up when the manifest was pulled.\n            if (pullContext._referenceBranch) {\n                var refComponent = pullContext._referenceBranch.getComponentWithId(component.id);\n                if (refComponent) {\n                    etag = refComponent.etag;\n                }\n            }\n            if (component.etag !== etag) {\n                doLoadComponent(component);\n            } else {\n                loadIfNoLocalAsset(component);\n            }\n        }\n        if (pullContext._componentsPending === 0) {\n            // Must call callback since we do not have any component.\n            pullContext._xferComplete(undefined, pulledBranch);\n        }\n    };\n    \n    /**\n     * Initiate a pull of a component.\n     * This pulls the component whether the etags match or not. For instance we may be pulling\n     * because we don't have a local file cached.\n     * @private\n     */\n    exports._pullComponent = function (component, filePath, storageSession, callback) {\n        var owner = component._owner;\n        if (!component._owner.hasLocalStorage) {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'No local storage. Use AdobeDCXCompositeXfer.pullCompositeManifestOnly() to pull down the composite without local storage.');\n        }\n        \n        var req = storageSession.getComponent(component, new FileContent(filePath), function (error, response) {\n            if (error) {\n                // TODO: distinguish between failures that might be temporary (e.g. server down)\n                // vs. those that indicate that there is something wrong with the composite.\n                callback(error, component);\n            } else if (response.statusCode === 200) {\n                // TODO: check the actual received data length\n                if (component.length !== undefined && component.length !== null && Number(response.headers['content-length']) !== component.length) {\n                    callback(new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"Incorrect content length\", error, response));\n                } else {\n                    // Success\n                    owner._localStorage.ingestComponentAsset(component, filePath, /*copy*/ false, owner._local(), function (error) {\n                        callback(error, component, response.headers.etag);\n                    });\n                }\n            } else if (response.statusCode === 304) {\n                // This is success too\n                callback(undefined, component, response.headers.etag);\n            } else {\n                // Unexpected response\n                callback(unexpectedResponse('Unexpected response getting a component', error, response), component);\n            }\n        });\n        return req;\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    // Push - Internal\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    // Creates the composite directory for new composites and ensures that we only try it once.\n    /**\n     * @private\n     * @param   {Object}              composite         \n     * @param   {Object}              journal           \n     * @param   {Boolean}             overwriteExisting \n     * @param   {AdobeStorageSession} session           \n     * @param   {Function}            callback          \n     */\n    function createCompositeDirectoryIfNecessary(composite, journal, overwriteExisting, session, callback) {\n        function doneWithError(error) {\n            if (!error) {\n                journal.compositeHasBeenCreated = true;\n            }\n            var callbacks = journal._compositeCreationCallbacks;\n            var i, c = callbacks.length;\n            for (i = 0; i < c; i++) {\n                try {\n                    callbacks[i](error);\n                } catch (x) {\n                    // nothing to do\n                }\n            }\n            journal._compositeCreationCallbacks = undefined;\n            return;\n        }\n        \n        if (!composite.isBound && !journal.compositeHasBeenCreated) {\n            if (journal._compositeCreationCallbacks) {\n                journal._compositeCreationCallbacks.push(callback);\n            } else {\n                journal._compositeCreationCallbacks = [ callback ];\n                \n                session.createCompositeDirectory(composite, overwriteExisting, function (error, response) {\n                    if (error) {\n                        if (error.code !== AdobeDCXError.ALREADY_EXISTS) {\n                            return doneWithError(unexpectedResponse('Unexpected response creating a composite directory', error, response));\n                        }\n                        if (!overwriteExisting) {\n                            // Check to see if there's a manifest already. If not, we'll continue\n                            var manifestHref = session.getCompositeManifestHref(composite);\n                            session.headRequest(manifestHref, function (error, response) {\n                                if (error) {\n                                    return doneWithError(error);\n                                }\n                                if (response.statusCode !== 404) {\n                                    error = new AdobeDCXError(AdobeDCXError.INVALID_STATE, \"Composite already exists and overwriteExisting not specified\");\n                                    return doneWithError(error);\n                                }\n                                doneWithError();\n                            });\n                        } else {\n                            doneWithError();\n                        }\n                    } else {\n                        doneWithError();\n                    }\n                });\n            }\n        } else {\n            // No need to create the composite directory\n            callback();\n        }\n    }\n    \n    \n    /**\n     * @private\n     * @param   {Object}   composite   \n     * @param   {Object}   pushContext \n     */\n    exports._pushComposite = function (composite, pushContext) {\n        var href = composite.href;\n        if (!href) {\n            return pushContext._xferComplete(new AdobeDCXError(AdobeDCXError.INVALID_STATE, \"New composite has no href\"));\n        }\n        var branch = pushContext._owner;\n        var journal = pushContext._journal;\n        var compositeIsNew = pushContext._compositeIsNew;\n        var overwriteExisting = pushContext._overwriteExisting;\n        var storageSession = pushContext._storageSession;\n        \n        var originalChangeCount = branch.changeCount;\n        var manifestSizeEstimate = branch.remoteData.length + 50;  // some fudge here\n        pushContext.bytesTotal = manifestSizeEstimate;  // approximate size of eventual manifest\n        if (branch.compositeState === STATES.committedDelete) {\n            return pushContext._xferComplete(new AdobeDCXError(AdobeDCXError.DELETED_COMPOSITE, 'Attempt to push a deleted composite'));\n        }\n        if (!compositeIsNew && branch.compositeState === STATES.unmodified) {\n            // There's nothing to do, so succeed with no pull branch (null)\n            return pushContext._xferComplete();\n        }\n        if (branch.compositeState === STATES.pendingDelete) {\n            // It's OK to try to delete an unbound composite. This\n            // lets us delete a composite if all we know about it is the ID.\n            // But just to be safe, insist that users specify 'overwriteExisting'.\n            if (compositeIsNew && !overwriteExisting) {\n                return pushContext._xferComplete(new AdobeDCXError(AdobeDCXError.DELETED_COMPOSITE, 'Attempt to delete unbound composite'));\n            }\n            if (composite.collaborationType === AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER) {\n                return pushContext._xferComplete(new AdobeDCXError(AdobeDCXError.INVALID_STATE, 'Attempt to delete composite that is shared with this user.'));\n            }\n            return exports._deleteComposite(pushContext, overwriteExisting, function (error, result) {\n                pushContext._xferComplete(error, result);\n            });\n        }\n\n        function reportFailureCheckingForDeletedManifest(error) {\n            // Errors pushing to deleted composites can be very messy and can look like\n            // other kinds of things. So here we check to see if there's a manifest.\n            // If not, then we call it a NO_COMPOSITE error. Otherwise just pass it along.\n            if (compositeIsNew) {\n                return pushContext._xferComplete(error);\n            }\n            var manifestHref = storageSession.getCompositeManifestHref(composite);\n            storageSession.headRequest(manifestHref, function (headRequestError, response) {\n                if (headRequestError) {\n                    return pushContext._xferComplete(headRequestError);\n                }\n                if (response.statusCode === 404) {\n                    error = new AdobeDCXError(AdobeDCXError.NO_COMPOSITE, \"Composite does not exist; may have been deleted\");\n                    return pushContext._xferComplete(error);\n                }\n                return pushContext._xferComplete(error);\n            });\n        }\n\n        createCompositeDirectoryIfNecessary(composite, journal, overwriteExisting, storageSession, function (error) {\n            if (error) {\n                return pushContext._xferComplete(error);\n            }\n            exports._pushComponents(pushContext, branch, function () {\n                var failedComponents = pushContext.failedComponents;\n                if (failedComponents) {\n                    error = new AdobeDCXError(AdobeDCXError.COMPONENT_UPLOAD_ERROR, \"One or more components failed to upload.\");\n                    // See whether we have an out of quota error somewhere and report that instead of\n                    // the generic error code above\n                    var i, c = failedComponents.length;\n                    for (i = 0; i < c; i++) {\n                        var componentError = failedComponents[i].error;\n                        if (componentError.code === AdobeDCXError.EXCEEDS_QUOTA) {\n                            error = new AdobeDCXError(componentError.code, componentError.message);\n                            break;\n                        }\n                    }\n                    error.failedComponents = failedComponents;\n                    return reportFailureCheckingForDeletedManifest(error);\n                }\n                //\n                // Now push the manifest\n                //\n                branch.compositeState = STATES.unmodified;\n                var manifestData = branch.remoteData;\n                // Correct the size estimate\n                pushContext.bytesTotal += manifestData.length;\n                pushContext.bytesTotal -= manifestSizeEstimate;\n\n                var requestDesc = storageSession.updateManifest(branch, manifestData, overwriteExisting, function (error, response) {\n                    if (error) {\n                        return reportFailureCheckingForDeletedManifest(error);\n                    }\n                    var etag = response.headers.etag;\n                    journal.manifestEtag = etag;\n                    journal.changeCount = originalChangeCount;\n                    journal.commitChanges(function (error) {\n                        if (error) {\n                            return pushContext._xferComplete(error);\n                        }\n                        journal.applyToBranch(branch);\n                        branch.compositeState = STATES.unmodified;\n\n                        if (composite.hasLocalStorage) {\n                            dcxFs.writeFileAtomically(composite._localStorage.pushedManifestPath(), branch.localData, 'utf8', function (error) {\n                                if (error) {\n                                    return pushContext._xferComplete(error);\n                                }\n                                branch._isDirty = false;\n                                pushContext._xferComplete(undefined, branch);\n                            });\n                        } else {\n                            if (composite._options.xhrBaseBranchSupport) {\n                                // make a copy of the pushed manifest data so that it can be used for a base branch\n                                composite._pushedBranchData = branch.localData;\n                            }\n                            pushContext._xferComplete(undefined, branch);\n                        }\n\n                    });\n                });\n                if (requestDesc) {\n                    requestDesc.progress = pushContext._reportProgress;\n                    requestDesc.token = pushContext;\n                }\n            });\n        });\n    };\n    \n    /**\n     * @private\n     * @param   {Object}         pushContext       \n     * @param   {Boolean}        overwriteExisting \n     * @param   {branchCallback} callback\n     */\n    exports._deleteComposite = function (pushContext, overwriteExisting, callback) {\n        var composite = pushContext._composite;\n        var branch = pushContext._owner;\n        var storageSession = pushContext._storageSession;\n        branch.compositeState = STATES.committedDelete;\n        var manifestData = branch.remoteData;\n        // Correct the size estimate\n        pushContext.bytesTotal = manifestData.length;\n\n        // TODO: progress\n        storageSession.updateManifest(branch, manifestData, overwriteExisting, function (error, response) {\n            if (error) {\n                return callback(error);\n            }\n            storageSession.deleteCompositeDirectory(composite, function (error, response) {\n                if (error) {\n                    return callback(error);\n                }\n                pushContext._journal.compositeHasBeenDeleted = true;\n                pushContext._journal.commitChanges(function (error) {\n                    if (error) {\n                        return callback(error);\n                    }\n                    if (composite.hasLocalStorage) {\n                        dcxFs.writeFileAtomically(composite._localStorage.pushedManifestPath(), branch.localData, 'utf8', function (error) {\n                            if (error) {\n                                return callback(error);\n                            }\n                            callback(undefined, branch);\n                        });\n                    } else {\n                        callback(undefined, branch);\n                    }\n                });\n            });\n        });\n    };\n    \n    /**\n     * @private\n     * @param {Object}         pushContext\n     * @param {Object}         branch      \n     * @param {branchCallback} callback    \n     */\n    exports._pushComponents = function (pushContext, branch, callback) {\n        var self = this;\n        var i, components = branch.allComponents();\n        var composite = pushContext._composite;\n        var localStorage = composite._localStorage;\n        var pendingComponents = {};\n        var journal = pushContext._journal;\n        function setComponentUploadState(component, state, error) {\n            if (state) {\n                pendingComponents[component.id] = state;\n            } else {\n                delete pendingComponents[component.id];\n            }\n            if (error) {\n                // Record the error in the pushContext\n                pushContext.failedComponents = pushContext.failedComponents || [];\n                pushContext.failedComponents.push({ component: component, error: error });\n            }\n            if (Object.keys(pendingComponents).length === 0) {\n                journal.commitChanges(callback);  // waits until journal commits to callback\n            }\n        }\n        function uploadOneComponent(component, path, componentIsNew) {\n            setComponentUploadState(component, 'uploading');\n            dcxFs.info(path, function (error, stats) {\n                if (error) {\n                    error = new AdobeDCXError(AdobeDCXError.INVALID_STATE, \"Component asset missing\", error);\n                    setComponentUploadState(component, null, error);\n                    return;\n                }\n                var size = stats.size;\n                var storageName = dcxUtil.filePathComponents(path).fileName;\n                var journalRecord = journal.getRecordForUploadedComponent(component.id);\n                if (journalRecord && journalRecord.length === size && journalRecord[\"storage-name\"] === storageName) {\n                    // already uploaded\n                    // TODO verify that the component is still on the server\n                    component.etag = journalRecord.etag;\n                    component.version = journalRecord.version;\n                    component.md5 = journalRecord.md5;\n                    component.length = journalRecord.length;\n                    component.state = STATES.unmodified;\n                    setComponentUploadState(component, null);\n                    return;\n                }\n                pushContext.bytesTotal += size;\n                var requestDesc = pushContext._storageSession.uploadComponent(component, componentIsNew, composite.collaborationType === AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER, pushContext, new FileContent(path), function (error, response, responseData) {\n                    if (!error) {\n                        var etag = response.headers.etag;\n                        var version = response.headers['x-latest-version'];\n                        var md5 = responseData.md5;\n                        if (!etag) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No etag\"); }\n                        if (!version) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No version\"); }\n                        if (!md5) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No md5\"); }\n                        if (!error) {\n                            component.etag = etag;\n                            component.version = version;\n                            component.md5 = md5;\n                            component.length = size;\n                            component.state = STATES.unmodified;\n                            journal.recordUploadedComponent(component.id, etag, version, md5, size, storageName);\n                            journal.commitChanges(); // no need to wait... will wait when push wraps up\n                        }\n                    }\n                    setComponentUploadState(component, null, error);\n                });\n                if (requestDesc) {\n                    requestDesc.progress = pushContext._reportProgress;\n                    requestDesc.token = pushContext;\n                }\n            });\n        }\n        \n        function copyOneComponent(component, sourceHref, componentIsNew) {\n            var journalRecord = journal.getRecordForUploadedComponent(component.id);\n            if (journalRecord && journalRecord[\"source-href\"] === sourceHref) {\n                // already uploaded\n                // TODO verify that the component is still on the server\n                component.etag = journalRecord.etag;\n                component.version = journalRecord.version;\n                component.md5 = journalRecord.md5;\n                component.length = journalRecord.length;\n                component.state = STATES.unmodified;\n                return;\n            }\n            setComponentUploadState(component, 'copying');\n            var requestDesc = pushContext._storageSession.copyAssetToComponentId(component.id, component.type, pushContext._composite.href, componentIsNew,\n                                                                        composite.collaborationType === AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER,\n                                                                        pushContext, sourceHref, function (error, response, responseData) {\n                        if (!error) {\n                            var etag = response.headers.etag;\n                            var version = response.headers['x-latest-version'];\n                            var md5 = responseData.md5;\n                            var length = responseData.size;\n                            if (!etag) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No etag\"); }\n                            if (!version) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No version\"); }\n                            if (!md5) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No md5\"); }\n                            if (!length) { error = new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No length\"); }\n                            if (!error) {\n                                component.etag = etag;\n                                component.version = version;\n                                component.md5 = md5;\n                                component.length = length;\n                                component.state = STATES.unmodified;\n                                journal.recordUploadedComponent(component.id, etag, version, md5, length, undefined, sourceHref);\n                                journal.commitChanges(); // no need to wait... will wait when push wraps up\n                            }\n                        } else {\n                            if (localStorage) {\n                                // See whether we have a local file we can upload instead\n                                var path = localStorage.componentAssetPath(component, branch._local());\n                                if (path) {\n                                    // Notice and TODO:\n                                    // Currently only new components can have sourceHrefs since\n                                    // we do not yet support them for update. When we start supporting\n                                    // them we must make sure that we delete the file mapping for the\n                                    // updated component if the client does not provide a new file along\n                                    // with the sourceHref. Otherwise the call below will upload the\n                                    // old file!\n                                    return uploadOneComponent(component, path, componentIsNew);\n                                }\n                            }\n                        }\n                        setComponentUploadState(component, null, error);\n                    });\n            if (requestDesc) {\n                requestDesc.progress = pushContext._reportProgress;\n                requestDesc.token = pushContext;\n            }\n        }\n        \n        for (i = 0; i < components.length; ++i) {\n            var component = components[i];\n            var componentState = component.state;\n            var etag = component.etag;\n            var componentIsNew = !etag;\n            if (!componentState) {\n                componentState = STATES.unmodified;\n            }\n            if (componentIsNew || componentState === STATES.modified) {\n                var sourceHref = branch._core._getSourceHrefOfComponent(component);\n                if (branch.hasLocalStorage || sourceHref) {\n                    var isNew = componentIsNew || pushContext._compositeIsNew;\n                    if (sourceHref) {\n                        copyOneComponent(component, sourceHref, isNew);\n                    } else {\n                        uploadOneComponent(component, localStorage.componentAssetPath(component, branch._local()), isNew);\n                    }\n                } else {\n                    // unexpected state\n                    var error = new AdobeDCXError(AdobeDCXError.INVALID_STATE, \"Component should not be modified or new without local storage\");\n                    pushContext.failedComponents = pushContext.failedComponents || [];\n                    pushContext.failedComponents.push({ component: component, error: error });\n                }\n            } else if (componentState === STATES.unmodified) {\n                journal.removeRecordForUploadedComponent(component.id);\n            } else if (componentState === STATES.committedDelete || componentState === STATES.pendingDelete) {\n                // This cleans up components from manifests that assumed the old component deletion model\n                branch.removeComponent(component);\n            }\n        }\n        // UpdateComponent will invoke the callback when all scheduled updates complete, but if there aren't any\n        // then we do it here.\n        if (Object.keys(pendingComponents).length === 0) {\n            callback();\n        }\n    };\n    \n\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    // Internal support for in-browser component up-/download and copy\n    ////////////////////////////////////////////////////////////////////////////////////////////////\n    \n    /**\n     * helper function to extract the upload record from an http response\n     * @private\n     * @param   {String}  componentId \n     * @param   {Integer} length      \n     * @param   {String}  type        \n     * @param   {Object}  response    \n     * @returns {Object}  \n     */\n    function createComponentUploadRecord(componentId, length, type, response, responseData) {\n        if (typeof length !== 'number') { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No length\"); }\n        \n        var etag = response.headers.etag;\n        var version = response.headers['x-latest-version'];\n        var md5 = responseData.md5;\n\n        if (!etag) { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No etag\"); }\n        if (!version) { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No version\"); }\n        if (!md5) { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No md5\"); }\n        \n        return new AdobeDCXComponent._UploadRecord(componentId, etag, version, md5, length, type);\n    }\n    \n    /**\n     * helper function for doing the actual upload of a component asset\n     * @private\n     * @param   {String}              componentId       \n     * @param   {String}              componentType     \n     * @param   {Boolean}             isNew             \n     * @param   {Boolean}             isSharedComposite\n     * @param   {Object}              data              \n     * @param   {String}              compositeId       \n     * @param   {String}              compositeHref     \n     * @param   {AdobeStorageSession} storageSession    \n     * @param   {Function}            callback          \n     * @returns {Object}              \n     */\n    internalUploadComponent = function (componentId, componentType, isNew, isSharedComposite,\n                                      data, compositeId, compositeHref, storageSession, callback) {\n        // Check preconditions\n        if (typeof callback !== 'function') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"callback\" must be a function.');\n        }\n        \n        // Prepare the upload\n        var dataLength = data.length || data.byteLength || data.size;\n        var context = new XferContext(storageSession, callback);\n        context.bytesTotal = dataLength;\n        \n        // Upload the component asset\n        var requestDesc = storageSession.uploadAssetForComponentId(componentId, componentType, compositeHref, isNew, isSharedComposite, context, data, function (error, response, responseData) {\n            var results;\n            if (!error) {\n                try {\n                    results = new AdobeDCXComponent._UploadResults(compositeId);\n                    dataLength = dataLength || requestDesc.bytesSent;\n                    results.records[componentId] = createComponentUploadRecord(componentId, dataLength, componentType, response, responseData);\n                } catch (e) {\n                    error = e;\n                    results = undefined;\n                }\n            }\n            context._xferComplete(error, results);\n        });\n        if (requestDesc) {\n            requestDesc.progress = context._reportProgress;\n            requestDesc.token = context;\n        }\n        \n        return context;\n    };\n    \n    \n    /**\n     * helper function to extract the upload record from a copy http response\n     * @private\n     * @param   {String}  componentId \n     * @param   {Object}  data      \n     * @param   {String}  type        \n     * @param   {Object}  response    \n     * @returns {Object}  \n     */\n    function createComponentCopyRecord(componentId, responseData, type, response) {\n        var etag = response.headers.etag;\n        var version = response.headers['x-latest-version'];\n        var md5 = responseData.md5;\n        var length = responseData.size;\n\n        if (typeof length !== 'number') { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No length\"); }\n        if (!etag) { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No etag\"); }\n        if (!version) { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No version\"); }\n        if (!md5) { throw new AdobeDCXError(AdobeDCXError.UNEXPECTED_RESPONSE, \"No md5\"); }\n        \n        return new AdobeDCXComponent._UploadRecord(componentId, etag, version, md5, length, type);\n    }\n    \n    \n    /**\n     * helper function for doing the actual copy of a component asset\n     * @private\n     * @param   {String}              componentId       \n     * @param   {String}              componentType     \n     * @param   {Boolean}             isNew             \n     * @param   {Boolean}             isSharedComposite\n     * @param   {Object}              data              \n     * @param   {String}              compositeId       \n     * @param   {String}              compositeHref     \n     * @param   {AdobeStorageSession} storageSession    \n     * @param   {Function}            callback          \n     * @returns {Object}              \n     */\n    internalCopyComponent = function (componentId, componentType, isNew, isSharedComposite,\n                                      sourceHref, compositeId, compositeHref, storageSession, callback) {\n        // Check preconditions\n        if (typeof callback !== 'function') {\n            throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, 'Param \"callback\" must be a function.');\n        }\n        \n        // Prepare the upload\n        var context = new XferContext(storageSession, callback);\n        \n        // Upload the component asset\n        var requestDesc = storageSession.copyAssetToComponentId(componentId, componentType, compositeHref,\n                                                                 isNew, isSharedComposite, context,\n                                                                 sourceHref, function (error, response, responseData) {\n                    if (context._aborted) { // no callback when aborted\n                        return;\n                    }\n                    var results;\n                    if (!error) {\n                        try {\n                            results = new AdobeDCXComponent._UploadResults(compositeId);\n                            results.records[componentId] = createComponentCopyRecord(componentId, responseData, componentType, response);\n                        } catch (e) {\n                            error = e;\n                            results = undefined;\n                        }\n                    }\n                    callback(error, results);\n                });\n        if (requestDesc) {\n            requestDesc.progress = context._reportProgress;\n            requestDesc.token = context;\n        }\n        \n        return context;\n    };\n \n    return exports;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console */\n\n/**\n* Main entry point for Adobe DCX library. In most cases this is the only DCX module you \n* need to require().\n*\n* <p>Methods, arguments and properties are marked with <strong>NJS-only</strong> if they are only supported \n* when running in a Node.js environment. Conversely methods, arguments and properties that are marked\n* <strong>XHR-only</strong> are only available in a browser enviroment. Examples are also often marked with either\n* <strong>NJS</strong> or <strong>XHR</strong>.</p>\n*\n* @module AdobeDCX\n*/\n\n/*begin-node-only*/\n// Support either node.js or in the browser\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n/*end-node-only*/\n\ndefine('components/dcx-js/src/AdobeDCX',['require','exports','module','./AdobeDCXComposite','./AdobeDCXLocalStorage','./AdobeNetworkHTTPService','./AdobeStorageSession','./AdobeDCXCompositeXfer','./AdobeDCXUtil','./AdobeDCXError','./AdobeDCXFS'],function (require, exports, module) {\n    'use strict';\n    \n    \n    var AdobeDCXComposite = require('./AdobeDCXComposite'),\n        AdobeDCXLocalStorage = require('./AdobeDCXLocalStorage'),\n        AdobeNetworkHTTPService = require('./AdobeNetworkHTTPService'),\n        AdobeStorageSession = require('./AdobeStorageSession'),\n        AdobeDCXCompositeXfer = require('./AdobeDCXCompositeXfer'),\n        AdobeDCXUtil = require('./AdobeDCXUtil'),\n        AdobeDCXError = require('./AdobeDCXError'),\n        AdobeDCXFS = require('./AdobeDCXFS');\n    \n    \n    /**\n     * Can be passed into the AdobeDCX constructor to control how it works.\n     * @typedef {Object} DCXOptions\n     * @property {boolean} [preserveFileExtensions] Whether component assets in local storage get \n     *                                              the extension of their path properties.\n     * @property {boolean} [xhrBaseBranchSupport]   Whether when running in the browser a composite \n     *                                              should keep a copy of the last pulled or pushed \n     *                                              manifest in memory so that clients can request \n     *                                              the base branch for conflict merging.\n     */\n\n    /**\n     * @constructor\n     * @example\n     * // NJS\n     * var AdobeDCX = require('./path/to/library/AdobeDCX');\n     * var dcx = new AdobeDCX(require('fs'), { preserveFileExtensions: true });\n     * @example\n     * // XHR\n     * var AdobeDCX = require('./path/to/library/AdobeDCX');\n     * var dcx = new AdobeDCX();\n     * @alias module:AdobeDCX\n     * @param {Object} [fileSystemService] An object implementing the v0.8.22 interface of nodejs' fs. \n     *                                     See: {@link http://nodejs.org/docs/v0.8.22/api/fs.html}\n     * @param {DCXOptions} [options]       Controls the behavior of DCX. Notice that this object will\n     *                                     get copied. I.e. modifying it after the constructor has\n     *                                     finished will not have any effect.\n     */\n    function AdobeDCX(fileSystemService, options) {\n        if (fileSystemService) {\n            AdobeDCXFS._setFS(fileSystemService);\n        }\n        this._compositeOptions = AdobeDCXUtil.merge({}, options);\n    }\n    \n    /**\n     * The different types of collaboration for a composite. You can set the collaboration type \n     * directly on a {@link module:AdobeDCXComposite|AdobeDCXComposite} object.\n     */\n    AdobeDCX.COLLABORATION = {\n        /**\n         * Composite is not shared. This is the default for a new composite.\n         * @constant\n         * @alias COLLABORATION.PRIVATE\n         * @memberof! module:AdobeDCX\n         */\n        PRIVATE: AdobeDCXComposite.COLLABORATION.PRIVATE,\n        /**\n         * Current user is the owner of the composite and has shared it with others.\n         * @constant\n         * @alias COLLABORATION.SHARED_BY_USER\n         * @memberof! module:AdobeDCX\n         */\n        SHARED_BY_USER: AdobeDCXComposite.COLLABORATION.SHARED_BY_USER,\n        /**\n         * Composite is owned by another user but is being shared with the current user.\n         * @constant\n         * @alias COLLABORATION.SHARED_WITH_USER\n         * @memberof! module:AdobeDCX\n         */\n        SHARED_WITH_USER: AdobeDCXComposite.COLLABORATION.SHARED_WITH_USER\n    };\n    \n    /** \n    Accessor for the {@link module:AdobeDCXError|AdobeDCXError} class.\n    @readonly\n    @type {AdobeDCXError}\n    */\n    AdobeDCX.AdobeDCXError = AdobeDCXError;\n    \n    //******************************************************************************\n    // Data providers\n    //******************************************************************************\n    \n    /**\n     * Class for providing file content as data\n     */\n    AdobeDCX.FileContent = AdobeNetworkHTTPService.FileContent;\n    \n    /**\n     * Class for providing stream content as input data\n     */\n    AdobeDCX.StreamProvider = AdobeNetworkHTTPService.StreamProvider;\n\n    //******************************************************************************\n    // Creating Composites\n    //******************************************************************************\n    \n    /**\n     * Creates and returns a new empty composite.\n     * @example\n     * // NJS\n     * var composite = dcx.newEmptyComposite('Untitled', MY_COMPOSITE_TYPE);\n     * composite.path = myBaseFilePathForComposites + '/' + composite.id;\n     * @example\n     * // XHR\n     * var composite = dcx.newEmptyComposite('Untitled', MY_COMPOSITE_TYPE);\n     * @param {String} name    The name of the new composite.\n     * @param {String} type    The content type of the new composite.\n     * @param {String} [path]  A local file path for the composite to persist to.\n     * @param {String} [id]    A unique id for the composite. If undefined then a new random id will get assigned.\n     * @returns {@link module:AdobeDCXComposite|AdobeDCXComposite}\n     */\n    AdobeDCX.prototype.newEmptyComposite = function (name, type, path, id) {\n        var newComposite = new AdobeDCXComposite(name, type, null, id, null, this._compositeOptions);\n        if (path) {\n            // We set the path after calling the constructor so that it doesn't attempt to load the manifest.\n            newComposite.path = path;\n        }\n        return newComposite;\n    };\n    \n    /**\n     * Gets passed into newCompositeFromLocalStorage() and called when the composite has been read\n     * from local storage or the attempt to do so has failed.\n     * @callback newCompositeCallback\n     *    @param {Error}             error     The error or undefined.\n     *    @param {AdobeDCXComposite} composite The newly created composite.\n     */\n    \n    /**\n     * <strong>NJS-only</strong>. \n     * <p>Asynchronously creates a composite for a locally saved composite that might or might not have \n     * a server-side existence.\n     * Will try to read the composite's current manifest into memory.</p>\n     * @example\n     * var filePath; // The absolute file path of the local composite directory.\n     * dcx.newCompositeFromLocalStorage = function (filePath, function (error, composite) {\n     *      if (!error) {\n     *          // do something with composite\n     *      }\n     * });\n     * @param {String}               path       The absolute file path of the local composite directory.\n     * @param {newCompositeCallback} callback   Gets called when the composite has been loaded (or has \n     *                                          failed to do so).\n     */\n    AdobeDCX.prototype.newCompositeFromLocalStorage = function (path, callback) {\n        try {\n            if (typeof path !== 'string') {\n                throw new AdobeDCXError(AdobeDCXError.INVALID_PARAMS, '');\n            }\n            var newComposite = new AdobeDCXComposite(null, null, path, null, null, this._compositeOptions);\n            newComposite.loadCurrentFromLocalStorage(function (error, current) {\n                callback(error, error ? undefined : newComposite);\n            });\n            // Delete any existing temp files.\n            newComposite.deleteTempFiles();\n        } catch (error) {\n            callback(error);\n        }\n    };\n    \n    /**\n     * Creates and returns an AdobeDCXComposite object for a composite that doesn't exist locally \n     * (yet). Does not pull it down yet. You must explicitely call pull.\n     * @example\n     * // NJS\n     * var composite = dcx.newCompositeWithHref(href, compositeDirPath]);\n     * // next: pull the composite\n     * @example\n     * // XHR\n     * var composite = dcx.newCompositeWithHref(href]);\n     * // next: pull the composite manifest\n     * @param   {String} href   The path of the composite on the server.\n     * @param   {String} path   The local storage path for the composite. There must not be a file or \n     *                          directory at this path.\n     * @param   {String} [name] The name of the new composite. Will get overridden with the \n     *                          actual name once the composite is pulled.\n     * @param   {String} [id]   The unique id for the composite. Will get overridden with \n     *                          the actual id once the composite is pulled.\n     * @param   {String} [type] The content type of the new composite. Will get overridden \n     *                          with the actual type once the composite is pulled.\n     * @returns {@link module:AdobeDCXComposite|AdobeDCXComposite}\n     */\n    AdobeDCX.prototype.newCompositeWithHref = function (href, path, name, id, type) {\n        var newComposite = new AdobeDCXComposite(name, type, null, id, href, this._compositeOptions);\n        if (path) {\n            // We set the path after calling the constructor so that it doesn't attempt to load the manifest.\n            newComposite.path = path;\n        }\n        \n        return newComposite;\n    };\n    \n    /**\n     * Creates and returns a new composite object that is a copy of compositeBranchOrElement.\n     * \n     * @param   {Object}    compositeOrBranchOrElement As the name implies this param is expected to be\n     *                                                 either a composite (with a valid current branch),\n     *                                                 a branch or an element. Furthermore it may (at\n     *                                                 this point in time) not contain an new or modified\n     *                                                 components.\n     * @param   {String}    [name]                     An optional new name for the new composite. If undefined\n     *                                                 the composite will have the same name as the original.\n     * @param   {String}    [type]                     An optional new type for the new composite. If undefined\n     *                                                 the composite will have the same type as the original.\n     * @param   {String}    [path]                     The optional local file path for the composite.\n     * @param   {String}    [id]                       An optional new id for the new composite. If undefined\n     *                                                 the composite will get a random new id.\n     * @param   {String}    [href]                     The new href of the composite\n     * @returns {@link module:AdobeDCXComposite|AdobeDCXComposite}\n     */\n    AdobeDCX.prototype.newCompositeAsCopyOf = function (compositeOrBranchOrElement, name, type, path, id, href) {\n        return AdobeDCXComposite.newCompositeAsCopyOf(compositeOrBranchOrElement, name, type, path, id, href, this._compositeOptions);\n    };\n    \n    //******************************************************************************\n    // Transfering Composites\n    //******************************************************************************\n    \n    /**\n     * Gets passed into createHTTPService() and called back whenever the service needs a new\n     * authentication token.\n     * @callback authenticationCallback\n     *    @param {AdobeHTTPService} service The service that is requesting a new auth token.\n     */\n    \n    /**\n     * Constructs and returns a network service instance.\n     * @example\n     * var AdobeDCX = require('./path/to/library/AdobeDCX');\n     * var dcx = new AdobeDCX(require('fs')); // leave off require('fs') in browser environment\n     * var service = dcx.createHTTPService(function (service) {\n     *      myGetToken(function (token) {\n     *          service.setAuthToken(token);\n     *      });\n     * });\n     * service.setApiKey('MyApiKey');\n     * service.setAdditionalHeaders( {'foo': 'bar'} );\n     * @param   {authenticationCallback} authCallback Called when authentication fails. Client must \n     *                                              secure a new authentication token and call \n     *                                              service.setAuthToken(token) for the service \n     *                                              to resume.\n     *                                              @returns {@link module:AdobeHTTPService|AdobeHTTPService}\n     */\n    AdobeDCX.prototype.createHTTPService = function (authCallback) {\n        return new AdobeNetworkHTTPService(authCallback);\n    };\n    \n    /**\n     * Constructs and returns a storage session instance.\n     * @example\n     * // create instances of AdobeDCX and AdobeHTTPService\n     * ...\n     * var session = dcx.createStorageSession(service, 'https://my.proxy.adobe.com/ccstorage'); \n     * @param   {AdobeHTTPService}    httpService The HTTP service.\n     * @param   {String}              endpoint    The url for the storage server.\n     * @returns {@link module:AdobeStorageSession|AdobeStorageSession}\n     */\n    AdobeDCX.prototype.createStorageSession = function (httpService, endpoint) {\n        return new AdobeStorageSession(httpService, endpoint);\n    };\n    \n    /** \n    Accessor for the {@link module:AdobeDCXCompositeXfer|AdobeDCXCompositeXfer} class.\n    @readonly\n    @type {AdobeDCXCompositeXfer}\n    */\n    AdobeDCX.prototype.compositeXfer = AdobeDCXCompositeXfer;\n    \n    return AdobeDCX;\n});\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, nodeRequire, VulcanInterface, VulcanMessage */\n\n/**\n * @class AdobeLibraryServices\n * @classdesc\n * Accessors for external dependencies\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryServices',['require','exports','module','./components/uuid/uuid','./components/dcx-js/src/AdobeDCX'],function (require, exports, module) {\n    'use strict';\n\n    var uuid = require('./components/uuid/uuid');\n    var AdobeDCX = require('./components/dcx-js/src/AdobeDCX');\n\n    function AdobeLibraryServices() {\n        var requireType = typeof nodeRequire; // Avoid JSLint warning\n        if (requireType !== 'undefined') {\n            this.fs = nodeRequire('fs');\n            this.path = nodeRequire('path');\n        }\n\n        this._initDCX();\n    }\n\n    AdobeLibraryServices.prototype._initDCX = function () {\n        this.dcx = new AdobeDCX(this.fs, {\n            preserveFileExtensions: true\n        });\n    };\n\n    AdobeLibraryServices.prototype.uuid = function () {\n        return uuid();\n    };\n\n    AdobeLibraryServices.prototype.log = function (message) {\n        if (this._log) {\n            this._log('CC Libraries: ' + message);\n        }\n    };\n\n    AdobeLibraryServices.prototype.getDisplayName = function (element) {\n        if (this._getDisplayName) {\n            return this._getDisplayName(element);\n        }\n        return element.name;\n    };\n\n    AdobeLibraryServices.prototype.hasFileSystem = function () {\n        return this.fs !== undefined;\n    };\n\n    AdobeLibraryServices.prototype.setFileSystem = function (fs) {\n        this.fs = fs;\n\n        // Need to reinitialise DCX because the FS changed\n        this._initDCX();\n    };\n\n    AdobeLibraryServices.prototype.getVulcanInterface = function () {\n        var vulcanInterfaceType = typeof VulcanInterface;\n        if (vulcanInterfaceType !== 'undefined') {\n            return VulcanInterface;\n        }\n    };\n\n    AdobeLibraryServices.prototype.getVulcanMessage = function () {\n        var vulcanMessageType = typeof VulcanMessage;\n        if (vulcanMessageType !== 'undefined') {\n            return VulcanMessage;\n        }\n    };\n\n    AdobeLibraryServices.prototype.hasCEPVulcan = function () {\n        return this.getVulcanInterface() !== undefined && this.getVulcanMessage() !== undefined;\n    };\n\n    /**\n        Path utils\n    **/\n\n    AdobeLibraryServices.prototype.getPathSeparator = function () {\n        return '/';\n        // TOFIX: We would like to use the code below, but the Libraries Panels always pass in\n        // paths with '/' as the delimiter, even on Windows. So we need to revert this for now.\n        // return this.path ? this.path.sep : '/';\n    };\n\n    AdobeLibraryServices.prototype.getFileNameFromPath = function (path) {\n        // TOFIX: on Windows, paths are inconsistent - sometimes with '/' and sometimes with '\\' (depends on whether they come from CEP or the product)\n        // If the path contains any '\\' characters, and does NOT contain any '/' characters, we assume it's a Windows path.\n        // We convert the '\\' into '/', to do the split.\n        if (path.indexOf('/') === -1 && path.indexOf('\\\\') !== -1) {\n            path = path.replace(/\\\\/g, '/');\n        }\n        return path.split('/').pop();\n    };\n\n\n    return new AdobeLibraryServices();\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryError\n * @classdesc\n * Class for communicating Creative Cloud Library errors. We handle errors in two ways:\n *\n * * Synchronous methods will throw an error if something goes wrong.\n * * Asynchronous methods always return an error object as the first argument of the callback, or `null` if there was no error.\n *\n * @description\n * This class has a private constructor.\n *\n * @property {String} code The type of error.\n * @property {String} message A description of the error.\n * @property {Uuid} [libraryId] The id of the library that the error occurred in (if not defined, assume it's a problem at the collection level).\n * @property {Error} [underlyingError] The underlying cause of the error, if applicable (e.g. a DCX error).\n *\n * @private\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryError',['require','exports','module'],function (require, exports, module) {\n    'use strict';\n\n    // Private constructor\n    function AdobeLibraryError(code, message, libraryId, underlyingError) {\n        Error.call(this);\n        this.code = code;\n        this._message = message;\n        this.message = '[' + code + '] ' + message;\n        this.libraryId = libraryId;\n        this.underlyingError = underlyingError;\n    }\n\n    AdobeLibraryError.prototype = new Error();\n    AdobeLibraryError.prototype.name = 'AdobeLibraryError';\n    delete AdobeLibraryError.prototype.stack;\n\n\n    /**\n        Error codes\n    **/\n\n    // Invalid cases: should never be exposed to the user (it means you're using the API incorrectly)\n\n    /**\n     * An invalid parameter was passed into the method.\n     *\n     * This should never be exposed to the user; it indicates that the API is being used incorrectly.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.INVALID_PARAMETER = 'INVALID_PARAMETER';\n\n    /**\n     * You're trying to modify a read-only property (i.e. a property that is never directly modifiable, regardless of the\n     * permissions of the user - contrast this to {@link AdobeLibraryError.NOT_ALLOWED}).\n     *\n     * This should never be exposed to the user; it indicates that the API is being used incorrectly.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.READ_ONLY = 'READ_ONLY';\n\n    /**\n     * The method you called is not yet implemented, but we intend to implement it in the near future. For example,\n     * this is the case for copy/move operations in the browser, since we're waiting for server-side functionality to be implemented.\n     *\n     * This should never be exposed to the user; it indicates that the API is being used incorrectly.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.NOT_IMPLEMENTED = 'NOT_IMPLEMENTED';\n\n    /**\n     * The method you called is not supported, because of the API configuration. For example, if shared local storage is\n     * enabled, methods related to loading and unloading library collections are not supported (instead, you should listen\n     * for changes to the list of loaded collections).\n     *\n     * This should never be exposed to the user; it indicates that the API is being used incorrectly.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.NOT_SUPPORTED = 'NOT_SUPPORTED';\n\n    /**\n     * The method you called requires a file system (e.g. it involves paths on disk, or copying files around), but you're\n     * running in an environment where there isn't a filesystem (e.g. in the browser). Unlike NOT_IMPLEMENTED, there are no\n     * plans to ever support this method in a non-filesystem environment.\n     *\n     * This should never be exposed to the user; it indicates that the API is being used incorrectly.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.REQUIRES_FILESYSTEM = 'REQUIRES_FILESYSTEM';\n\n    /**\n     * The object you're trying to access a property of, or perform an operation on, has been deleted locally. This means\n     * that you should no longer hold onto your reference to it. For example, after calling {@link AdobeLibraryComposite#removeElement},\n     * you'll get this error if you try to perform any operations on the removed element.\n     *\n     * This should never be exposed to the user; it indicates that the API is being used incorrectly.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.DELETED_LOCALLY = 'DELETED_LOCALLY';\n\n    // User-visible local errors:\n\n    /**\n     * The user doesn't have permissions to do the requested operation - for example, they don't have write access to a library\n     * that they're trying to modify.\n     *\n     * Note that this is in contrast to {@link AdobeLibraryError.READ_ONLY}, which corresponds to a property that the API never allows\n     * you to modify.\n     *\n     * This is a user-visible error - they should be informed why the operation failed.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.NOT_ALLOWED = 'NOT_ALLOWED';\n\n    /**\n     * When setting a file as a representation, e.g. via {@link AdobeLibraryRepresentation#updateContentFromPath}, there is a limit in\n     * size of 1GB. We return this error to prevent you from adding files that are larger than 1GB to a library - otherwise they would\n     * fail to upload, and leave the library in an unsyncable state.\n     *\n     * This is a user-visible error - they should be informed why the operation failed.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.FILE_TOO_LARGE = 'FILE_TOO_LARGE';\n\n    /**\n     * Aborting an operation that would bring the library over the maximum size (1000 elements). For example, trying to add\n     * a new element when the library already has 1000 elements.\n     *\n     * This is a user-visible error - they should be informed why the operation failed.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.EXCEEDS_MAX_LIBRARY_SIZE = 'EXCEEDS_MAX_LIBRARY_SIZE';\n\n    /**\n     * We're unable to read the manifest for a library, due to it being invalid.\n     *\n     * This may be a user-visible error, but purely informational - there's nothing they can do right now, if they have a corrupted library.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.CORRUPTED_LIBRARY = 'CORRUPTED_LIBRARY';\n\n    /**\n     * No rendition is available for an element, or shared cloud failed to generate a rendition.\n     *\n     * This may be exposed to the user in the form of a default/broken thumbnail.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.RENDITION_NOT_AVAILABLE = 'RENDITION_NOT_AVAILABLE';\n\n    /**\n     * Reading/writing to disk failed, due to a file system error. This indicates a critical error, such as not having permissions\n     * to read/write to the intended location on disk. If there's an error due to lack of disk space, you will get an\n     * {@link AdobeLibraryError.OUT_OF_SPACE} error instead.\n     *\n     * This is a user-visible error - they may be able to correct, e.g. by changing permissions.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.FS_ERROR = 'FS_ERROR';\n\n    /**\n     * Writing to disk failed, due to not having enough disk space.\n     *\n     * This is a user-visible error - they can correct it by freeing up space.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.OUT_OF_SPACE = 'OUT_OF_SPACE';\n\n\n    // User-visible network errors:\n\n    /**\n     * We don't have an access token, so we can't perform any syncing operations. You need to call `CCLibraries.updateAccessToken`\n     * with a new access token, in order for syncing to resume.\n     *\n     * This may be exposed to the user in the form of prompting them to re-login, but automatically renewing the access token\n     * in the background is better, if possible.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.LOGGED_OUT = 'LOGGED_OUT';\n\n    /**\n     * A push failed due to the user having insufficient remaining storage space on shared cloud.\n     *\n     * This is a user-visible error - they can free up space on their creative cloud account to recover from this.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.EXCEEDS_QUOTA = 'EXCEEDS_QUOTA';\n\n    /**\n     * We received a 5xx error from the server, indicating a temporary server problem. The libraries API will automatically\n     * retry a certain number of times.\n     *\n     * This is a user-visible error - they should be notified of the server error, and any retries.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.RETRYABLE_SERVER_ERROR = 'RETRYABLE_SERVER_ERROR';\n\n    /**\n     * Something unexpected happened during the syncing operation - we received an unexpected response from the server. This\n     * may or may not be recoverable, depending on what went wrong.\n     *\n     * This is a user-visible error - they should be notified of the error.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.TRANSFER_ERROR = 'TRANSFER_ERROR';\n\n    /**\n     * The syncing operation was aborted.\n     *\n     * This is not a user-visible error.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.TRANSFER_ABORTED = 'TRANSFER_ABORTED';\n\n    /**\n     * We didn't get a response from the server, or a request timed out. This is normally due to the user losing their network connection,\n     * but it could be due to a gateway failure on our servers, or a failure elsewhere in the network. We expect this to be recoverable.\n     *\n     * This is a user-visible error - they should be notified of the error, and given the chance to retry when they come online again.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.NETWORK_ERROR = 'NETWORK_ERROR';\n\n    /**\n     * The user does not have permissions to use CC Libraries as a cloud service. This error occurs when you have a Type 2 account\n     * with no services provisioned, or if the encryption key for the account has been revoked.\n     *\n     * If we receive a 403 error from the server, this is interpreted as ACCESS_DENIED.\n     *\n     * This is a user-visible error - they should be notified of the error.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.ACCESS_DENIED = 'ACCESS_DENIED';\n\n    /**\n     * The URL stored in a library (as an external link) is not valid, according to our whitelist. We only support linking to\n     * https:// URLs, and they must be whitelisted to an approved Adobe domain, for security reasons.\n     *\n     * This is a user-visible error - it means the external link won't be accessible to them.\n     * @constant\n     * @memberof AdobeLibraryError\n     */\n    AdobeLibraryError.URL_VALIDATION_FAILED = 'URL_VALIDATION_FAILED';\n\n    return AdobeLibraryError;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryConfig\n * @classdesc\n * Configuration options\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryConfig',['require','exports','module','./AdobeLibraryError'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryError = require('./AdobeLibraryError');\n\n    var configurableParams = [\n        'ROOT_DIR',\n        'POLL_INTERVAL',\n        'RENDITION_SIZES',\n        'FULL_RENDITION_CONFIG',\n        'EXTERNAL_LINK_PREFETCH',\n        'DEFAULT_LIBRARY_NAME',\n        'STORAGE_API_KEY',\n        'USER_AGENT_HEADER',\n        'SYNC_POLICY',\n        'ELEMENT_TYPE_FILTERS',\n        'AUTO_START_POLLING',\n        'SHARED_LOCAL_STORAGE',\n        'SHARED_LOCAL_STORAGE_ANALYTICS',\n        'PROXY_AUTH',\n        'WHITELISTED_DOMAINS',\n        'CLIENT_DESCRIPTION'\n    ];\n\n    function AdobeLibraryConfig() {\n        this.name = 'config'; // Have to put something here to avoid empty block linter warning\n    }\n\n    // Current version of design library manifest format\n    AdobeLibraryConfig.prototype.VERSION = 1;\n\n    // Maximum number of elements in a design library\n    AdobeLibraryConfig.prototype.MAX_ELEMENTS = 1000;\n\n    // Maximum size (in bytes) of a DCX component - currently the storage service limits it to 1GB\n    AdobeLibraryConfig.prototype.MAX_COMPONENT_SIZE = 1024 * 1024 * 1024;\n\n    // Valid relationships for a design library representation\n    AdobeLibraryConfig.prototype.VALID_RELATIONS = ['rendition', 'primary', 'alternate'];\n\n    // Valid relationships for a design library representation\n    AdobeLibraryConfig.prototype.VALID_SYNC_POLICIES = ['manifestAndAssets', 'manifestOnly'];\n\n    // Filters for design library element types\n    AdobeLibraryConfig.prototype.ELEMENT_TYPE_FILTERS = [];\n\n    // Names for DCX-specific fields\n    AdobeLibraryConfig.prototype.DL_NAMESPACE = 'library';\n    AdobeLibraryConfig.prototype.DL_PREFIX = AdobeLibraryConfig.prototype.DL_NAMESPACE + '#';\n    AdobeLibraryConfig.prototype.VERSION_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'version';\n    AdobeLibraryConfig.prototype.CATEGORY_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'category';\n    AdobeLibraryConfig.prototype.RELATIONSHIP_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'rel';\n    AdobeLibraryConfig.prototype.WIDTH_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'width';\n    AdobeLibraryConfig.prototype.HEIGHT_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'height';\n    AdobeLibraryConfig.prototype.LENGTH_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'length';\n    AdobeLibraryConfig.prototype.IS_FULL_SIZE_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'isFullSize';\n    AdobeLibraryConfig.prototype.MODIFIED_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'modified';\n    AdobeLibraryConfig.prototype.CREATED_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'created';\n    AdobeLibraryConfig.prototype.LINK_TYPE_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'linktype';\n    AdobeLibraryConfig.prototype.LINK_URL_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'linkurl';\n    AdobeLibraryConfig.prototype.REPRESENTATION_ORDER_KEY = AdobeLibraryConfig.prototype.DL_PREFIX + 'representationOrder';\n\n    // DCX types for design library core nodes\n    AdobeLibraryConfig.prototype.COMPOSITE_TYPE = 'application/vnd.adobe.library+dcx';\n    AdobeLibraryConfig.prototype.LINK_REPRESENTATION_TYPE = 'application/vnd.adobe.library.link+dcx';\n    AdobeLibraryConfig.prototype.ELEMENTS_NAME = 'elements';\n    AdobeLibraryConfig.prototype.CATEGORIES_NAME = 'categories';\n\n    // Analytics\n    AdobeLibraryConfig.prototype.ANALYTICS_ELEMENT_UPDATE_THRESHOLD = 500; // Ignore multiple updates to an element within this threshold (ms).\n\n    // Syncing and server configuration\n    AdobeLibraryConfig.prototype.PUBLIC_USER_ID = 'public'; // The 'userId' we use for a public collection (i.e. there is no user associated with it)\n    AdobeLibraryConfig.prototype.DEFAULT_CLOUD_ID = 'creative_cloud';\n    AdobeLibraryConfig.prototype.STORAGE_ASSETS_PATH = '/assets/';\n    AdobeLibraryConfig.prototype.LIBRARY_SYNC_GROUP = 'adobe-libraries';\n    AdobeLibraryConfig.prototype.PUBLIC_STORAGE_ASSETS_PATH = '/public/';\n    AdobeLibraryConfig.prototype.PUBLIC_LIBRARY_SYNC_GROUP = 'libraries';\n    AdobeLibraryConfig.prototype.STORAGE_API_KEY = ''; // Required parameter unless using shared local storage. Clients must provide in configuration options.\n    AdobeLibraryConfig.prototype.USER_AGENT_HEADER = undefined; // Optional parameter, to set a User-Agent header on all requests.\n\n    // Sync configuration\n    AdobeLibraryConfig.prototype.SYNCING_ENABLED = true; // Setting this to false will turn off library syncing\n    AdobeLibraryConfig.prototype.DEFAULT_MAX_SYNC_INTERVAL = 10000; // Maximum time between syncs in milliseconds\n    AdobeLibraryConfig.prototype.RETRY_FAIL_MAX_SYNC_INTERVAL = 60000; // Maximum time between syncs, if there's a server error and we failed on retry (need to throttle)\n    AdobeLibraryConfig.prototype.MAX_SYNC_INTERVAL = AdobeLibraryConfig.prototype.DEFAULT_MAX_SYNC_INTERVAL;\n    AdobeLibraryConfig.prototype.POLL_INTERVAL = 1; // Time to poll in the background, in minutes\n    AdobeLibraryConfig.prototype.AUTO_START_POLLING = false; // Automatically start polling after getting a library collection\n    AdobeLibraryConfig.prototype.RENDITION_SIZES = {}; // Specify sizes of renditions to auto-fetch\n    AdobeLibraryConfig.prototype.FULL_RENDITION_CONFIG = {}; // Configuration of when to generate full-size renditions\n    AdobeLibraryConfig.prototype.BACKOFF_INTERVALS = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]; // Fibonacci backoff\n    AdobeLibraryConfig.prototype.ERROR_RETRY_INTERVALS = [30, 60, 120]; // Default retry (in seconds) - gets overriden by a retry-after header\n    AdobeLibraryConfig.prototype.NETWORK_TIMEOUT = 10 * 60 * 1000; // 10 minutes timeout (has to be long, since pushing can be inactive for a long time)\n    AdobeLibraryConfig.prototype.RETRY_RANDOM_SECONDS = 30; // Choose random seconds between [0,x] for retry-after as a date\n    AdobeLibraryConfig.prototype.RENDITION_MAX_RETRIES = 2; // Maximum number of times to retry fetching a rendition if there's a failure\n    AdobeLibraryConfig.prototype.DEFAULT_RENDITION_RETRY_INTERVAL = 1000; // Time between retrying rendition fetch\n    AdobeLibraryConfig.prototype.RENDITION_RETRY_INTERVAL = AdobeLibraryConfig.prototype.DEFAULT_RENDITION_RETRY_INTERVAL;\n    AdobeLibraryConfig.prototype.DEFAULT_RENDITION_404_BACKOFF = 5 * 60 * 1000; // If we get a 404 on a rendition (after the max of 2 retries), back off for 5 minutes.\n    AdobeLibraryConfig.prototype.RENDITION_404_BACKOFF = AdobeLibraryConfig.prototype.DEFAULT_RENDITION_404_BACKOFF;\n    AdobeLibraryConfig.prototype.LOCAL_RENDITION_MAX_RETRIES = 5; // Retrying rendition fetch from local storage process\n    AdobeLibraryConfig.prototype.LOCAL_RENDITION_RETRY_INTERVAL = 200; // Time between retrying rendition fetch\n    AdobeLibraryConfig.prototype.MAX_UPDATE_CONFLICTS = 5; // Max number of times to retry on a 412, on a single sync\n\n    // Whitelisting\n    AdobeLibraryConfig.prototype.WHITELISTED_DOMAINS = []; // Allowed domains for external links (this includes ADOBE_AUTHENTICATED_DOMAINS)\n    AdobeLibraryConfig.prototype.ADOBE_AUTHENTICATED_DOMAINS = ['adobe.com', 'adobe.io', 'fotolia.net']; // We set the access token when calling these\n\n    AdobeLibraryConfig.prototype.SYNC_POLICY = 'manifestAndAssets'; // Policy for pulling\n\n    // Rendition cache\n    AdobeLibraryConfig.prototype.RENDITION_CACHE_FILE = 'cache.json';\n    AdobeLibraryConfig.prototype.RENDITION_CACHE_PLACEHOLDER = '<placeholder>';\n\n    // Shared local storage\n    AdobeLibraryConfig.prototype.SHARED_LOCAL_STORAGE = true; // Do we connect to a local storage service?\n    AdobeLibraryConfig.prototype.SHARED_LOCAL_STORAGE_VERSION = 7; // Version to allow us to make breaking changes\n    // As a server, I expect the client to be at within this range:\n    AdobeLibraryConfig.prototype.SHARED_LOCAL_STORAGE_MIN_CLIENT_VERSION = 5;\n    AdobeLibraryConfig.prototype.SHARED_LOCAL_STORAGE_MAX_CLIENT_VERSION = 7;\n\n    // Vulcan messages\n    AdobeLibraryConfig.prototype.VULCAN_PREFIX = 'vulcan.SuiteMessage.';\n    AdobeLibraryConfig.prototype.VULCAN_STARTUP_MESSAGE = 'cclibraries.service.Initialized';\n    AdobeLibraryConfig.prototype.VULCAN_SHUTDOWN_REQUEST = 'cclibraries.service.TerminateServiceRequest';\n    AdobeLibraryConfig.prototype.VULCAN_QUERY_REQUEST = 'cclibraries.service.QueryRequest';\n    AdobeLibraryConfig.prototype.VULCAN_QUERY_RESPONSE = 'cclibraries.service.QueryResponse';\n    AdobeLibraryConfig.prototype.VULCAN_LIBRARY_CHANGED_LOCAL_TYPE = 'cclibraries.service.LibraryChangedLocal';\n    AdobeLibraryConfig.prototype.VULCAN_LIBRARY_CHANGED_REMOTE_TYPE = 'cclibraries.service.LibraryChangedRemote';\n    AdobeLibraryConfig.prototype.VULCAN_LIBRARY_DELETED_TYPE = 'cclibraries.service.LibraryDeleted';\n    AdobeLibraryConfig.prototype.VULCAN_COLLECTIONS_LOADED_TYPE = 'cclibraries.service.LibrariesLoaded';\n    AdobeLibraryConfig.prototype.VULCAN_COLLECTIONS_UNLOADED_TYPE = 'cclibraries.service.LibrariesUnloaded';\n\n    // Loading any user-defined parameters\n    AdobeLibraryConfig.prototype.setParameter = function (key, value) {\n        if (configurableParams.indexOf(key) === -1) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Parameter not configurable');\n        }\n        if (key === 'SYNC_POLICY' && this.VALID_SYNC_POLICIES.indexOf(value) === -1) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid value for SYNC_POLICY');\n        }\n        if (key === 'POLL_INTERVAL') {\n            // Don't allow people to set the polling interval shorter than 1 minute\n            value = Math.max(1, value);\n        }\n\n        this[key] = value;\n    };\n\n\n    return new AdobeLibraryConfig();\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryMimeTypeUtils\n * @classdesc\n * Utility functions for converting between extensions and mime types\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryMimeTypeUtils',['require','exports','module'],function (require, exports, module) {\n    'use strict';\n\n    // Static object\n    var AdobeLibraryMimeTypeUtils = {};\n\n\n    /**\n        Constants\n    **/\n\n    var mimeTypeMap = {\n        'application/andrew-inset': ['ez'],\n        'application/applixware': ['aw'],\n        'application/atom+xml': ['atom'],\n        'application/atomcat+xml': ['atomcat'],\n        'application/atomsvc+xml': ['atomsvc'],\n        'application/ccxml+xml': ['ccxml'],\n        'application/cdmi-capability': ['cdmia'],\n        'application/cdmi-container': ['cdmic'],\n        'application/cdmi-domain': ['cdmid'],\n        'application/cdmi-object': ['cdmio'],\n        'application/cdmi-queue': ['cdmiq'],\n        'application/cu-seeme': ['cu'],\n        'application/davmount+xml': ['davmount'],\n        'application/docbook+xml': ['dbk'],\n        'application/dssc+der': ['dssc'],\n        'application/dssc+xml': ['xdssc'],\n        'application/ecmascript': ['ecma'],\n        'application/emma+xml': ['emma'],\n        'application/epub+zip': ['epub'],\n        'application/exi': ['exi'],\n        'application/font-tdpfr': ['pfr'],\n        'application/gml+xml': ['gml'],\n        'application/gpx+xml': ['gpx'],\n        'application/gxf': ['gxf'],\n        'application/hyperstudio': ['stk'],\n        'application/illustrator': ['ai'],\n        'application/inkml+xml': ['ink', 'inkml'],\n        'application/ipfix': ['ipfix'],\n        'application/java-archive': ['jar'],\n        'application/java-serialized-object': ['ser'],\n        'application/java-vm': ['class'],\n        'application/javascript': ['js'],\n        'application/json': ['json'],\n        'application/jsonml+json': ['jsonml'],\n        'application/lost+xml': ['lostxml'],\n        'application/mac-binhex40': ['hqx'],\n        'application/mac-compactpro': ['cpt'],\n        'application/mads+xml': ['mads'],\n        'application/marc': ['mrc'],\n        'application/marcxml+xml': ['mrcx'],\n        'application/mathematica': ['ma', 'nb', 'mb'],\n        'application/mathml+xml': ['mathml'],\n        'application/mbox': ['mbox'],\n        'application/mediaservercontrol+xml': ['mscml'],\n        'application/metalink+xml': ['metalink'],\n        'application/metalink4+xml': ['meta4'],\n        'application/mets+xml': ['mets'],\n        'application/mods+xml': ['mods'],\n        'application/mp21': ['m21', 'mp21'],\n        'application/mp4': ['mp4s'],\n        'application/msword': ['doc', 'dot'],\n        'application/mxf': ['mxf'],\n        'application/octet-stream': ['bin', 'dms', 'lrf', 'mar', 'so', 'dist', 'distz', 'pkg', 'bpk', 'dump', 'elc', 'deploy'],\n        'application/oda': ['oda'],\n        'application/oebps-package+xml': ['opf'],\n        'application/ogg': ['ogx'],\n        'application/omdoc+xml': ['omdoc'],\n        'application/onenote': ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],\n        'application/oxps': ['oxps'],\n        'application/patch-ops-error+xml': ['xer'],\n        'application/pdf': ['pdf'],\n        'application/pgp-encrypted': ['pgp'],\n        'application/pgp-signature': ['asc', 'sig'],\n        'application/photoshop': ['psd'],\n        'application/photoshop.large': ['psb'],\n        'application/pics-rules': ['prf'],\n        'application/pkcs10': ['p10'],\n        'application/pkcs7-mime': ['p7m', 'p7c'],\n        'application/pkcs7-signature': ['p7s'],\n        'application/pkcs8': ['p8'],\n        'application/pkix-attr-cert': ['ac'],\n        'application/pkix-cert': ['cer'],\n        'application/pkix-crl': ['crl'],\n        'application/pkix-pkipath': ['pkipath'],\n        'application/pkixcmp': ['pki'],\n        'application/pls+xml': ['pls'],\n        'application/postscript': ['ai', 'eps', 'ps'],\n        'application/prs.cww': ['cww'],\n        'application/pskc+xml': ['pskcxml'],\n        'application/rdf+xml': ['rdf'],\n        'application/reginfo+xml': ['rif'],\n        'application/relax-ng-compact-syntax': ['rnc'],\n        'application/resource-lists+xml': ['rl'],\n        'application/resource-lists-diff+xml': ['rld'],\n        'application/rls-services+xml': ['rs'],\n        'application/rpki-ghostbusters': ['gbr'],\n        'application/rpki-manifest': ['mft'],\n        'application/rpki-roa': ['roa'],\n        'application/rsd+xml': ['rsd'],\n        'application/rss+xml': ['rss'],\n        'application/rtf': ['rtf'],\n        'application/sbml+xml': ['sbml'],\n        'application/scvp-cv-request': ['scq'],\n        'application/scvp-cv-response': ['scs'],\n        'application/scvp-vp-request': ['spq'],\n        'application/scvp-vp-response': ['spp'],\n        'application/sdp': ['sdp'],\n        'application/set-payment-initiation': ['setpay'],\n        'application/set-registration-initiation': ['setreg'],\n        'application/shf+xml': ['shf'],\n        'application/smil+xml': ['smi', 'smil'],\n        'application/sparql-query': ['rq'],\n        'application/sparql-results+xml': ['srx'],\n        'application/srgs': ['gram'],\n        'application/srgs+xml': ['grxml'],\n        'application/sru+xml': ['sru'],\n        'application/ssdl+xml': ['ssdl'],\n        'application/ssml+xml': ['ssml'],\n        'application/tei+xml': ['tei', 'teicorpus'],\n        'application/thraud+xml': ['tfi'],\n        'application/timestamped-data': ['tsd'],\n        'application/vnd.3gpp.pic-bw-large': ['plb'],\n        'application/vnd.3gpp.pic-bw-small': ['psb'],\n        'application/vnd.3gpp.pic-bw-var': ['pvb'],\n        'application/vnd.3gpp2.tcap': ['tcap'],\n        'application/vnd.3m.post-it-notes': ['pwn'],\n        'application/vnd.accpac.simply.aso': ['aso'],\n        'application/vnd.accpac.simply.imp': ['imp'],\n        'application/vnd.acucobol': ['acu'],\n        'application/vnd.acucorp': ['atc', 'acutc'],\n        'application/vnd.adobe.air-application-installer-package+zip': ['air'],\n        'application/vnd.adobe.characterstyle+json': ['style'],\n        'application/vnd.adobe.characterstyle+snippet': ['idms'],\n        'application/vnd.adobe.charts+zip': ['zip'],\n        'application/vnd.adobe.color+json': ['ase'],\n        'application/vnd.adobe.colortheme+json': ['ase'],\n        'application/vnd.adobe.cube+txt': ['cube'],\n        'application/vnd.adobe.formscentral.fcdt': ['fcdt'],\n        'application/vnd.adobe.fxp': ['fxp', 'fxpl'],\n        'application/vnd.adobe.indesign-idms': ['idms'],\n        'application/vnd.adobe.layerstyle': ['asl'],\n        'application/vnd.adobe.look+xml': ['look'],\n        'application/vnd.adobe.muse-collection': ['muse'],\n        'application/vnd.adobe.paragraphstyle+json': ['style'],\n        'application/vnd.adobe.paragraphstyle+snippet': ['idms'],\n        'application/vnd.adobe.ribbon.brush+zip': ['brush'],\n        'application/vnd.adobe.scatter.brush+zip':  ['brush'],\n        'application/vnd.adobe.vector.brush+zip': ['brush'],\n        'application/vnd.adobe.xdp+xml': ['xdp'],\n        'application/vnd.adobe.xfdf': ['xfdf'],\n        'application/vnd.ahead.space': ['ahead'],\n        'application/vnd.airzip.filesecure.azf': ['azf'],\n        'application/vnd.airzip.filesecure.azs': ['azs'],\n        'application/vnd.amazon.ebook': ['azw'],\n        'application/vnd.americandynamics.acc': ['acc'],\n        'application/vnd.amiga.ami': ['ami'],\n        'application/vnd.android.package-archive': ['apk'],\n        'application/vnd.anser-web-certificate-issue-initiation': ['cii'],\n        'application/vnd.anser-web-funds-transfer-initiation': ['fti'],\n        'application/vnd.antix.game-component': ['atx'],\n        'application/vnd.apple.installer+xml': ['mpkg'],\n        'application/vnd.apple.mpegurl': ['m3u8'],\n        'application/vnd.aristanetworks.swi': ['swi'],\n        'application/vnd.astraea-software.iota': ['iota'],\n        'application/vnd.audiograph': ['aep'],\n        'application/vnd.blueice.multipass': ['mpm'],\n        'application/vnd.bmi': ['bmi'],\n        'application/vnd.businessobjects': ['rep'],\n        'application/vnd.chemdraw+xml': ['cdxml'],\n        'application/vnd.chipnuts.karaoke-mmd': ['mmd'],\n        'application/vnd.cinderella': ['cdy'],\n        'application/vnd.claymore': ['cla'],\n        'application/vnd.cloanto.rp9': ['rp9'],\n        'application/vnd.clonk.c4group': ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],\n        'application/vnd.cluetrust.cartomobile-config': ['c11amc'],\n        'application/vnd.cluetrust.cartomobile-config-pkg': ['c11amz'],\n        'application/vnd.commonspace': ['csp'],\n        'application/vnd.contact.cmsg': ['cdbcmsg'],\n        'application/vnd.cosmocaller': ['cmc'],\n        'application/vnd.crick.clicker': ['clkx'],\n        'application/vnd.crick.clicker.keyboard': ['clkk'],\n        'application/vnd.crick.clicker.palette': ['clkp'],\n        'application/vnd.crick.clicker.template': ['clkt'],\n        'application/vnd.crick.clicker.wordbank': ['clkw'],\n        'application/vnd.criticaltools.wbs+xml': ['wbs'],\n        'application/vnd.ctc-posml': ['pml'],\n        'application/vnd.cups-ppd': ['ppd'],\n        'application/vnd.curl.car': ['car'],\n        'application/vnd.curl.pcurl': ['pcurl'],\n        'application/vnd.dart': ['dart'],\n        'application/vnd.data-vision.rdz': ['rdz'],\n        'application/vnd.dece.data': ['uvf', 'uvvf', 'uvd', 'uvvd'],\n        'application/vnd.dece.ttml+xml': ['uvt', 'uvvt'],\n        'application/vnd.dece.unspecified': ['uvx', 'uvvx'],\n        'application/vnd.dece.zip': ['uvz', 'uvvz'],\n        'application/vnd.denovo.fcselayout-link': ['fe_launch'],\n        'application/vnd.dna': ['dna'],\n        'application/vnd.dolby.mlp': ['mlp'],\n        'application/vnd.dpgraph': ['dpg'],\n        'application/vnd.dreamfactory': ['dfac'],\n        'application/vnd.ds-keypoint': ['kpxx'],\n        'application/vnd.dvb.ait': ['ait'],\n        'application/vnd.dvb.service': ['svc'],\n        'application/vnd.dynageo': ['geo'],\n        'application/vnd.ecowin.chart': ['mag'],\n        'application/vnd.enliven': ['nml'],\n        'application/vnd.epson.esf': ['esf'],\n        'application/vnd.epson.msf': ['msf'],\n        'application/vnd.epson.quickanime': ['qam'],\n        'application/vnd.epson.salt': ['slt'],\n        'application/vnd.epson.ssf': ['ssf'],\n        'application/vnd.eszigno3+xml': ['es3', 'et3'],\n        'application/vnd.ezpix-album': ['ez2'],\n        'application/vnd.ezpix-package': ['ez3'],\n        'application/vnd.fdf': ['fdf'],\n        'application/vnd.fdsn.mseed': ['mseed'],\n        'application/vnd.fdsn.seed': ['seed', 'dataless'],\n        'application/vnd.flographit': ['gph'],\n        'application/vnd.fluxtime.clip': ['ftc'],\n        'application/vnd.framemaker': ['fm', 'frame', 'maker', 'book'],\n        'application/vnd.frogans.fnc': ['fnc'],\n        'application/vnd.frogans.ltf': ['ltf'],\n        'application/vnd.fsc.weblaunch': ['fsc'],\n        'application/vnd.fujitsu.oasys': ['oas'],\n        'application/vnd.fujitsu.oasys2': ['oa2'],\n        'application/vnd.fujitsu.oasys3': ['oa3'],\n        'application/vnd.fujitsu.oasysgp': ['fg5'],\n        'application/vnd.fujitsu.oasysprs': ['bh2'],\n        'application/vnd.fujixerox.ddd': ['ddd'],\n        'application/vnd.fujixerox.docuworks': ['xdw'],\n        'application/vnd.fujixerox.docuworks.binder': ['xbd'],\n        'application/vnd.fuzzysheet': ['fzs'],\n        'application/vnd.genomatix.tuxedo': ['txd'],\n        'application/vnd.geogebra.file': ['ggb'],\n        'application/vnd.geogebra.tool': ['ggt'],\n        'application/vnd.geometry-explorer': ['gex', 'gre'],\n        'application/vnd.geonext': ['gxt'],\n        'application/vnd.geoplan': ['g2w'],\n        'application/vnd.geospace': ['g3w'],\n        'application/vnd.gmx': ['gmx'],\n        'application/vnd.google-earth.kml+xml': ['kml'],\n        'application/vnd.google-earth.kmz': ['kmz'],\n        'application/vnd.grafeq': ['gqf', 'gqs'],\n        'application/vnd.groove-account': ['gac'],\n        'application/vnd.groove-help': ['ghf'],\n        'application/vnd.groove-identity-message': ['gim'],\n        'application/vnd.groove-injector': ['grv'],\n        'application/vnd.groove-tool-message': ['gtm'],\n        'application/vnd.groove-tool-template': ['tpl'],\n        'application/vnd.groove-vcard': ['vcg'],\n        'application/vnd.hal+xml': ['hal'],\n        'application/vnd.handheld-entertainment+xml': ['zmm'],\n        'application/vnd.hbci': ['hbci'],\n        'application/vnd.hhe.lesson-player': ['les'],\n        'application/vnd.hp-hpgl': ['hpgl'],\n        'application/vnd.hp-hpid': ['hpid'],\n        'application/vnd.hp-hps': ['hps'],\n        'application/vnd.hp-jlyt': ['jlt'],\n        'application/vnd.hp-pcl': ['pcl'],\n        'application/vnd.hp-pclxl': ['pclxl'],\n        'application/vnd.ibm.minipay': ['mpy'],\n        'application/vnd.ibm.modcap': ['afp', 'listafp', 'list3820'],\n        'application/vnd.ibm.rights-management': ['irm'],\n        'application/vnd.ibm.secure-container': ['sc'],\n        'application/vnd.iccprofile': ['icc', 'icm'],\n        'application/vnd.igloader': ['igl'],\n        'application/vnd.immervision-ivp': ['ivp'],\n        'application/vnd.immervision-ivu': ['ivu'],\n        'application/vnd.insors.igm': ['igm'],\n        'application/vnd.intercon.formnet': ['xpw', 'xpx'],\n        'application/vnd.intergeo': ['i2g'],\n        'application/vnd.intu.qbo': ['qbo'],\n        'application/vnd.intu.qfx': ['qfx'],\n        'application/vnd.ipunplugged.rcprofile': ['rcprofile'],\n        'application/vnd.irepository.package+xml': ['irp'],\n        'application/vnd.is-xpr': ['xpr'],\n        'application/vnd.isac.fcs': ['fcs'],\n        'application/vnd.jam': ['jam'],\n        'application/vnd.jcp.javame.midlet-rms': ['rms'],\n        'application/vnd.jisp': ['jisp'],\n        'application/vnd.joost.joda-archive': ['joda'],\n        'application/vnd.kahootz': ['ktz', 'ktr'],\n        'application/vnd.kde.karbon': ['karbon'],\n        'application/vnd.kde.kchart': ['chrt'],\n        'application/vnd.kde.kformula': ['kfo'],\n        'application/vnd.kde.kivio': ['flw'],\n        'application/vnd.kde.kontour': ['kon'],\n        'application/vnd.kde.kpresenter': ['kpr', 'kpt'],\n        'application/vnd.kde.kspread': ['ksp'],\n        'application/vnd.kde.kword': ['kwd', 'kwt'],\n        'application/vnd.kenameaapp': ['htke'],\n        'application/vnd.kidspiration': ['kia'],\n        'application/vnd.kinar': ['kne', 'knp'],\n        'application/vnd.koan': ['skp', 'skd', 'skt', 'skm'],\n        'application/vnd.kodak-descriptor': ['sse'],\n        'application/vnd.las.las+xml': ['lasxml'],\n        'application/vnd.llamagraphics.life-balance.desktop': ['lbd'],\n        'application/vnd.llamagraphics.life-balance.exchange+xml': ['lbe'],\n        'application/vnd.lotus-1-2-3': ['123'],\n        'application/vnd.lotus-approach': ['apr'],\n        'application/vnd.lotus-freelance': ['pre'],\n        'application/vnd.lotus-notes': ['nsf'],\n        'application/vnd.lotus-organizer': ['org'],\n        'application/vnd.lotus-screencam': ['scm'],\n        'application/vnd.lotus-wordpro': ['lwp'],\n        'application/vnd.macports.portpkg': ['portpkg'],\n        'application/vnd.mcd': ['mcd'],\n        'application/vnd.medcalcdata': ['mc1'],\n        'application/vnd.mediastation.cdkey': ['cdkey'],\n        'application/vnd.mfer': ['mwf'],\n        'application/vnd.mfmp': ['mfm'],\n        'application/vnd.micrografx.flo': ['flo'],\n        'application/vnd.micrografx.igx': ['igx'],\n        'application/vnd.mif': ['mif'],\n        'application/vnd.mobius.daf': ['daf'],\n        'application/vnd.mobius.dis': ['dis'],\n        'application/vnd.mobius.mbk': ['mbk'],\n        'application/vnd.mobius.mqy': ['mqy'],\n        'application/vnd.mobius.msl': ['msl'],\n        'application/vnd.mobius.plc': ['plc'],\n        'application/vnd.mobius.txf': ['txf'],\n        'application/vnd.mophun.application': ['mpn'],\n        'application/vnd.mophun.certificate': ['mpc'],\n        'application/vnd.mozilla.xul+xml': ['xul'],\n        'application/vnd.ms-artgalry': ['cil'],\n        'application/vnd.ms-cab-compressed': ['cab'],\n        'application/vnd.ms-excel': ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],\n        'application/vnd.ms-excel.addin.macroenabled.12': ['xlam'],\n        'application/vnd.ms-excel.sheet.binary.macroenabled.12': ['xlsb'],\n        'application/vnd.ms-excel.sheet.macroenabled.12': ['xlsm'],\n        'application/vnd.ms-excel.template.macroenabled.12': ['xltm'],\n        'application/vnd.ms-fontobject': ['eot'],\n        'application/vnd.ms-htmlhelp': ['chm'],\n        'application/vnd.ms-ims': ['ims'],\n        'application/vnd.ms-lrm': ['lrm'],\n        'application/vnd.ms-officetheme': ['thmx'],\n        'application/vnd.ms-pki.seccat': ['cat'],\n        'application/vnd.ms-pki.stl': ['stl'],\n        'application/vnd.ms-powerpoint': ['ppt', 'pps', 'pot'],\n        'application/vnd.ms-powerpoint.addin.macroenabled.12': ['ppam'],\n        'application/vnd.ms-powerpoint.presentation.macroenabled.12': ['pptm'],\n        'application/vnd.ms-powerpoint.slide.macroenabled.12': ['sldm'],\n        'application/vnd.ms-powerpoint.slideshow.macroenabled.12': ['ppsm'],\n        'application/vnd.ms-powerpoint.template.macroenabled.12': ['potm'],\n        'application/vnd.ms-project': ['mpp', 'mpt'],\n        'application/vnd.ms-word.document.macroenabled.12': ['docm'],\n        'application/vnd.ms-word.template.macroenabled.12': ['dotm'],\n        'application/vnd.ms-works': ['wps', 'wks', 'wcm', 'wdb'],\n        'application/vnd.ms-wpl': ['wpl'],\n        'application/vnd.ms-xpsdocument': ['xps'],\n        'application/vnd.mseq': ['mseq'],\n        'application/vnd.musician': ['mus'],\n        'application/vnd.muvee.style': ['msty'],\n        'application/vnd.mynfc': ['taglet'],\n        'application/vnd.neurolanguage.nlu': ['nlu'],\n        'application/vnd.nitf': ['ntf', 'nitf'],\n        'application/vnd.noblenet-directory': ['nnd'],\n        'application/vnd.noblenet-sealer': ['nns'],\n        'application/vnd.noblenet-web': ['nnw'],\n        'application/vnd.nokia.n-gage.data': ['ngdat'],\n        'application/vnd.nokia.radio-preset': ['rpst'],\n        'application/vnd.nokia.radio-presets': ['rpss'],\n        'application/vnd.novadigm.edm': ['edm'],\n        'application/vnd.novadigm.edx': ['edx'],\n        'application/vnd.novadigm.ext': ['ext'],\n        'application/vnd.oasis.opendocument.chart': ['odc'],\n        'application/vnd.oasis.opendocument.chart-template': ['otc'],\n        'application/vnd.oasis.opendocument.database': ['odb'],\n        'application/vnd.oasis.opendocument.formula': ['odf'],\n        'application/vnd.oasis.opendocument.formula-template': ['odft'],\n        'application/vnd.oasis.opendocument.graphics': ['odg'],\n        'application/vnd.oasis.opendocument.graphics-template': ['otg'],\n        'application/vnd.oasis.opendocument.image': ['odi'],\n        'application/vnd.oasis.opendocument.image-template': ['oti'],\n        'application/vnd.oasis.opendocument.presentation': ['odp'],\n        'application/vnd.oasis.opendocument.presentation-template': ['otp'],\n        'application/vnd.oasis.opendocument.spreadsheet': ['ods'],\n        'application/vnd.oasis.opendocument.spreadsheet-template': ['ots'],\n        'application/vnd.oasis.opendocument.text': ['odt'],\n        'application/vnd.oasis.opendocument.text-master': ['odm'],\n        'application/vnd.oasis.opendocument.text-template': ['ott'],\n        'application/vnd.oasis.opendocument.text-web': ['oth'],\n        'application/vnd.olpc-sugar': ['xo'],\n        'application/vnd.oma.dd2+xml': ['dd2'],\n        'application/vnd.openofficeorg.extension': ['oxt'],\n        'application/vnd.openxmlformats-officedocument.presentationml.presentation': ['pptx'],\n        'application/vnd.openxmlformats-officedocument.presentationml.slide': ['sldx'],\n        'application/vnd.openxmlformats-officedocument.presentationml.slideshow': ['ppsx'],\n        'application/vnd.openxmlformats-officedocument.presentationml.template': ['potx'],\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['xlsx'],\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.template': ['xltx'],\n        'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['docx'],\n        'application/vnd.openxmlformats-officedocument.wordprocessingml.template': ['dotx'],\n        'application/vnd.osgeo.mapguide.package': ['mgp'],\n        'application/vnd.osgi.dp': ['dp'],\n        'application/vnd.osgi.subsystem': ['esa'],\n        'application/vnd.palm': ['pdb', 'pqa', 'oprc'],\n        'application/vnd.pawaafile': ['paw'],\n        'application/vnd.pg.format': ['str'],\n        'application/vnd.pg.osasli': ['ei6'],\n        'application/vnd.picsel': ['efif'],\n        'application/vnd.pmi.widget': ['wg'],\n        'application/vnd.pocketlearn': ['plf'],\n        'application/vnd.powerbuilder6': ['pbd'],\n        'application/vnd.previewsystems.box': ['box'],\n        'application/vnd.proteus.magazine': ['mgz'],\n        'application/vnd.publishare-delta-tree': ['qps'],\n        'application/vnd.pvi.ptid1': ['ptid'],\n        'application/vnd.quark.quarkxpress': ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb'],\n        'application/vnd.realvnc.bed': ['bed'],\n        'application/vnd.recordare.musicxml': ['mxl'],\n        'application/vnd.recordare.musicxml+xml': ['musicxml'],\n        'application/vnd.rig.cryptonote': ['cryptonote'],\n        'application/vnd.rim.cod': ['cod'],\n        'application/vnd.rn-realmedia': ['rm'],\n        'application/vnd.rn-realmedia-vbr': ['rmvb'],\n        'application/vnd.route66.link66+xml': ['link66'],\n        'application/vnd.sailingtracker.track': ['st'],\n        'application/vnd.seemail': ['see'],\n        'application/vnd.sema': ['sema'],\n        'application/vnd.semd': ['semd'],\n        'application/vnd.semf': ['semf'],\n        'application/vnd.shana.informed.formdata': ['ifm'],\n        'application/vnd.shana.informed.formtemplate': ['itp'],\n        'application/vnd.shana.informed.interchange': ['iif'],\n        'application/vnd.shana.informed.package': ['ipk'],\n        'application/vnd.simtech-mindmapper': ['twd', 'twds'],\n        'application/vnd.smaf': ['mmf'],\n        'application/vnd.smart.teacher': ['teacher'],\n        'application/vnd.solent.sdkm+xml': ['sdkm', 'sdkd'],\n        'application/vnd.spotfire.dxp': ['dxp'],\n        'application/vnd.spotfire.sfs': ['sfs'],\n        'application/vnd.stardivision.calc': ['sdc'],\n        'application/vnd.stardivision.draw': ['sda'],\n        'application/vnd.stardivision.impress': ['sdd'],\n        'application/vnd.stardivision.math': ['smf'],\n        'application/vnd.stardivision.writer': ['sdw', 'vor'],\n        'application/vnd.stardivision.writer-global': ['sgl'],\n        'application/vnd.stepmania.package': ['smzip'],\n        'application/vnd.stepmania.stepchart': ['sm'],\n        'application/vnd.sun.xml.calc': ['sxc'],\n        'application/vnd.sun.xml.calc.template': ['stc'],\n        'application/vnd.sun.xml.draw': ['sxd'],\n        'application/vnd.sun.xml.draw.template': ['std'],\n        'application/vnd.sun.xml.impress': ['sxi'],\n        'application/vnd.sun.xml.impress.template': ['sti'],\n        'application/vnd.sun.xml.math': ['sxm'],\n        'application/vnd.sun.xml.writer': ['sxw'],\n        'application/vnd.sun.xml.writer.global': ['sxg'],\n        'application/vnd.sun.xml.writer.template': ['stw'],\n        'application/vnd.sus-calendar': ['sus', 'susp'],\n        'application/vnd.svd': ['svd'],\n        'application/vnd.symbian.install': ['sis', 'sisx'],\n        'application/vnd.syncml+xml': ['xsm'],\n        'application/vnd.syncml.dm+wbxml': ['bdm'],\n        'application/vnd.syncml.dm+xml': ['xdm'],\n        'application/vnd.tao.intent-module-archive': ['tao'],\n        'application/vnd.tcpdump.pcap': ['pcap', 'cap', 'dmp'],\n        'application/vnd.tmobile-livetv': ['tmo'],\n        'application/vnd.trid.tpt': ['tpt'],\n        'application/vnd.triscape.mxs': ['mxs'],\n        'application/vnd.trueapp': ['tra'],\n        'application/vnd.ufdl': ['ufd', 'ufdl'],\n        'application/vnd.uiq.theme': ['utz'],\n        'application/vnd.umajin': ['umj'],\n        'application/vnd.unity': ['unityweb'],\n        'application/vnd.uoml+xml': ['uoml'],\n        'application/vnd.vcx': ['vcx'],\n        'application/vnd.visio': ['vsd', 'vst', 'vss', 'vsw'],\n        'application/vnd.visionary': ['vis'],\n        'application/vnd.vsf': ['vsf'],\n        'application/vnd.wap.wbxml': ['wbxml'],\n        'application/vnd.wap.wmlc': ['wmlc'],\n        'application/vnd.wap.wmlscriptc': ['wmlsc'],\n        'application/vnd.webturbo': ['wtb'],\n        'application/vnd.wolfram.player': ['nbp'],\n        'application/vnd.wordperfect': ['wpd'],\n        'application/vnd.wqd': ['wqd'],\n        'application/vnd.wt.stf': ['stf'],\n        'application/vnd.xara': ['xar'],\n        'application/vnd.xfdl': ['xfdl'],\n        'application/vnd.yamaha.hv-dic': ['hvd'],\n        'application/vnd.yamaha.hv-script': ['hvs'],\n        'application/vnd.yamaha.hv-voice': ['hvp'],\n        'application/vnd.yamaha.openscoreformat': ['osf'],\n        'application/vnd.yamaha.openscoreformat.osfpvg+xml': ['osfpvg'],\n        'application/vnd.yamaha.smaf-audio': ['saf'],\n        'application/vnd.yamaha.smaf-phrase': ['spf'],\n        'application/vnd.yellowriver-custom-menu': ['cmp'],\n        'application/vnd.zul': ['zir', 'zirz'],\n        'application/vnd.zzazz.deck+xml': ['zaz'],\n        'application/voicexml+xml': ['vxml'],\n        'application/widget': ['wgt'],\n        'application/winhlp': ['hlp'],\n        'application/wsdl+xml': ['wsdl'],\n        'application/wspolicy+xml': ['wspolicy'],\n        'application/x-7z-compressed': ['7z'],\n        'application/x-abiword': ['abw'],\n        'application/x-ace-compressed': ['ace'],\n        'application/x-apple-diskimage': ['dmg'],\n        'application/x-authorware-bin': ['aab', 'x32', 'u32', 'vox'],\n        'application/x-authorware-map': ['aam'],\n        'application/x-authorware-seg': ['aas'],\n        'application/x-bcpio': ['bcpio'],\n        'application/x-bittorrent': ['torrent'],\n        'application/x-blorb': ['blb', 'blorb'],\n        'application/x-bzip': ['bz'],\n        'application/x-bzip2': ['bz2', 'boz'],\n        'application/x-cbr': ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],\n        'application/x-cdlink': ['vcd'],\n        'application/x-cfs-compressed': ['cfs'],\n        'application/x-chat': ['chat'],\n        'application/x-chess-pgn': ['pgn'],\n        'application/x-conference': ['nsc'],\n        'application/x-cpio': ['cpio'],\n        'application/x-csh': ['csh'],\n        'application/x-debian-package': ['deb', 'udeb'],\n        'application/x-dgc-compressed': ['dgc'],\n        'application/x-director': ['dir', 'dcr', 'dxr', 'cst', 'cct', 'cxt', 'w3d', 'fgd', 'swa'],\n        'application/x-doom': ['wad'],\n        'application/x-dtbncx+xml': ['ncx'],\n        'application/x-dtbook+xml': ['dtb'],\n        'application/x-dtbresource+xml': ['res'],\n        'application/x-dvi': ['dvi'],\n        'application/x-envoy': ['evy'],\n        'application/x-eva': ['eva'],\n        'application/x-font-bdf': ['bdf'],\n        'application/x-font-ghostscript': ['gsf'],\n        'application/x-font-linux-psf': ['psf'],\n        'application/x-font-otf': ['otf'],\n        'application/x-font-pcf': ['pcf'],\n        'application/x-font-snf': ['snf'],\n        'application/x-font-ttf': ['ttf', 'ttc'],\n        'application/x-font-type1': ['pfa', 'pfb', 'pfm', 'afm'],\n        'application/font-woff': ['woff'],\n        'application/x-freearc': ['arc'],\n        'application/x-futuresplash': ['spl'],\n        'application/x-gca-compressed': ['gca'],\n        'application/x-glulx': ['ulx'],\n        'application/x-gnumeric': ['gnumeric'],\n        'application/x-gramps-xml': ['gramps'],\n        'application/x-gtar': ['gtar'],\n        'application/x-hdf': ['hdf'],\n        'application/x-install-instructions': ['install'],\n        'application/x-iso9660-image': ['iso'],\n        'application/x-java-jnlp-file': ['jnlp'],\n        'application/x-latex': ['latex'],\n        'application/x-lzh-compressed': ['lzh', 'lha'],\n        'application/x-mie': ['mie'],\n        'application/x-mobipocket-ebook': ['prc', 'mobi'],\n        'application/x-ms-application': ['application'],\n        'application/x-ms-shortcut': ['lnk'],\n        'application/x-ms-wmd': ['wmd'],\n        'application/x-ms-wmz': ['wmz'],\n        'application/x-ms-xbap': ['xbap'],\n        'application/x-msaccess': ['mdb'],\n        'application/x-msbinder': ['obd'],\n        'application/x-mscardfile': ['crd'],\n        'application/x-msclip': ['clp'],\n        'application/x-msdownload': ['exe', 'dll', 'com', 'bat', 'msi'],\n        'application/x-msmediaview': ['mvb', 'm13', 'm14'],\n        'application/x-msmetafile': ['wmf', 'wmz', 'emf', 'emz'],\n        'application/x-msmoney': ['mny'],\n        'application/x-mspublisher': ['pub'],\n        'application/x-msschedule': ['scd'],\n        'application/x-msterminal': ['trm'],\n        'application/x-mswrite': ['wri'],\n        'application/x-netcdf': ['nc', 'cdf'],\n        'application/x-nzb': ['nzb'],\n        'application/x-pkcs12': ['p12', 'pfx'],\n        'application/x-pkcs7-certificates': ['p7b', 'spc'],\n        'application/x-pkcs7-certreqresp': ['p7r'],\n        'application/x-rar-compressed': ['rar'],\n        'application/x-research-info-systems': ['ris'],\n        'application/x-sh': ['sh'],\n        'application/x-shar': ['shar'],\n        'application/x-shockwave-flash': ['swf'],\n        'application/x-silverlight-app': ['xap'],\n        'application/x-sql': ['sql'],\n        'application/x-stuffit': ['sit'],\n        'application/x-stuffitx': ['sitx'],\n        'application/x-subrip': ['srt'],\n        'application/x-sv4cpio': ['sv4cpio'],\n        'application/x-sv4crc': ['sv4crc'],\n        'application/x-t3vm-image': ['t3'],\n        'application/x-tads': ['gam'],\n        'application/x-tar': ['tar'],\n        'application/x-tcl': ['tcl'],\n        'application/x-tex': ['tex'],\n        'application/x-tex-tfm': ['tfm'],\n        'application/x-texinfo': ['texinfo', 'texi'],\n        'application/x-tgif': ['obj'],\n        'application/x-ustar': ['ustar'],\n        'application/x-wais-source': ['src'],\n        'application/x-x509-ca-cert': ['der', 'crt'],\n        'application/x-xfig': ['fig'],\n        'application/x-xliff+xml': ['xlf'],\n        'application/x-xpinstall': ['xpi'],\n        'application/x-xz': ['xz'],\n        'application/x-zmachine': ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],\n        'application/xaml+xml': ['xaml'],\n        'application/xcap-diff+xml': ['xdf'],\n        'application/xenc+xml': ['xenc'],\n        'application/xhtml+xml': ['xhtml', 'xht'],\n        'application/xml': ['xml', 'xsl'],\n        'application/xml-dtd': ['dtd'],\n        'application/xop+xml': ['xop'],\n        'application/xproc+xml': ['xpl'],\n        'application/xslt+xml': ['xslt'],\n        'application/xspf+xml': ['xspf'],\n        'application/xv+xml': ['mxml', 'xhvml', 'xvml', 'xvm'],\n        'application/yang': ['yang'],\n        'application/yin+xml': ['yin'],\n        'application/zip': ['zip'],\n        'audio/adpcm': ['adp'],\n        'audio/basic': ['au', 'snd'],\n        'audio/midi': ['mid', 'midi', 'kar', 'rmi'],\n        'audio/mp4': ['mp4a'],\n        'audio/mpeg': ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],\n        'audio/ogg': ['oga', 'ogg', 'spx'],\n        'audio/s3m': ['s3m'],\n        'audio/silk': ['sil'],\n        'audio/vnd.dece.audio': ['uva', 'uvva'],\n        'audio/vnd.digital-winds': ['eol'],\n        'audio/vnd.dra': ['dra'],\n        'audio/vnd.dts': ['dts'],\n        'audio/vnd.dts.hd': ['dtshd'],\n        'audio/vnd.lucent.voice': ['lvp'],\n        'audio/vnd.ms-playready.media.pya': ['pya'],\n        'audio/vnd.nuera.ecelp4800': ['ecelp4800'],\n        'audio/vnd.nuera.ecelp7470': ['ecelp7470'],\n        'audio/vnd.nuera.ecelp9600': ['ecelp9600'],\n        'audio/vnd.rip': ['rip'],\n        'audio/webm': ['weba'],\n        'audio/x-aac': ['aac'],\n        'audio/x-aiff': ['aif', 'aiff', 'aifc'],\n        'audio/x-caf': ['caf'],\n        'audio/x-flac': ['flac'],\n        'audio/x-matroska': ['mka'],\n        'audio/x-mpegurl': ['m3u'],\n        'audio/x-ms-wax': ['wax'],\n        'audio/x-ms-wma': ['wma'],\n        'audio/x-pn-realaudio': ['ram', 'ra'],\n        'audio/x-pn-realaudio-plugin': ['rmp'],\n        'audio/x-wav': ['wav'],\n        'audio/xm': ['xm'],\n        'chemical/x-cdx': ['cdx'],\n        'chemical/x-cif': ['cif'],\n        'chemical/x-cmdf': ['cmdf'],\n        'chemical/x-cml': ['cml'],\n        'chemical/x-csml': ['csml'],\n        'chemical/x-xyz': ['xyz'],\n        'image/bmp': ['bmp'],\n        'image/cgm': ['cgm'],\n        'image/g3fax': ['g3'],\n        'image/gif': ['gif'],\n        'image/ief': ['ief'],\n        'image/jpeg': ['jpeg', 'jpg', 'jpe'],\n        'image/jpg': ['jpg'],\n        'image/ktx': ['ktx'],\n        'image/png': ['png'],\n        'image/prs.btif': ['btif'],\n        'image/sgi': ['sgi'],\n        'image/svg+xml': ['svg', 'svgz'],\n        'image/tiff': ['tiff', 'tif'],\n        'image/vnd.adobe.photoshop': ['psd'],\n        'image/vnd.adobe.shape+svg': ['shape'],\n        'image/vnd.dece.graphic': ['uvi', 'uvvi', 'uvg', 'uvvg'],\n        'image/vnd.dvb.subtitle': ['sub'],\n        'image/vnd.djvu': ['djvu', 'djv'],\n        'image/vnd.dwg': ['dwg'],\n        'image/vnd.dxf': ['dxf'],\n        'image/vnd.fastbidsheet': ['fbs'],\n        'image/vnd.fpx': ['fpx'],\n        'image/vnd.fst': ['fst'],\n        'image/vnd.fujixerox.edmics-mmr': ['mmr'],\n        'image/vnd.fujixerox.edmics-rlc': ['rlc'],\n        'image/vnd.ms-modi': ['mdi'],\n        'image/vnd.ms-photo': ['wdp'],\n        'image/vnd.net-fpx': ['npx'],\n        'image/vnd.wap.wbmp': ['wbmp'],\n        'image/vnd.xiff': ['xif'],\n        'image/webp': ['webp'],\n        'image/x-3ds': ['3ds'],\n        'image/x-adobe-photoshop-brush': ['abr'],\n        'image/x-cmu-raster': ['ras'],\n        'image/x-cmx': ['cmx'],\n        'image/x-freehand': ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],\n        'image/x-icon': ['ico'],\n        'image/x-mrsid-image': ['sid'],\n        'image/x-pcx': ['pcx'],\n        'image/x-pict': ['pic', 'pct'],\n        'image/x-portable-anymap': ['pnm'],\n        'image/x-portable-bitmap': ['pbm'],\n        'image/x-portable-graymap': ['pgm'],\n        'image/x-portable-pixmap': ['ppm'],\n        'image/x-rgb': ['rgb'],\n        'image/x-tga': ['tga'],\n        'image/x-xbitmap': ['xbm'],\n        'image/x-xpixmap': ['xpm'],\n        'image/x-xwindowdump': ['xwd'],\n        'message/rfc822': ['eml', 'mime'],\n        'model/iges': ['igs', 'iges'],\n        'model/mesh': ['msh', 'mesh', 'silo'],\n        'model/vnd.collada+xml': ['dae'],\n        'model/vnd.dwf': ['dwf'],\n        'model/vnd.gdl': ['gdl'],\n        'model/vnd.gtw': ['gtw'],\n        'model/vnd.mts': ['mts'],\n        'model/vnd.vtu': ['vtu'],\n        'model/vrml': ['wrl', 'vrml'],\n        'model/x3d+binary': ['x3db', 'x3dbz'],\n        'model/x3d+vrml': ['x3dv', 'x3dvz'],\n        'model/x3d+xml': ['x3d', 'x3dz'],\n        'text/cache-manifest': ['appcache'],\n        'text/calendar': ['ics', 'ifb'],\n        'text/css': ['css'],\n        'text/csv': ['csv'],\n        'text/html': ['html', 'htm'],\n        'text/n3': ['n3'],\n        'text/plain': ['txt', 'text', 'conf', 'def', 'list', 'log', 'in'],\n        'text/prs.lines.tag': ['dsc'],\n        'text/richtext': ['rtx'],\n        'text/sgml': ['sgml', 'sgm'],\n        'text/tab-separated-values': ['tsv'],\n        'text/troff': ['t', 'tr', 'roff', 'man', 'me', 'ms'],\n        'text/turtle': ['ttl'],\n        'text/uri-list': ['uri', 'uris', 'urls'],\n        'text/vcard': ['vcard'],\n        'text/vnd.curl': ['curl'],\n        'text/vnd.curl.dcurl': ['dcurl'],\n        'text/vnd.curl.scurl': ['scurl'],\n        'text/vnd.curl.mcurl': ['mcurl'],\n        'text/vnd.dvb.subtitle': ['sub'],\n        'text/vnd.fly': ['fly'],\n        'text/vnd.fmi.flexstor': ['flx'],\n        'text/vnd.graphviz': ['gv'],\n        'text/vnd.in3d.3dml': ['3dml'],\n        'text/vnd.in3d.spot': ['spot'],\n        'text/vnd.sun.j2me.app-descriptor': ['jad'],\n        'text/vnd.wap.wml': ['wml'],\n        'text/vnd.wap.wmlscript': ['wmls'],\n        'text/x-asm': ['s', 'asm'],\n        'text/x-c': ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],\n        'text/x-fortran': ['f', 'for', 'f77', 'f90'],\n        'text/x-java-source': ['java'],\n        'text/x-opml': ['opml'],\n        'text/x-pascal': ['p', 'pas'],\n        'text/x-nfo': ['nfo'],\n        'text/x-setext': ['etx'],\n        'text/x-sfv': ['sfv'],\n        'text/x-uuencode': ['uu'],\n        'text/x-vcalendar': ['vcs'],\n        'text/x-vcard': ['vcf'],\n        'video/3gpp': ['3gp'],\n        'video/3gpp2': ['3g2'],\n        'video/h261': ['h261'],\n        'video/h263': ['h263'],\n        'video/h264': ['h264'],\n        'video/jpeg': ['jpgv'],\n        'video/jpm': ['jpm', 'jpgm'],\n        'video/mj2': ['mj2', 'mjp2'],\n        'video/mp4': ['mp4', 'mp4v', 'mpg4'],\n        'video/mpeg': ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],\n        'video/ogg': ['ogv'],\n        'video/quicktime': ['qt', 'mov'],\n        'video/vnd.dece.hd': ['uvh', 'uvvh'],\n        'video/vnd.dece.mobile': ['uvm', 'uvvm'],\n        'video/vnd.dece.pd': ['uvp', 'uvvp'],\n        'video/vnd.dece.sd': ['uvs', 'uvvs'],\n        'video/vnd.dece.video': ['uvv', 'uvvv'],\n        'video/vnd.dvb.file': ['dvb'],\n        'video/vnd.fvt': ['fvt'],\n        'video/vnd.mpegurl': ['mxu', 'm4u'],\n        'video/vnd.ms-playready.media.pyv': ['pyv'],\n        'video/vnd.uvvu.mp4': ['uvu', 'uvvu'],\n        'video/vnd.vivo': ['viv'],\n        'video/webm': ['webm'],\n        'video/x-f4v': ['f4v'],\n        'video/x-fli': ['fli'],\n        'video/x-flv': ['flv'],\n        'video/x-m4v': ['m4v'],\n        'video/x-matroska': ['mkv', 'mk3d', 'mks'],\n        'video/x-mng': ['mng'],\n        'video/x-ms-asf': ['asf', 'asx'],\n        'video/x-ms-vob': ['vob'],\n        'video/x-ms-wm': ['wm'],\n        'video/x-ms-wmv': ['wmv'],\n        'video/x-ms-wmx': ['wmx'],\n        'video/x-ms-wvx': ['wvx'],\n        'video/x-msvideo': ['avi'],\n        'video/x-sgi-movie': ['movie'],\n        'video/x-smv': ['smv'],\n        'x-conference/x-cooltalk': ['ice']\n    };\n\n    var extensionMap = {};\n\n    Object.keys(mimeTypeMap).forEach(function (mimeType) {\n        var extensions = mimeTypeMap[mimeType];\n        extensions.forEach(function (extension) {\n            extensionMap[extension] = extensionMap[extension] || [];\n            extensionMap[extension].push(mimeType);\n        });\n    });\n\n    function extensionForUnresolvedContentType(contentType) {\n        var matches = contentType.match(/application\\/x-adobe-libraries-(.+)/);\n        return matches ? [matches[1]] : [];\n    }\n\n    function contentTypeForUnresolvedExtension(extension) {\n        return [\"application/x-adobe-libraries-\" + extension];\n    }\n\n    /**\n        Public API\n    **/\n\n    AdobeLibraryMimeTypeUtils.getExtensions = function (mimeType) {\n        if (mimeType) {\n            return mimeTypeMap[mimeType.toLowerCase()] || extensionForUnresolvedContentType(mimeType.toLowerCase());\n        }\n        return [];\n    };\n\n    AdobeLibraryMimeTypeUtils.getMimeTypes = function (extension) {\n        if (extension) {\n            return extensionMap[extension.toLowerCase()] || contentTypeForUnresolvedExtension(extension.toLowerCase());\n        }\n        return [];\n    };\n\n\n    return AdobeLibraryMimeTypeUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define */\n\n/**\n * @class AdobeLibraryManifestUtils\n * @classdesc\n * Utility functions for manifest and DCX operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryManifestUtils',['require','exports','module','../components/dcx-js/src/AdobeDCX','../components/dcx-js/src/AdobeDCXError','../AdobeLibraryConfig','../AdobeLibraryServices','../AdobeLibraryError'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeDCX = require('../components/dcx-js/src/AdobeDCX');\n    var AdobeDCXError = require('../components/dcx-js/src/AdobeDCXError');\n    var AdobeLibraryConfig = require('../AdobeLibraryConfig');\n    var AdobeLibraryServices = require('../AdobeLibraryServices');\n    var AdobeLibraryError = require('../AdobeLibraryError');\n\n\n    // Static object\n    var AdobeLibraryManifestUtils = {};\n\n\n    /**\n        Constants\n    **/\n\n    var SUPERTYPE_MAP = {\n    };\n\n\n    /**\n        Public API\n    **/\n\n    AdobeLibraryManifestUtils.isCompatibleType = function (requestedType, actualType) {\n        return requestedType === actualType || requestedType === SUPERTYPE_MAP[actualType];\n    };\n\n    AdobeLibraryManifestUtils.validateLibraryId = function (libraryId, isPublic) {\n        if (isPublic) {\n            // Public library ids are generated by the storage service. The only guarantees they provide are that the\n            // id is at least 30 characters in length, and contains only alpha-numerical characters and dashes)\n            if (libraryId && libraryId.length >= 30 && libraryId.match(/^[0-9A-Z\\-]+$/i)) {\n                return true;\n            }\n\n        } else {\n            // Private libraries must follow the standard guid format\n            if (libraryId && libraryId.match(/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i)) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    AdobeLibraryManifestUtils.validateLibrary = function (dcxComposite) {\n        var version = dcxComposite.current && dcxComposite.current.rootNode.getValue(AdobeLibraryConfig.VERSION_KEY);\n        if (version !== AdobeLibraryConfig.VERSION) {\n            return false;\n        }\n        return true;\n    };\n\n    AdobeLibraryManifestUtils.areManifestsEqual = function (manifest1, manifest2) {\n        try {\n            var data1 = JSON.parse(manifest1);\n            var data2 = JSON.parse(manifest2);\n            delete data1['manifest-format-version'];\n            delete data2['manifest-format-version'];\n            if (JSON.stringify(data1) === JSON.stringify(data2)) {\n                return true;\n            }\n        } catch (ignore) {\n        }\n        return false;\n    };\n\n    AdobeLibraryManifestUtils.getDCXKey = function (namespace, key) {\n        if (!namespace || !(typeof namespace === 'string' || namespace instanceof String) || namespace === '') {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid namespace');\n        }\n        if (!key || !(typeof key === 'string' || key instanceof String) || key === '') {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid key');\n        }\n        return namespace + '#' + key;\n    };\n\n    // Gets all custom data on a dcx node or component\n    AdobeLibraryManifestUtils.getCustomDCXData = function (dcxElement) {\n        var keys = dcxElement.getCustomKeys();\n\n        var customData = [];\n\n        keys.forEach(function (key) {\n            // Copy the key/value over if it's namespaced, and not a library#... key\n\n            var splitKey = key.split('#');\n            var isNamespacedKey = splitKey.length >= 2;\n            if (isNamespacedKey) {\n                // Check that all the components of the namespace are non-empty\n                splitKey.forEach(function (split) {\n                    if (split === '') {\n                        isNamespacedKey = false;\n                    }\n                });\n            }\n            var isLibraryKey = key.indexOf(AdobeLibraryConfig.DL_PREFIX) === 0;\n\n            if (isNamespacedKey && !isLibraryKey) {\n                customData.push({\n                    namespace: splitKey.shift(),\n                    key: splitKey.join('#'),\n                    value: dcxElement.getValue(key)\n                });\n            }\n        });\n\n        return customData;\n    };\n\n    // Copies custom data between two dcx nodes or components (from dcxElement1 to dcxElement2).\n    // This is any data you set on a representation by calling setValue()\n    AdobeLibraryManifestUtils.copyCustomDCXData = function (dcxElement1, dcxElement2) {\n        var customData = AdobeLibraryManifestUtils.getCustomDCXData(dcxElement1);\n\n        customData.forEach(function (data) {\n            dcxElement2.setValue(AdobeLibraryManifestUtils.getDCXKey(data.namespace, data.key), data.value);\n        });\n\n        // Also copy across the order field\n        var order = dcxElement1.getValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY);\n        if (order) {\n            dcxElement2.setValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY, order);\n        }\n    };\n\n    // Use this in all methods/properties of the collection/library/element/representation classes, to prevent\n    // you from modifying objects that have already been deleted\n    AdobeLibraryManifestUtils.checkDeletedState = function (object, callback) {\n        if (object.deletedLocally) {\n            if (callback) {\n                // Asynchronous case calls the callback - you need to remember to return\n                callback(new AdobeLibraryError(AdobeLibraryError.DELETED_LOCALLY, 'deleted/orphan object'));\n                return true;\n            }\n\n            // Synchronous case just throws an exception\n            throw new AdobeLibraryError(AdobeLibraryError.DELETED_LOCALLY, 'deleted/orphan object');\n        }\n\n        return false;\n    };\n\n    AdobeLibraryManifestUtils.checkEncoding = function (encoding, supportedEncodings, callback) {\n        if (supportedEncodings.indexOf(encoding) === -1) {\n            var supported = supportedEncodings.join(', ');\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Unsupported encoding. Supported encodings are: ' + supported));\n            return false;\n        }\n        return true;\n    };\n\n    AdobeLibraryManifestUtils.sortRepresentations = function (representations) {\n        if (representations.length < 2) {\n            return;\n        }\n\n        // This uses a simple bubble sort, so we can ensure the sort is stable\n        // If representation order is not specified, this will not alter the order of the array\n        // Note that you only have a few representations per element at most, so it doesn't matter that this is O(n^2)\n        var changed, i, r1, r2;\n        while (true) {\n            changed = false;\n            for (i = 1; i < representations.length; i++) {\n                r1 = representations[i - 1];\n                r2 = representations[i];\n                if (r2._getOrder() < r1._getOrder()) {\n                    representations[i - 1] = r2;\n                    representations[i] = r1;\n                    changed = true;\n                }\n            }\n            if (!changed) {\n                break;\n            }\n        }\n    };\n\n    /**\n        Error recovery, e.g. for incomplete pulls and pushes\n    **/\n\n    // Takes a branch, and an array of failed components, and attempts to fix the branch by removing any missing components.\n    // If the fix succeeds, it returns the fixed branch - but if any failed components can't be removed (because they failed\n    // due to a different error), it will return undefined.\n    AdobeLibraryManifestUtils.removeMissingComponents = function (branch, failedComponents) {\n\n        if (!branch || !failedComponents) {\n            return undefined;\n        }\n\n        var numFixed = 0;\n        failedComponents.forEach(function (failed) {\n            var component = failed.component;\n            var error = failed.error;\n\n            if (component && error && error.response && error.response.statusCode === 404) {\n                // Remove the component from the pulled branch, since it's missing\n                branch.removeComponent(component);\n\n                numFixed++;\n                AdobeLibraryServices.log('Removed missing component: ' + component.id + ' from library ' + branch.compositeId);\n            }\n        });\n\n        AdobeLibraryServices.log('Fixed ' + numFixed + ' of ' + failedComponents.length + ' components that failed to download');\n\n        if (failedComponents.length === numFixed) {\n            return branch;\n        }\n        return undefined;\n    };\n\n    // Private Utility to find a representation in a library, by its id.\n    // Not very efficient, but it's only used in the rare circumstance that a push fails (due to file missing from disk)\n    var getRepresentationById = function (library, id) {\n        var foundRepresentation;\n        library.elements.some(function (element) {\n            return element.representations.some(function (representation) {\n                if (representation.id === id) {\n                    foundRepresentation = representation;\n                    return true;\n                }\n            });\n        });\n        return foundRepresentation;\n    };\n\n    // Takes a library, and an array of failed components, and attempts to fix the library by removing any representations\n    // that correspond to missing local components\n    // If the fix succeeds, it returns the fixed branch - but if any failed components can't be removed (because they failed\n    // due to a different error), it will return undefined.\n    AdobeLibraryManifestUtils.removeMissingLocalComponents = function (library, failedComponents) {\n\n        if (!library || !failedComponents) {\n            return;\n        }\n\n        var numFixed = 0;\n        var representationsToRemove = [];\n        failedComponents.forEach(function (failed) {\n            var component = failed.component;\n            var error = failed.error;\n\n            if (component && error && error.code === AdobeDCXError.INVALID_STATE) {\n\n                // We need to find the representation that corresponds to the component\n                var representation = getRepresentationById(library, component.id);\n                if (representation) {\n                    representationsToRemove.push(representation);\n                } else {\n                    // Just remove the component directly, because it doesn't belong to any representation\n                    // (e.g. it could be a missing XMP component)\n                    library._dcxBranch.removeComponent(component);\n                }\n\n                numFixed++;\n                AdobeLibraryServices.log('Removed missing local component: ' + component.id + ' from library ' + library.id);\n            }\n        });\n\n        if (numFixed > 0) {\n            library.beginOperation();\n            representationsToRemove.forEach(function (representation) {\n                representation.element.removeRepresentation(representation);\n            });\n            library.endOperation();\n        }\n\n        AdobeLibraryServices.log('Fixed ' + numFixed + ' of ' + failedComponents.length + ' components that failed to upload');\n    };\n\n\n    /**\n        Collaboration states - unfortunately we have to have a mapping, because DCX decided to use different\n        constants from everyone else.\n    **/\n\n    AdobeLibraryManifestUtils.collaborationStateToDCX = function (collaboration) {\n        if (collaboration === 'incoming') {\n            return AdobeDCX.COLLABORATION.SHARED_WITH_USER;\n        }\n        if (collaboration === 'outgoing') {\n            return AdobeDCX.COLLABORATION.SHARED_BY_USER;\n        }\n        return AdobeDCX.COLLABORATION.PRIVATE;\n    };\n\n    AdobeLibraryManifestUtils.collaborationStateFromDCX = function (dcxCollaboration) {\n        if (dcxCollaboration === AdobeDCX.COLLABORATION.SHARED_WITH_USER) {\n            return 'incoming';\n        }\n        if (dcxCollaboration === AdobeDCX.COLLABORATION.SHARED_BY_USER) {\n            return 'outgoing';\n        }\n        return undefined;\n    };\n\n    AdobeLibraryManifestUtils.getElementReference = function (storageHost, libraryId, elementId) {\n        return \"cloud-asset://\" + storageHost + AdobeLibraryConfig.STORAGE_ASSETS_PATH +\n            AdobeLibraryConfig.LIBRARY_SYNC_GROUP + \"/\" + libraryId + \";node=\" + elementId;\n    };\n\n    return AdobeLibraryManifestUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define */\n\n/**\n * @class AdobeLibraryFileUtils\n * @classdesc\n * Utility functions for file-related operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryFileUtils',['require','exports','module','../AdobeLibraryServices'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('../AdobeLibraryServices');\n\n\n    // Static object\n    var AdobeLibraryFileUtils = {};\n\n    // Utilities\n    var getTempPath = function (path) {\n        return path + '.TEMP_' + AdobeLibraryServices.uuid();\n    };\n    var stripTempSuffix = function (path) {\n        var match = path.match(/(.*)\\.TEMP_[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i);\n        if (match && match[1]) {\n            return match[1];\n        }\n        return path;\n    };\n\n\n    /**\n        Public API\n    **/\n\n    // Ensures that the given path exists, and creates any missing dirs if not\n    AdobeLibraryFileUtils.ensurePathExists = function (path, callback) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var fs = AdobeLibraryServices.fs;\n\n        function recursiveEnsurePath(i, dirs, callback) {\n            var pathToTest = dirs.slice(0, i).join(pathSep);\n\n            var continuation = function (err) {\n                // Ignore any error in mkdir - it's ok if the directory already exists\n                if (i < dirs.length) {\n                    recursiveEnsurePath(i + 1, dirs, callback);\n                } else {\n                    callback(null);\n                }\n            };\n\n            fs.exists(pathToTest, function (exists) {\n                if (!exists) {\n                    fs.mkdir(pathToTest, continuation);\n                } else {\n                    continuation();\n                }\n            });\n        }\n\n        var dirs = path.split(pathSep);\n        recursiveEnsurePath(2, dirs, callback); // Start from '/<rootdir>'\n    };\n\n    // Copy a file from one place to another\n    AdobeLibraryFileUtils.copyFile = function (path, newPath, callback) {\n        var fs = AdobeLibraryServices.fs;\n\n        try {\n            // Write to a temp file (streaming copy), then do a rename\n            // This ensures an atomic write\n            var tempPath = getTempPath(newPath);\n\n            var tempFile = fs.createWriteStream(tempPath);\n            var sourceFile = fs.createReadStream(path);\n            var hadError = false;\n            sourceFile.on('end', function () {\n                // move to destination\n                if (!hadError) {\n                    fs.rename(tempPath, newPath, callback);\n                }\n            });\n            sourceFile.on('error', function (err) {\n                hadError = true;\n                callback(err);\n            });\n            sourceFile.pipe(tempFile);\n\n        } catch (err) {\n            callback(err);\n        }\n    };\n\n    // If the filename has a temp file suffix, it'll remove it\n    AdobeLibraryFileUtils.normaliseTempFileName = function (fileName) {\n        return stripTempSuffix(fileName);\n    };\n\n    AdobeLibraryFileUtils.getFileExtension = function (fileNameOrPath) {\n        var fileName = fileNameOrPath && fileNameOrPath.replace(/^.*[\\\\\\/]/, '');\n        var dotIndex = fileName ? fileName.lastIndexOf('.') : -1;\n        if (dotIndex !== -1) {\n            return fileName.substr(dotIndex + 1).toLowerCase();\n        }\n        return undefined;\n    };\n\n    AdobeLibraryFileUtils.recursiveDeleteDirectory = function (path, _callback) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var fs = AdobeLibraryServices.fs;\n\n        var callback = function (err) {\n            if (err && err.code === 'ENOENT') {\n                // Ignore if delete fails because it was already deleted\n                err = null;\n            }\n\n            if (_callback) {\n                _callback(err);\n            }\n        };\n\n        fs.exists(path, function (exists) {\n            if (exists) {\n                fs.readdir(path, function (err, items) {\n                    if (err) { callback(err); return; }\n\n                    if (!items || items.length === 0) {\n                        // Empty directory - so just go ahead and delete it\n                        fs.rmdir(path, callback);\n                        return;\n                    }\n\n                    var firstError = null;\n                    var count = 0;\n                    function finishDeleteItem(err) {\n                        if (err && err.code === 'ENOENT') {\n                            // Ignore if delete fails because it was already deleted\n                            err = null;\n                        }\n\n                        firstError = firstError || err;\n                        count++;\n                        if (count === items.length) {\n                            // Delete the actual directory\n                            if (firstError) {\n                                callback(firstError);\n                            } else {\n                                fs.rmdir(path, callback);\n                            }\n                        }\n                    }\n\n                    items.forEach(function (item) {\n                        var itemPath = path + pathSep + item;\n                        fs.stat(itemPath, function (err, stat) {\n                            firstError = firstError || err;\n\n                            if (stat && stat.isDirectory()) {\n                                AdobeLibraryFileUtils.recursiveDeleteDirectory(itemPath, finishDeleteItem);\n                            } else {\n                                fs.unlink(itemPath, finishDeleteItem);\n                            }\n                        });\n                    });\n                });\n            } else {\n                callback(null);\n            }\n        });\n    };\n\n    AdobeLibraryFileUtils.moveLibrary = function (library, oldLibraryId, callback) {\n        var fs = AdobeLibraryServices.fs;\n\n        if (oldLibraryId === library.id) {\n            callback(null);\n            return;\n        }\n\n        var oldCompositePath = library._collection._getCompositeDir(oldLibraryId);\n        var newCompositePath = library._getCompositeDir();\n        var oldRenditionCachePath = library._collection._getRenditionCacheDir(oldLibraryId);\n        var newRenditionCachePath = library._getRenditionCacheDir();\n\n        fs.rename(oldCompositePath, newCompositePath, function (err) {\n            if (err) { callback(err); return; }\n\n            // Update the DCX path\n            library._dcxComposite.path = newCompositePath;\n\n            fs.rename(oldRenditionCachePath, newRenditionCachePath, callback);\n        });\n    };\n\n    AdobeLibraryFileUtils.readLibraryDirectory = function (collection, callback) {\n        var fs = AdobeLibraryServices.fs;\n\n        // Since this gets called when a collection is loaded, we take the opportunity to delete the collection's temp dir, if it exists\n        var tempDir = collection._getTempDir();\n        AdobeLibraryFileUtils.recursiveDeleteDirectory(tempDir, function () {\n            // Now load the collection directory\n\n            // NOTE: we don't ensure the path exists, because we only want to create the path if you actually sync some libraries (or create one)\n            // When we write to disk, we ensure that the root directory exists\n            var path = collection._getCompositeDir();\n            fs.readdir(path, callback);\n        });\n    };\n\n    AdobeLibraryFileUtils.doesRootDirExist = function (collection, callback) {\n        var fs = AdobeLibraryServices.fs;\n\n        var path = collection._getCompositeDir();\n        fs.exists(path, function (exists) {\n            callback(null, exists);\n        });\n    };\n\n    AdobeLibraryFileUtils.deleteLibraryFromDisk = function (collection, libraryId, callback) {\n        if (AdobeLibraryServices.hasFileSystem()) {\n            var compositePath = collection._getCompositeDir(libraryId);\n            var renditionPath = collection._getRenditionCacheDir(libraryId);\n\n            AdobeLibraryFileUtils.recursiveDeleteDirectory(compositePath, function () {\n                AdobeLibraryFileUtils.recursiveDeleteDirectory(renditionPath, callback);\n            });\n        } else {\n            if (callback) {\n                callback(null);\n            }\n        }\n    };\n\n    return AdobeLibraryFileUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define */\n\n/**\n * @class AdobeLibraryErrorUtils\n * @classdesc\n * Utility functions for errors\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryErrorUtils',['require','exports','module','../components/dcx-js/src/AdobeDCXError','../AdobeLibraryError'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeDCXError = require('../components/dcx-js/src/AdobeDCXError');\n    var AdobeLibraryError = require('../AdobeLibraryError');\n\n\n    // Static object\n    var AdobeLibraryErrorUtils = {};\n\n\n    /**\n        Public API\n    **/\n\n    AdobeLibraryErrorUtils.getErrorStatusCode = function (err) {\n        if (!err) {\n            return undefined;\n        }\n\n        var statusCode = err.code === AdobeDCXError.UNEXPECTED_RESPONSE && err.response && err.response.statusCode;\n        if (statusCode) {\n            return statusCode;\n        }\n\n        if (err.underlyingError) {\n            // See if the underlying error has a status code\n            return AdobeLibraryErrorUtils.getErrorStatusCode(err.underlyingError);\n        }\n\n        return undefined;\n    };\n\n    AdobeLibraryErrorUtils.getSyncError = function (err, libraryId) {\n        if (err) {\n            var newError;\n            if (err.code === AdobeDCXError.SERVICE_IS_INACTIVE) {\n                newError = new AdobeLibraryError(AdobeLibraryError.LOGGED_OUT, 'no access token: call updateAccessToken() and try again', libraryId, err);\n            } else if (err.code === AdobeDCXError.NETWORK_ERROR) {\n                newError = new AdobeLibraryError(AdobeLibraryError.NETWORK_ERROR, 'error connecting to server', libraryId, err);\n            } else if (err.code === AdobeDCXError.EXCEEDS_QUOTA) {\n                newError = new AdobeLibraryError(AdobeLibraryError.EXCEEDS_QUOTA, 'push failed due to insufficient remaining quota', libraryId, err);\n            } else if (err.code === AdobeDCXError.OUT_OF_SPACE) {\n                newError = new AdobeLibraryError(AdobeLibraryError.OUT_OF_SPACE, 'not enough disk space', libraryId, err);\n            } else if (err.code === AdobeDCXError.NOT_IMPLEMENTED) {\n                newError = new AdobeLibraryError(AdobeLibraryError.NOT_IMPLEMENTED, 'tried to call an API not implemented on the server', libraryId, err);\n            } else if (err.code === AdobeDCXError.RETRYABLE_SERVER_ERROR) {\n                newError = new AdobeLibraryError(AdobeLibraryError.RETRYABLE_SERVER_ERROR, 'intermittent server failure - can retry later', libraryId, err);\n            } else if (err.code === AdobeDCXError.INVALID_DATA || err.code === AdobeDCXError.INVALID_JSON) {\n                newError = new AdobeLibraryError(AdobeLibraryError.CORRUPTED_LIBRARY, 'unable to read manifest', libraryId, err);\n            } else if (AdobeLibraryErrorUtils.getErrorStatusCode(err) === 403) {\n                newError = new AdobeLibraryError(AdobeLibraryError.ACCESS_DENIED, 'server returned 403 Forbidden response', libraryId, err);\n            } else {\n                // TRANSFER_ERROR is catchall for anything unexpected\n                newError = new AdobeLibraryError(AdobeLibraryError.TRANSFER_ERROR, 'something went wrong during a push/pull operation', libraryId, err);\n            }\n            return newError;\n        }\n    };\n\n    AdobeLibraryErrorUtils.getCommitError = function (err, libraryId, additionalMessage) {\n        if (err) {\n            var newError;\n            var explanation = additionalMessage ? ' - ' + additionalMessage : '';\n            if (err.code === AdobeDCXError.INVALID_DATA || err.code === AdobeDCXError.INVALID_JSON) {\n                newError = new AdobeLibraryError(AdobeLibraryError.CORRUPTED_LIBRARY, 'unable to read manifest' + explanation, libraryId, err);\n            } else if (err.code === AdobeDCXError.OUT_OF_SPACE) {\n                newError = new AdobeLibraryError(AdobeLibraryError.OUT_OF_SPACE, 'not enough disk space' + explanation, libraryId, err);\n            } else {\n                newError = new AdobeLibraryError(AdobeLibraryError.FS_ERROR, 'filesystem error' + explanation, libraryId, err);\n            }\n            return newError;\n        }\n    };\n\n    AdobeLibraryErrorUtils.getErrorPriority = function (err) {\n        // Ordered from low to high priority\n        var errorsInPriorityOrder = [\n            AdobeLibraryError.EXCEEDS_MAX_LIBRARY_SIZE,\n            AdobeLibraryError.RENDITION_NOT_AVAILABLE,\n            AdobeLibraryError.URL_VALIDATION_FAILED,\n            AdobeLibraryError.CORRUPTED_LIBRARY,\n            AdobeLibraryError.TRANSFER_ABORTED,\n            AdobeLibraryError.TRANSFER_ERROR,\n            AdobeLibraryError.NETWORK_ERROR,\n            AdobeLibraryError.EXCEEDS_QUOTA,\n            AdobeLibraryError.RETRYABLE_SERVER_ERROR,\n            AdobeLibraryError.LOGGED_OUT,\n            AdobeLibraryError.FILE_TOO_LARGE,\n            AdobeLibraryError.FS_ERROR,\n            AdobeLibraryError.OUT_OF_SPACE,\n            AdobeLibraryError.ACCESS_DENIED,\n            AdobeLibraryError.NOT_ALLOWED,\n            AdobeLibraryError.DELETED_LOCALLY,\n            AdobeLibraryError.REQUIRES_FILESYSTEM,\n            AdobeLibraryError.NOT_SUPPORTED,\n            AdobeLibraryError.NOT_IMPLEMENTED,\n            AdobeLibraryError.INVALID_PARAMETER,\n            AdobeLibraryError.READ_ONLY\n        ];\n\n        var priority = err && err.code && errorsInPriorityOrder.indexOf(err.code);\n        return priority !== undefined ? priority : -1;\n    };\n\n    // Get a string form of an error: useful for logging\n    AdobeLibraryErrorUtils.errorToString = function (err) {\n        var str = '';\n        if (err) {\n            if (err.message) {\n                str += err.message;\n            }\n            if (err.libraryId) {\n                str += ' library: ' + err.libraryId;\n            }\n            if (err.underlyingError) {\n                str += '\\n<- ' + AdobeLibraryErrorUtils.errorToString(err.underlyingError);\n            } else if (err.response && err.response.statusCode) {\n                str += ': ' + err.response.statusCode;\n            }\n\n            if (err.failedComponents) {\n                str += '\\n<- Failed Components:';\n                err.failedComponents.forEach(function (failed) {\n                    var componentId = failed.component && failed.component.id;\n                    var error = failed.error;\n                    var message = error && error.message;\n                    var statusCode = error && error.response && error.response.statusCode;\n                    str += '\\n    [' + componentId + '] ' + message + (statusCode ? ': ' + statusCode : '');\n                });\n            }\n        }\n\n        return str;\n    };\n\n    // Determine if a particular string is a library error code\n    AdobeLibraryErrorUtils.isErrorCode = function (errorCode) {\n        if (!errorCode) {\n            return false;\n        }\n\n        return AdobeLibraryError.hasOwnProperty(errorCode) && AdobeLibraryError[errorCode] === errorCode;\n    };\n\n\n    return AdobeLibraryErrorUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define */\n\n/**\n * @class AdobeLibrarySyncUtils\n * @classdesc\n * Utility functions for syncing-related operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibrarySyncUtils',['require','exports','module','../AdobeLibraryConfig','../AdobeLibraryError','../components/dcx-js/src/AdobeDCXUtil'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryConfig = require('../AdobeLibraryConfig');\n    var AdobeLibraryError = require('../AdobeLibraryError');\n    var AdobeDCXUtil = require('../components/dcx-js/src/AdobeDCXUtil');\n\n\n    // Static object\n    var AdobeLibrarySyncUtils = {};\n\n\n    /**\n        Public API\n    **/\n\n\n    AdobeLibrarySyncUtils.getBackoffTicks = function (numBackoffs) {\n        var intervals = AdobeLibraryConfig.BACKOFF_INTERVALS;\n        var index = Math.max(0, Math.min(numBackoffs, intervals.length - 1));\n        return intervals[index] - 1;\n    };\n\n    // Given the headers, return the retry after value if there is one (in seconds), or 0\n    AdobeLibrarySyncUtils.getRetryAfterHeader = function (headers) {\n        if (headers) {\n            var retryAfterHeader = headers['retry-after'] || headers['Retry-After'];\n            if (retryAfterHeader) {\n                try {\n                    // First, try to parse it as a number (retry time in seconds)\n                    var retryTime = parseInt(retryAfterHeader, 10);\n                    if (retryTime) {\n                        return Math.max(0, retryTime);\n                    }\n\n                    // If that fails, try to parse it as a date\n                    var retryDate = Date.parse(retryAfterHeader);\n                    if (retryDate) {\n                        // Need to add a randomised element to ensure requests don't all come back at the same time\n                        var now = new Date().valueOf();\n                        var retrySeconds = Math.max(0, retryDate - now) / 1000;\n                        var retryRandom = Math.floor(Math.random() * AdobeLibraryConfig.RETRY_RANDOM_SECONDS);\n                        return retrySeconds + retryRandom;\n                    }\n\n                } catch (ignore) {\n                }\n            }\n        }\n\n        return 0;\n    };\n\n    // Given the headers, return the location value\n    AdobeLibrarySyncUtils.getLocationHeader = function (headers) {\n        if (headers) {\n            var locationHeader = headers.location || headers.Location;\n            if (locationHeader) {\n                return locationHeader;\n            }\n        }\n    };\n\n    // Given the headers, return the content-type value\n    AdobeLibrarySyncUtils.getContentTypeHeader = function (headers) {\n        if (headers) {\n            var contentType = headers['content-type'] || headers['Content-Type'];\n            if (contentType) {\n                var semiColonIndex = contentType.indexOf(';');\n                if (semiColonIndex > 0) {\n                    // Content type could have parameters, e.g. \"text/html; charset=UTF-8\" - so strip everything after the semicolon\n                    contentType = contentType.substring(0, semiColonIndex);\n                }\n                return contentType;\n            }\n        }\n    };\n\n    // Is it a 4xx error, excluding the recoverable ones (401, 407, 408)\n    AdobeLibrarySyncUtils.isUnrecoverableClientError = function (status) {\n        if (!status) {\n            return false;\n        }\n        return status >= 400 && status < 500 && status !== 401 && status !== 407 && status !== 408;\n    };\n\n\n    /**\n        Whitelisting\n    **/\n\n    // Private - check if domain is in list\n    var checkDomain = function (domain, domainSuffixList) {\n        return domainSuffixList.some(function (domainSuffix) {\n            if (domain === domainSuffix) {\n                return true;\n            }\n            var index = domain.indexOf('.' + domainSuffix);\n            return index !== -1 && index === (domain.length - domainSuffix.length - 1);\n        });\n    };\n\n\n    // Check if the URL is an Adobe-domain; in which case it should always be whitelisted, and we should set the auth token when calling it\n    AdobeLibrarySyncUtils.isAdobeDomain = function (domain) {\n        if (!domain) {\n            return false;\n        }\n\n        return checkDomain(domain, AdobeLibraryConfig.ADOBE_AUTHENTICATED_DOMAINS);\n    };\n\n    // Check if the given URL is allowed (via our whitelisting)\n    // Returns null, or an error\n    AdobeLibrarySyncUtils.validateURL = function (url) {\n\n        if (!url) {\n            // Don't support http downloads\n            return new AdobeLibraryError(AdobeLibraryError.URL_VALIDATION_FAILED, 'URL not specified');\n        }\n\n        var urlItems = AdobeDCXUtil.parseURI(url);\n\n        if (urlItems.scheme !== 'https') {\n            // Don't support http downloads\n            return new AdobeLibraryError(AdobeLibraryError.URL_VALIDATION_FAILED, 'URL must be https://');\n        }\n\n        var isAdobeDomain = AdobeLibrarySyncUtils.isAdobeDomain(urlItems.authority);\n        var isWhitelisted = isAdobeDomain || checkDomain(urlItems.authority, AdobeLibraryConfig.WHITELISTED_DOMAINS);\n\n        if (!isWhitelisted) {\n            // Don't support http downloads\n            return new AdobeLibraryError(AdobeLibraryError.URL_VALIDATION_FAILED, 'URL domain not in whitelist');\n        }\n\n        return null;\n    };\n\n\n    return AdobeLibrarySyncUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define */\n\n/**\n * @class AdobeLibraryRepresentation\n * @classdesc\n * A representation of an element in a library.\n *\n * @description\n * This class has a private constructor. The only way to obtain an instance of AdobeLibraryRepresentation\n * is via an {@link AdobeLibraryElement}.\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryRepresentation',['require','exports','module','./AdobeLibraryServices','./AdobeLibraryConfig','./AdobeLibraryError','./utils/AdobeLibraryMimeTypeUtils','./utils/AdobeLibraryManifestUtils','./utils/AdobeLibraryFileUtils','./utils/AdobeLibraryErrorUtils','./utils/AdobeLibrarySyncUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n\n    var AdobeLibraryMimeTypeUtils = require('./utils/AdobeLibraryMimeTypeUtils');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n    var AdobeLibraryErrorUtils = require('./utils/AdobeLibraryErrorUtils');\n    var AdobeLibrarySyncUtils = require('./utils/AdobeLibrarySyncUtils');\n\n    // Constructor\n    // Note: you should never call this directly; always through AdobeLibraryElement.createRepresentation()\n    function AdobeLibraryRepresentation(element, dcxNode, dcxComponent) {\n        this._element = element;\n        this._dcxNode = dcxNode;\n        this._dcxComponent = dcxComponent;\n        this._deletedLocally = false;\n\n        this._pendingDownloadCallbacks = [];\n    }\n\n    // Private: prevent further operations when the representation is destroyed\n    AdobeLibraryRepresentation.prototype._markDeletedLocally = function (isDeleted) {\n        this._deletedLocally = isDeleted;\n    };\n\n    // Private: convert to internal JSON format that can be serialised to disk (will be replaced by DCX)\n    AdobeLibraryRepresentation.prototype._toJSON = function () {\n        var obj = {\n            id: this.id,\n            type: this.type,\n            relationship: this.relationship\n        };\n        // TOFIX: what about custom values?\n\n        if (AdobeLibraryServices.hasFileSystem()) {\n            obj._componentPath = this._getComponentPath();\n        }\n\n        return obj;\n    };\n\n    // Private: get the specified order of the representation\n    AdobeLibraryRepresentation.prototype._getOrder = function () {\n        return this._getDCXElement().getValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY) || 0;\n    };\n\n    // Private: Set the component in the library from the given path on disk\n    AdobeLibraryRepresentation.prototype._setComponentInBrowser = function (content, fileName, callback) {\n        var that = this;\n\n        var syncManager = this._element._library._collection._syncManager;\n        syncManager.uploadNewComponent(content, fileName, this, function (err, dcxComponent) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { callback(err); return; }\n\n            if (err) { callback(err); return; }\n\n            // Remember to copy any custom data across (in case they called setValue before setContent)\n            AdobeLibraryManifestUtils.copyCustomDCXData(that._dcxNode, dcxComponent);\n\n            var branch = that._element._library._dcxBranch;\n            branch.removeChild(that._dcxNode);\n            that._dcxComponent = dcxComponent;\n            delete that._dcxNode;\n            // We now have a component, rather than a node: it's a one-way journey and we can't go back.\n\n            that._commit();\n            callback(null);\n        });\n    };\n\n    // Private: Set the component in the library from the given path on disk\n    AdobeLibraryRepresentation.prototype._setComponentFromPath = function (path, copyFile, callback) {\n        var fs = AdobeLibraryServices.fs;\n        var that = this;\n\n        // Get the file extension: we'll preserve this\n        var fileName = path && AdobeLibraryServices.getFileNameFromPath(path);\n        var extension = AdobeLibraryFileUtils.getFileExtension(fileName);\n        var dcxPath = this.id + '.' + extension;\n\n        // Check that the file isn't bigger than 1GB - otherwise, we should block it from being added\n        fs.stat(path, function (err, stats) {\n            if (stats && stats.size > AdobeLibraryConfig.MAX_COMPONENT_SIZE) {\n                callback(new AdobeLibraryError(AdobeLibraryError.FILE_TOO_LARGE, 'File exceeds maximum size for a representation'));\n                return;\n            }\n\n            AdobeLibraryServices.storageInterface.notifyStartWrite(that._element._library, [], function () {\n                // If we're in the shared local storage world, we'll notify the service that we're starting to write components, so it can turn off auto-GC until we commit\n\n                var branch = that._element._library._dcxBranch;\n                branch.addComponent(fileName, that.type, that.relationship, dcxPath, path, copyFile, undefined, that._element._dcxNode, that.id, function (err, dcxComponent) {\n                    if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                    if (err) { callback(err); return; }\n\n                    // Remember to copy any custom data across (in case they called setValue before setContent)\n                    AdobeLibraryManifestUtils.copyCustomDCXData(that._dcxNode, dcxComponent);\n\n                    branch.removeChild(that._dcxNode);\n                    that._dcxComponent = dcxComponent;\n                    delete that._dcxNode;\n                    // We now have a component, rather than a node: it's a one-way journey and we can't go back.\n\n                    that._commit();\n                    callback(null);\n                });\n            });\n        });\n    };\n\n    // Private: Set the component in the library from the given data\n    AdobeLibraryRepresentation.prototype._setComponent = function (data, encoding, fileName, callback) {\n        var fs = AdobeLibraryServices.fs;\n        var that = this;\n\n        var componentPath;\n\n        function finishWritingFile(err) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            if (err) {\n                callback(AdobeLibraryErrorUtils.getCommitError(err, that._element._library.id, 'error writing representation contents'));\n                return;\n            }\n\n            // Commit changes to manifest\n            that._setComponentFromPath(componentPath, false, callback);\n        }\n\n        function writeFile() {\n            if (encoding === 'buffer') {\n                fs.writeFile(componentPath, data, finishWritingFile);\n            } else {\n                fs.writeFile(componentPath, data, encoding, finishWritingFile);\n            }\n        }\n\n        var tempRootPath = this.element.library.collection._getTempDir();\n        AdobeLibraryFileUtils.ensurePathExists(tempRootPath, function (err) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            if (err) {\n                callback(AdobeLibraryErrorUtils.getCommitError(err, that._element._library.id, 'error creating temp directory'));\n                return;\n            }\n\n            // If you don't pass in a fileName, we generate one for you, with extension based on the mime type of the representation\n            if (!fileName) {\n                var extension = AdobeLibraryMimeTypeUtils.getExtensions(that.type)[0];\n                fileName = that.id + '.' + extension;\n            }\n\n            componentPath = tempRootPath + AdobeLibraryServices.getPathSeparator() + fileName;\n            writeFile();\n        });\n    };\n\n    AdobeLibraryRepresentation.prototype._getCurrentComponentPath = function () {\n        if (this._dcxComponent) {\n            return this._element._library._dcxBranch.assetOfComponent(this._dcxComponent);\n        }\n        return undefined;\n    };\n\n    // Private: get an absolute path to the component\n    // It's a synchronous call if you specify a callback, otherwise asynchronous\n    AdobeLibraryRepresentation.prototype._getComponentPath = function (callback, noRetry) {\n        if (callback) {\n            if (this.isExternalLink()) {\n                this._getExternalLinkPath(callback);\n\n            } else if (this._dcxComponent) {\n                var componentPath = this._getCurrentComponentPath();\n\n                if (componentPath || noRetry) {\n                    callback(null, componentPath);\n\n                } else {\n                    // Need to download asset\n                    var that = this;\n                    var library = this._element._library;\n\n                    // Make sure we obtain a network lock, to prevent another sync of the library from happening in parallel\n                    library._networkLock.obtain(function (err) {\n                        // Just return if aborted (couldn't obtain lock)\n                        if (err) { callback(err); return; }\n\n                        if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) {\n                            library._networkLock.release();\n                            return;\n                        }\n\n                        library._setSyncState('downloading');\n                        var syncManager = library._collection._syncManager;\n                        syncManager.downloadRepresentation(that, function (err) {\n                            library._networkLock.release();\n                            library._setSyncState();\n\n                            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                            if (err) {\n                                callback(AdobeLibraryErrorUtils.getSyncError(err, that._element._library.id));\n                                return;\n                            }\n\n                            library._commit(true, true); // Save to disk, but don't mark the library as modified, and don't sync\n                            that._getComponentPath(callback, true);\n                        });\n                    });\n                }\n            } else {\n                callback(null);\n            }\n\n        } else {\n            return this._getCurrentComponentPath();\n        }\n    };\n\n    // Private: Utility to update the element's rendition cache, acquiring the lock\n    AdobeLibraryRepresentation.prototype._setRenditionCache = function (size, fileName, notifyDownloadRendition, callback) {\n        var element = this.element;\n\n        element._lock.obtain(function () {\n            element._setRenditionCache(size, fileName, notifyDownloadRendition);\n\n            element._lock.release();\n            callback();\n        });\n    };\n\n    AdobeLibraryRepresentation.prototype._getCachedExternalLinkPath = function (returnPlaceholder) {\n        var cachedError = null;\n        var cachedPath = this.element._lookupRenditionPath(this.id);\n\n        if (!returnPlaceholder && cachedPath === AdobeLibraryConfig.RENDITION_CACHE_PLACEHOLDER) {\n            // This is just a placeholder - not actually a cached path\n            cachedPath = undefined;\n        }\n        if (AdobeLibraryErrorUtils.isErrorCode(cachedPath)) {\n            cachedError = new AdobeLibraryError(cachedPath, 'Broken link, or access denied', this.element.library.id);\n            cachedPath = undefined;\n        }\n\n        if (!cachedError && !cachedPath) {\n            // Get the URL, and make sure it's valid\n            var url = this._dcxNode.getValue(AdobeLibraryConfig.LINK_URL_KEY);\n            cachedError = AdobeLibrarySyncUtils.validateURL(url);\n        }\n\n        return {\n            err: cachedError,\n            path: cachedPath\n        };\n    };\n\n    // Private: get the content path for an external link - this assumes that we are an external link, since only called internally\n    // If we don't have the external link cached, this will download it.\n    // This code assumes\n    AdobeLibraryRepresentation.prototype._getExternalLinkPath = function (callback) {\n        var that = this;\n        var library = this.element.library;\n        var collection = library.collection;\n        var tempDir = collection._getTempDir();\n\n        // First check the cache, to see if we already have the content downloaded\n        // We sneakily use the rendition cache of the element, with a map from representation id to the file\n        var cachedPath = this._getCachedExternalLinkPath();\n        if (cachedPath.err || cachedPath.path) {\n            // Return the cached path or error\n            callback(cachedPath.err, cachedPath.path);\n            return;\n        }\n\n        // Not cached and the URL is valid - we need to do the download...\n\n        // If we're shared local storage, we need to call into the local storage service for this\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            AdobeLibraryServices.storageInterface.downloadExternalLink(that, callback);\n            return;\n        }\n\n        // Now, before we download, let's see if somebody else was already downloading this same representation!! Don't want to do it twice!\n        this._pendingDownloadCallbacks.push(callback);\n        if (this._pendingDownloadCallbacks.length > 1) {\n            // Just return - our callback will be handled in due course\n            return;\n        }\n\n        var callPendingCallbacks = function (err, path) {\n            var callbacks = that._pendingDownloadCallbacks;\n            that._pendingDownloadCallbacks = [];\n            callbacks.forEach(function (callback) {\n                callback(err, path);\n            });\n        };\n\n        var onDownloadComplete = function (err, path) {\n            if (err) { callPendingCallbacks(err); return; }\n\n            if (AdobeLibraryErrorUtils.isErrorCode(path)) {\n                // If we failed to download because of a permissions error (or 404 broken link), we stash this in the cache.\n                // That's so we don't keep on trying to download something that doesn't exist (or we don't have permissions for it).\n                that._setRenditionCache(that.id, path, true, function () {\n                    callPendingCallbacks(new AdobeLibraryError(path, 'Broken link, or access denied', library.id));\n                });\n                return;\n            }\n\n            // Otherwise, we have a path to the downloaded file - so store this in the rendition cache\n            // This handles passing back the new path (or an error if it failed).\n            that.element.setRenditionCache(that.id, path, function (err, path) {\n                // setRendition cache doesn't notify the clients of the rendition cache update, so need to do so here\n                AdobeLibraryServices.storageInterface.notifyDownloadRendition(that.element);\n\n                callPendingCallbacks(err, path);\n            });\n        };\n\n        var url = this._dcxNode.getValue(AdobeLibraryConfig.LINK_URL_KEY);\n\n        var startTime = new Date().valueOf();\n        AdobeLibraryServices.log('Downloading from external URL: ' + url);\n        AdobeLibraryServices.storageInterface.getAssetFromURL(collection, url, {}, tempDir, function (err, tempFilePath, etag, response) {\n            AdobeLibraryServices.log('Finished downloading from external URL: ' + (new Date().valueOf() - startTime) + 'ms');\n\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, onDownloadComplete)) { return; }\n\n            // Check for permanent errors on fetching the external link - in which case we shouldn't retry.\n            // Anything that's a 4xx error (including 403 and 404) satisfies this, except for 401/407/408 which are retryable.\n            var errorStatus = err && err.response && err.response.statusCode;\n            if (AdobeLibrarySyncUtils.isUnrecoverableClientError(errorStatus)) {\n                onDownloadComplete(null, AdobeLibraryError.RENDITION_NOT_AVAILABLE);\n                return;\n            }\n\n            // If it's a normal error, just return\n            if (err) {\n                onDownloadComplete(AdobeLibraryErrorUtils.getSyncError(err));\n                return;\n            }\n\n            // If we have a content type header in the response, we'll use that to generate a file name for the downloaded content\n            // Otherwise, we use the type of the representation\n            var contentType = AdobeLibrarySyncUtils.getContentTypeHeader(response && response.headers) || that.type;\n            var extension = AdobeLibraryMimeTypeUtils.getExtensions(contentType)[0] || 'data';\n            var tempFilePathWithExtension = tempFilePath + '.' + extension;\n\n            // Rename, so the temp file has the correct extension (this gets preserved by DCX)\n            AdobeLibraryServices.fs.rename(tempFilePath, tempFilePathWithExtension, function (err) {\n                if (err) {\n                    onDownloadComplete(AdobeLibraryErrorUtils.getCommitError(err));\n                    return;\n                }\n\n                onDownloadComplete(null, tempFilePathWithExtension);\n            });\n        });\n    };\n\n    // Private: internal function used to test if an external link is valid, without downloading it\n    // This is under-approximating errors - it returns false if we know it's an error, true if it's ok (or we're not sure)\n    AdobeLibraryRepresentation.prototype._testExternalLink = function (callback) {\n        var that = this;\n\n        // First check the cache, to see if we already have the content downloaded\n        // We sneakily use the rendition cache of the element, with a map from representation id to the file\n        var cachedPath = this._getCachedExternalLinkPath(true);\n        if (cachedPath.err) {\n            // There's an error, so it's not valid\n            callback(null, false);\n            return;\n        }\n        if (cachedPath.path) {\n            // We have a cached path (or placeholder following a successful HEAD request), so the link is valid\n            callback(null, true);\n            return;\n        }\n\n        // Otherwise, need to do a HEAD request and cache the result (if the URL is valid)\n        var url = this._dcxNode.getValue(AdobeLibraryConfig.LINK_URL_KEY);\n\n        var startTime = new Date().valueOf();\n        AdobeLibraryServices.log('HEAD request of external URL: ' + url);\n        AdobeLibraryServices.storageInterface.doHeadRequestOfURL(this.element.library.collection, url, function (err, response) {\n            AdobeLibraryServices.log('Finished HEAD request of external URL: ' + (new Date().valueOf() - startTime) + 'ms');\n\n            // Network error is ok - we just return true, so we can try again later\n            if (err) { callback(null, true); return; }\n\n            var status = response && response.statusCode;\n\n            if (AdobeLibrarySyncUtils.isUnrecoverableClientError(status)) {\n                // Definitely bad - remember this, so we don't retry\n                that._setRenditionCache(that.id, AdobeLibraryError.RENDITION_NOT_AVAILABLE, true, function () {\n                    callback(null, false);\n                });\n\n\n            } else if (status && status >= 200 && status < 400) {\n                // It's a success or redirect: leave a placeholder so we don't retry (unless we actually ask for the path!!)\n                that._setRenditionCache(that.id, AdobeLibraryConfig.RENDITION_CACHE_PLACEHOLDER, false, function () {\n                    callback(null, true);\n                });\n\n            } else {\n                // Some other error - we just return true, so we can try again later\n                callback(null, true);\n            }\n        });\n    };\n\n    // Private: utility to get the DCX element: could be the node or the component\n    AdobeLibraryRepresentation.prototype._getDCXElement = function () {\n        return this._dcxComponent || this._dcxNode;\n    };\n\n    // Private: commit an operation\n    AdobeLibraryRepresentation.prototype._commit = function () {\n        this._element._commit();\n    };\n\n    // Private: wrap an operation (uncomment if needed)\n//    AdobeLibraryRepresentation.prototype._wrapOperation = function (operation, thisObject) {\n//        return this._element._wrapOperation(function () {\n//            var innerRetValue = this._element._wrapOperation(operation, thisObject);\n//            this._element._clearRenditionCache();\n//            return innerRetValue;\n//        }, this);\n//    };\n\n    // Private: custom pretty printer for testing\n    AdobeLibraryRepresentation.prototype.jasmineToString = function () {\n        return this.toString();\n    };\n\n    /**\n        Public API\n    **/\n\n    // Getters/setters for properties\n    Object.defineProperties(AdobeLibraryRepresentation.prototype, {\n        /**\n         * The id of the representation (this will never change, after the representation is created).\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {String}\n         * @instance\n         */\n        id: {\n            get: function () {\n                return this._getDCXElement().id;\n            },\n            set: function (id) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the id of an existing representation', this._element._library.id);\n            }\n        },\n        /**\n         * The element that the representation belongs to.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {AdobeLibraryElement}\n         * @instance\n         */\n        element: {\n            get: function () {\n                return this._element;\n            },\n            set: function (element) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'element is a read-only property', this._element._library.id);\n            }\n        },\n        /**\n         * Whether or not write operations are permitted on the representation. If `false`, you'll receive an {@AdobeLibraryError.NOT_ALLOWED} error\n         * if you try to modify the representation.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {Boolean}\n         * @instance\n         */\n        writable: {\n            get: function () {\n                return this._element.writable;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'writable is a read-only property', this._element._library.id);\n            }\n        },\n        /**\n         * The type of the representation.\n         *\n         * Representation types should correspond to concrete mime types - in particular, if you add a file as a representation,\n         * this should be the same as the mime type of the file (e.g. `image/png`). For non-standard data stored in design libraries,\n         * see [Creative Cloud Library Types](https://wiki.corp.adobe.com/display/ccprojects/Creative+Cloud+Libraries+DCX+Types).\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {String}\n         * @instance\n         */\n        type: {\n            get: function () {\n                var type = this._getDCXElement().type;\n                if (type === AdobeLibraryConfig.LINK_REPRESENTATION_TYPE) {\n                    // We pretend that the type of the representation is whatever type the underlying link returns.\n                    type = this._getDCXElement().getValue(AdobeLibraryConfig.LINK_TYPE_KEY);\n                }\n                return type;\n            },\n            set: function (name) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the content type of an existing representation', this._element._library.id);\n            }\n        },\n        /**\n         * The relationship of the representation to the element it belongs to. This can take three values:\n         *\n         * * `'primary'`: the main representation - this should be the highest-fidelity form of the element, and is considered\n         *   the most 'truthful' version of the element. For example, an image added from Photoshop would use a PSD as its primary\n         *   representation, whereas one added from Illustrator would use an AI file.\n         *   An element must have precisely one primary representation.\n         * * `'rendition'`: a representation that is derivable from, and is visually similar to the primary representation. For\n         *   example, a flattened PNG version of a PSD would be a rendition representation.\n         * * `'alternate'`: a representation that is not derivable from the primary representation, but stores alternative, or\n         *   auxilliary data. This should be used sparingly.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {String}\n         * @instance\n         * @see {@link AdobeLibraryElement#createRepresentation}\n         */\n        relationship: {\n            get: function () {\n                if (this._dcxComponent) {\n                    return this._dcxComponent.relationship;\n                }\n                // Due to a bug in the iOS app, there may be node-type representations whose relationship is set using the 'relationship' key\n                // rather than 'library#rel'. To account for this, we check both (but 'library#rel' takes precedence).\n                return this._dcxNode.getValue(AdobeLibraryConfig.RELATIONSHIP_KEY) || this._dcxNode.getValue('relationship');\n            },\n            set: function (relationship) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the relationship of an existing representation', this._element._library.id);\n            }\n        },\n        /**\n         * The width of the image corresponding to the representation. To modify the width, just set this to a new value,\n         * and it will automatically save and sync the change to the server.\n         *\n         * Notes:\n         *\n         * 1. This property only makes sense if the representation corresponds to something with dimensions, e.g. an image.\n         * 2. It's up to the client to set this property whenever a representation corresponding to an image is created.\n         * 3. This can only be set after calling {@link AdobeLibraryRepresentation#updateContentFromPath}, or one of the other\n         *    methods to assign a file to the representation. If not, you will get an {@link AdobeLibraryError.INVALID_PARAMETER} error.\n         * 4. Changing this property on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {Number|undefined}\n         * @instance\n         */\n        width: {\n            get: function () {\n                if (this._dcxComponent) {\n                    return this._dcxComponent.getValue('width');\n                }\n                return this._dcxNode.getValue(AdobeLibraryConfig.WIDTH_KEY);\n            },\n            set: function (width) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id);\n                }\n                if (!this._dcxComponent && !this.isExternalLink()) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot set width on a representation without contents', this._element._library.id);\n                }\n                if (typeof width !== 'number' || width < 0) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid width', this._element._library.id);\n                }\n                if (this._dcxComponent) {\n                    this._dcxComponent.setValue('width', width);\n                } else {\n                    this._dcxNode.setValue(AdobeLibraryConfig.WIDTH_KEY, width);\n                }\n                this._commit();\n            }\n        },\n        /**\n         * The height of the image corresponding to the representation. To modify the height, just set this to a new value,\n         * and it will automatically save and sync the change to the server.\n         *\n         * Notes:\n         *\n         * 1. This property only makes sense if the representation corresponds to something with dimensions, e.g. an image.\n         * 2. It's up to the client to set this property whenever a representation corresponding to an image is created.\n         * 3. This can only be set after calling {@link AdobeLibraryRepresentation#updateContentFromPath}, or one of the other\n         *    methods to assign a file to the representation. If not, you will get an {@link AdobeLibraryError.INVALID_PARAMETER} error.\n         * 4. Changing this property on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {Number|undefined}\n         * @instance\n         */\n        height: {\n            get: function () {\n                if (this._dcxComponent) {\n                    return this._dcxComponent.getValue('height');\n                }\n                return this._dcxNode.getValue(AdobeLibraryConfig.HEIGHT_KEY);\n            },\n            set: function (height) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id);\n                }\n                if (!this._dcxComponent && !this.isExternalLink()) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot set height on a representation without contents', this._element._library.id);\n                }\n                if (typeof height !== 'number' || height < 0) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid height', this._element._library.id);\n                }\n                if (this._dcxComponent) {\n                    this._dcxComponent.setValue('height', height);\n                } else {\n                    this._dcxNode.setValue(AdobeLibraryConfig.HEIGHT_KEY, height);\n                }\n                this._commit();\n            }\n        },\n        /**\n         * A flag indicating whether the image corresponding to the representation is full size, or a scaled-down version (such\n         * as a thumbnail). To modify this property, just assign it a new value, and it will automatically save and sync the\n         * change to the server.\n         *\n         * Notes:\n         *\n         * 1. This property only makes sense if the representation corresponds to something with dimensions, e.g. an image.\n         * 2. It's up to the client to set this property whenever a representation corresponding to an image is created.\n         * 3. This can only be set after calling {@link AdobeLibraryRepresentation#updateContentFromPath}, or one of the other\n         *    methods to assign a file to the representation. If not, you will get an {@link AdobeLibraryError.INVALID_PARAMETER} error.\n         * 4. Changing this property on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {Boolean|undefined}\n         * @instance\n         */\n        isFullSize: {\n            get: function () {\n                return this._getDCXElement().getValue(AdobeLibraryConfig.IS_FULL_SIZE_KEY);\n            },\n            set: function (isFullSize) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id);\n                }\n                if (!this._dcxComponent && !this.isExternalLink()) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot set isFullSize on a representation without contents', this._element._library.id);\n                }\n                if (typeof isFullSize !== 'boolean') {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid isFullSize', this._element._library.id);\n                }\n                this._getDCXElement().setValue(AdobeLibraryConfig.IS_FULL_SIZE_KEY, isFullSize);\n                this._commit();\n            }\n        },\n        /**\n         * The length of the content, in bytes, for a representation with contents (i.e. you've called\n         * {@link AdobeLibraryRepresentation#updateContent}, {@link AdobeLibraryRepresentation#updateContentFromPath},\n         * or {@link AdobeLibraryRepresentation#updateContentFromURL}).\n         *\n         * Changing this property on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception,\n         * and changing it on a representation that is not an external link, will result in a {@link AdobeLibraryError.READ_ONLY}\n         * exception.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {Number|undefined}\n         * @instance\n         */\n        contentLength: {\n            get: function () {\n                if (this.isExternalLink()) {\n                    return this._dcxNode.getValue(AdobeLibraryConfig.LENGTH_KEY);\n                }\n                if (this._dcxComponent) {\n                    if (this._dcxComponent.length === undefined && AdobeLibraryServices.hasFileSystem()) {\n                        // It's a component that hasn't been uploaded to the server, so it doesn't have a content length\n                        // Instead, we'd better read it from disk (we do that synchronously, to avoid making the whole function async)\n                        var componentPath = this._getCurrentComponentPath();\n                        var statSync = 'statSync';\n                        try {\n                            var stats = AdobeLibraryServices.fs[statSync](componentPath);\n                            return stats && stats.size;\n                        } catch (ignore) {\n                        }\n                    }\n                    return this._dcxComponent.length;\n                }\n                return undefined;\n            },\n            set: function (length) {\n                if (!this.isExternalLink()) {\n                    throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'setContentLength can only be used for an externally-linked representation', this._element._library.id);\n                }\n\n                if (typeof length !== 'number' || length < 0) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid content length', this._element._library.id);\n                }\n\n                this._dcxNode.setValue(AdobeLibraryConfig.LENGTH_KEY, length);\n                this._commit();\n            }\n        },\n        /**\n         * This is `true`, if and only if the representation is deleted locally. This is the case if the representation\n         * has been removed, or if the element or library it belongs to were deleted. You should stop referencing the\n         * representation - any further operations will be met with an error.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryRepresentation\n         * @type {Boolean}\n         * @instance\n         */\n        deletedLocally: {\n            get: function () {\n                return this._deletedLocally;\n            },\n            set: function (element) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'deletedLocally is a read-only property', this._element._library.id);\n            }\n        }\n    });\n\n    /**\n     * Find out if the type of the representation is equal to, or a subtype of, the specified mime type. In addition,\n     * this method checks if the extension of the representation's content path (if any) matches with the representation's\n     * content type. This lets us know whether it is safe to read the representation as the type we want (for example, if we\n     * know how to read SVG, but the representation has a more specific type, corresponding to a more specific SVG format, then\n     * it's safe to read the data as SVG, but not to write it back without knowing the more specific format).\n     *\n     * Note: Since we don't currently have any sub-type information built into the library, this is equivalent\n     * to the expression `representation.type === type` && 'path extension matches the content type if the representation\n     * has a file associated with it'.\n     *\n     * @param {String} type The mime type to compare the representation type to.\n     * @returns {Boolean} Whether the type is compatible for reading.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.isCompatibleType = function (type) {\n        if (this._dcxComponent) {\n            var extension = AdobeLibraryFileUtils.getFileExtension(this._dcxComponent.path);\n            var extensions = AdobeLibraryMimeTypeUtils.getExtensions(type);\n            if (extensions.indexOf(extension) === -1) {\n                return false; // Extension and content-type doesn't match therefore not compatible.\n            }\n        }\n\n        return AdobeLibraryManifestUtils.isCompatibleType(type, this.type);\n    };\n\n    // Custom toString method for debugging - don't show internal fields\n    AdobeLibraryRepresentation.prototype.toString = function () {\n        return JSON.stringify(this._toJSON());\n    };\n\n    /**\n        Inline data (stored in manifest)\n    **/\n\n    /**\n     * Get a property of the representation. Properties are used to store simple data that doesn't belong in a separate\n     * file (e.g. for colours, or text styles), or to add app-specific metadata about the content of the representation.\n     * All properties are namespaced.\n     *\n     * Example: The data for a colour element is obtained by calling `getValue('color', 'data')'`.\n     * For more details for the different element types, see\n     * [Creative Cloud Libraries Element Specifications](https://wiki.corp.adobe.com/display/ccprojects/Creative+Cloud+Libraries+Element+Specifications)\n     *\n     * @param {String} namespace The namespace of the property (this will either be specific to the element type,\n     * or specific to your application if you are the only one who needs to read this data).\n     * @param {String} key The name of the property.\n     * @returns {Object} The value of the property. The format depends on the property, so this may be an object with nested\n     * properties, or a simple value like a string or a number.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER}\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.getValue = function (namespace, key) {\n        // Check that you're not using a reserved namespace (i.e. the library namespace)\n        if (namespace === AdobeLibraryConfig.DL_NAMESPACE) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Reserved namespace', this._element._library.id);\n        }\n\n        var dcxKey = AdobeLibraryManifestUtils.getDCXKey(namespace, key);\n        return this._getDCXElement().getValue(dcxKey);\n    };\n\n    /**\n     * Get all properties of the representation. See {@link AdobeLibraryRepresentation#getValue}. This allows you to discover\n     * all custom properties set on the representation, without knowing the namespace and key.\n     *\n     * @returns {Array.<Object>} An array of all the properties of the representation. Each object in the array has the properties\n     * `namespace`, `key`, and `value`, such that `representation.getValue(o.namespace, o.key) === o.value`.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.getValues = function () {\n        return AdobeLibraryManifestUtils.getCustomDCXData(this._getDCXElement());\n    };\n\n    /**\n     * Set a property of the representation. Properties are used to store simple data that doesn't belong in a separate\n     * file (e.g. for colours, or text styles), or to add app-specific metadata about the content of the representation.\n     * All properties are namespaced.\n     *\n     * Example: The data for a colour element is set by calling `setValue('color', 'data', colorData)'`.\n     * For more details for the different element types, see\n     * [Creative Cloud Libraries Element Specifications](https://wiki.corp.adobe.com/display/ccprojects/Creative+Cloud+Libraries+Element+Specifications)\n     *\n     * @param {String} namespace The namespace of the property (this will either be specific to the element type,\n     * or specific to your application if you are the only one who needs to read this data).\n     * @param {String} key The name of the property.\n     * @param {Object} value The value to set the property to. This can be any Javascript value or object that\n     * can be serialised to JSON.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER|AdobeLibraryError.DELETED_LOCALLY}\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.setValue = function (namespace, key, value) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id);\n        }\n\n        // Check that you're not using a reserved namespace (i.e. the library namespace)\n        if (namespace === AdobeLibraryConfig.DL_NAMESPACE) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Reserved namespace', this._element._library.id);\n        }\n\n        var dcxKey = AdobeLibraryManifestUtils.getDCXKey(namespace, key);\n\n        // Make sure the value is valid JSON, and take a copy:\n        var newValue;\n        try {\n            newValue = JSON.parse(JSON.stringify(value));\n        } catch (e) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Value cannot be serialized to JSON', this._element._library.id);\n        }\n\n        this._getDCXElement().setValue(dcxKey, newValue);\n        this._commit();\n    };\n\n    /**\n        Content (this is data that gets stored in a component - i.e. in a file on disk)\n    **/\n\n    /**\n     * Update the content of the representation. Note that if the content you want to add already exists as a file\n     * on disk, it's much easier to call {@link AdobeLibraryRepresentation#updateContentFromPath}.\n     *\n     * Calling this on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {String|Buffer|Blob|ArrayBuffer} content The content to add to the representation.\n     * @param {String} encoding The encoding of `content`. In a filesystem environment, this is either\n     * `'utf8'`, `'ascii'`, `'base64'`, or `'buffer'` (the latter is a node.js [Buffer](http://nodejs.org/docs/v0.8.26/api/buffer.html)).\n     * In a browser environment, this parameter must be set to `undefined` - the type is determined by the `content` parameter: This\n     * can either be a Blob (e.g. a File object), an ArrayBuffer, or a text string.\n     * @param {String} [fileName] The original file name of the content - we use this so we can preserve the file extension whenever\n     * it's written to disk. Most of the desktop applications depend on the file extension, so this is important.\n     * @param {Function} callback This gets called when the content has been updated.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.updateContent = function (content, encoding, fileName, callback) {\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        if (!this.writable) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id));\n            return;\n        }\n\n        if (this._dcxComponent || this.isExternalLink()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot modify representation content once set', this._element._library.id));\n            return;\n        }\n\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            // In-browser case\n            if (encoding !== undefined) {\n                callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Encoding parameter not supported in-browser'));\n                return;\n            }\n\n            this._setComponentInBrowser(content, fileName, callback);\n\n        } else {\n            // Filesystem case\n            if (!AdobeLibraryManifestUtils.checkEncoding(encoding, ['utf8', 'ascii', 'base64', 'buffer'], callback)) { return; }\n\n            this._setComponent(content, encoding, fileName, callback);\n        }\n    };\n\n    /**\n     * Update the content of the representation, with the given file.\n     *\n     * Note: You can only set the content of a representation once. To change the content of a representation, you need\n     * to remove it, and add a new representation. This limitation is imposed because of the current server-side behaviour,\n     * so that we can ensure library consistency.\n     *\n     * This requires a filesystem (otherwise, you'll get a {@link AdobeLibraryError.REQUIRES_FILESYSTEM} error).\n     *\n     * Calling this on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * Passing in a path to a file that is greater than 1GB on disk, will result in a {@link AdobeLibraryError.FILE_TOO_LARGE} error.\n     *\n     * @param {String} path Path to the file on disk with the new content.\n     * @param {Boolean} [moveFile=false] Whether to move the file at the specified path, rather than copying it. By default, the\n     * file will be copied.\n     * @param {Function} callback This gets called when the content has been updated.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.updateContentFromPath = function (path, moveFile, callback) {\n\n        // Allow you to omit the moveFile parameter\n        if (typeof moveFile === 'function') {\n            callback = moveFile;\n            moveFile = false;\n        }\n\n        // Content path requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'path-based APIs require a filesystem', this._element._library.id));\n            return;\n        }\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        if (!this.writable) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id));\n            return;\n        }\n\n        if (this._dcxComponent || this.isExternalLink()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot modify representation content once set', this._element._library.id));\n            return;\n        }\n\n        this._setComponentFromPath(path, !moveFile, callback);\n    };\n\n    /**\n     * Update the content of the representation, with the given URL. This downloads the contents of the URL, and sets this\n     * as the representation content.\n     *\n     * Note: You can only set the content of a representation once. To change the content of a representation, you need\n     * to remove it, and add a new representation. This limitation is imposed because of the current server-side behaviour,\n     * so that we can ensure library consistency.\n     *\n     * Note: this is not yet implemented for the in-browser environment (you'll get a\n     * {@link AdobeLibraryError.NOT_IMPLEMENTED} error).\n     *\n     * Calling this on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Boolean} createLink If `true`, the URL you provide will be stored in\n     * @param {String} url The URL to download the content from (we perform a GET request).\n     * @param {Object} [headers] Custom headers to set when calling the URL. Note that the `'Authorization'` header is\n     * automatically set, with the access token of the current user.\n     * @param {Function} callback This gets called when the content has been updated.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.updateContentFromURL = function (createLink, url, headers, callback) {\n\n        // Content path requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem() && !createLink) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_IMPLEMENTED, 'not yet implemented updateContentFromURL without a filesystem', this._element._library.id));\n            return;\n        }\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        if (!this.writable) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._element._library.id));\n            return;\n        }\n\n        if (typeof createLink !== 'boolean') {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid createLink parameter: must be Boolean', this._element._library.id));\n            return;\n        }\n\n        if (this._dcxComponent || this.isExternalLink()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot modify representation content once set', this._element._library.id));\n            return;\n        }\n\n        // Is it an external link? If so, just a manifest modification\n        if (createLink) {\n            this._dcxNode.setValue(AdobeLibraryConfig.LINK_TYPE_KEY, this._dcxNode.type);\n            this._dcxNode.type = AdobeLibraryConfig.LINK_REPRESENTATION_TYPE;\n            this._dcxNode.setValue(AdobeLibraryConfig.LINK_URL_KEY, url);\n\n            // Save changes and return immediately\n            this._commit();\n            callback(null);\n            return;\n        }\n\n        var that = this;\n        var collection = this.element.library.collection;\n        var tempDir = collection._getTempDir();\n        AdobeLibraryServices.storageInterface.getAssetFromURL(collection, url, headers, tempDir, function (err, tempFilePath, etag, response) {\n            if (err) {\n                callback(AdobeLibraryErrorUtils.getSyncError(err));\n                return;\n            }\n\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            // If we have a content type header in the response, we'll use that to generate a file name for the downloaded content\n            var contentType = AdobeLibrarySyncUtils.getContentTypeHeader(response && response.headers);\n            if (contentType) {\n                var extension = AdobeLibraryMimeTypeUtils.getExtensions(contentType)[0];\n                var tempFilePathWithExtension = tempFilePath + '.' + extension;\n\n                // Rename, so the temp file has the correct extension (this gets preserved by DCX)\n                AdobeLibraryServices.fs.rename(tempFilePath, tempFilePathWithExtension, function (err) {\n                    if (err) {\n                        callback(AdobeLibraryErrorUtils.getCommitError(err));\n                        return;\n                    }\n\n                    // Move, rather than copying the file, when setting the component\n                    that._setComponentFromPath(tempFilePathWithExtension, false, callback);\n                });\n            } else {\n\n                // Move, rather than copying the file, when setting the component\n                that._setComponentFromPath(tempFilePath, false, callback);\n            }\n        });\n    };\n\n    /**\n     * Get the path to the file on disk that holds the content of the representation. This is the content set\n     * by calling {@link AdobeLibraryRepresentation#updateContent}, {@link AdobeLibraryRepresentation#updateContentFromPath},\n     * or {@link AdobeLibraryRepresentation#updateContentFromURL}.\n     *\n     * Note: this call is asynchronous, because we may need to download the content from the server, if it isn't already\n     * stored locally (e.g. if you specify `'manifestOnly'` as the `SYNC_POLICY` option for {@link ccLibraries.startup}).\n     *\n     * This requires a filesystem (otherwise, you'll get a {@link AdobeLibraryError.REQUIRES_FILESYSTEM} error).\n     *\n     * Calling this on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Function} callback This gets called with the path to the content.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {String} callback.path The path on disk to the contents of the representation,\n     * or `null` if the representation has no content.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.getContentPath = function (callback) {\n\n        // Content path requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'path-based APIs require a filesystem', this._element._library.id));\n            return;\n        }\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        this._getComponentPath(callback);\n    };\n\n    /**\n     * Get the cached path to the file on disk that holds the content of the representation. This is equivalent to calling\n     * {@link AdobeLibraryRepresentation#getContentPath}, except that it doesn't trigger the download of the content if it\n     * is not already cached.\n     *\n     * This is a synchronous call, and will return the cached content path if there is one, or `undefined` if either the\n     * representation has no content, or the content has not yet been downloaded.\n     *\n     * @returns {String} The cached path on disk to the contents of the representation,\n     * or `undefined` if there is no cached content.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.getCachedContentPath = function () {\n\n        // Content path requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            return undefined;\n        }\n\n        if (this.isExternalLink()) {\n            var cachedPath = this._getCachedExternalLinkPath();\n            return cachedPath.path;\n        }\n        if (this._dcxComponent) {\n            return this._getCurrentComponentPath() || undefined;\n        }\n\n        // Not a component or an external link\n        return undefined;\n    };\n\n    /**\n     * Get the data stored in the content of the representation, by reading the file from disk (in a filesystem environment), or by\n     * downloading it (in a browser environment). This is the content set\n     * by calling {@link AdobeLibraryRepresentation#updateContent}, {@link AdobeLibraryRepresentation#updateContentFromPath},\n     * or {@link AdobeLibraryRepresentation#updateContentFromURL}.\n     *\n     * Calling this on a deleted representation will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {String} encoding The encoding to use, when reading the content from disk. In a filesystem environment, this is either\n     * `'utf8'`, `'ascii'`, `'base64'`, or `'buffer'` (the latter is a node.js [Buffer](http://nodejs.org/docs/v0.8.26/api/buffer.html)).\n     * In a browser environment, this is either `'text'`, `'blob'`, or `'arraybuffer'`.\n     * @param {Function} callback This gets called when the representation's content has been loaded.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {String|Buffer|Blob|ArrayBuffer} callback.data The content of the representation,\n     * or `null` if the representation has no content.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.getContent = function (encoding, _callback) {\n        var fs = AdobeLibraryServices.fs;\n        var that = this;\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, _callback)) { return; }\n\n        // Content path requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            // In-browser case: fetch contents\n            if (!AdobeLibraryManifestUtils.checkEncoding(encoding, ['text', 'blob', 'arraybuffer'], _callback)) { return; }\n\n            if (!this._dcxComponent) {\n                // No contents\n                _callback(null);\n                return;\n            }\n\n            var syncManager = this._element._library._collection._syncManager;\n            syncManager.getSharedCloudContent(this, encoding, _callback);\n\n        } else {\n            // Filesystem case: read component from disk\n            if (!AdobeLibraryManifestUtils.checkEncoding(encoding, ['utf8', 'ascii', 'base64', 'buffer'], _callback)) { return; }\n\n            this._getComponentPath(function (err, componentPath) {\n                if (err || !componentPath) {\n                    // No content\n                    _callback(err);\n                    return;\n                }\n\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, _callback)) { return; }\n\n                var callback = function (err, data) {\n                    if (err) {\n                        AdobeLibraryErrorUtils.getCommitError(err, that._element._library.id, 'error reading content from disk');\n                    }\n\n                    _callback(err, data);\n                };\n\n                if (encoding === 'buffer') {\n                    fs.readFile(componentPath, callback);\n                } else {\n                    fs.readFile(componentPath, encoding, callback);\n                }\n\n            });\n        }\n    };\n\n    /**\n     * Get a URL to the contents of the representation, if it has any contents.\n     * This does not include the access token, or any other headers that may be required when calling the url.\n     *\n     * If the representation is an external link (created by calling {@link AdobeLibraryRepresentation#updateContentFromURL}, passing\n     * in `true` as the first parameter), then this will return thr URL\n     *\n     * @returns {String} The URL of the representation contents, or `undefined` if the representation has no content.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     * @see {@link AdobeLibraryRepresentation#getAuthenticatedContentURL}, {@link AdobeLibraryRepresentation#getContent}\n     */\n    AdobeLibraryRepresentation.prototype.getContentURL = function () {\n        if (this.isExternalLink()) {\n            return this._dcxNode.getValue(AdobeLibraryConfig.LINK_URL_KEY);\n        }\n\n        if (this._dcxComponent) {\n            var syncManager = this._element._library._collection._syncManager;\n            return syncManager.getSharedCloudContentURL(this);\n        }\n\n        // Not a normal component, and not an external link\n        return undefined;\n    };\n\n    /**\n     * Get a URL to the contents of the representation, if it has any contents.\n     * The URL is self-contained (including the access token), so you can call it by doing a simple GET, without\n     * setting any headers.\n     *\n     * @param {Function} callback This gets called with the URL.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {String} callback.url The URL of the representation contents, or `undefined` if the representation has no content.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     * @see {@link AdobeLibraryRepresentation#getContentURL}, {@link AdobeLibraryRepresentation#getContent}\n     */\n    AdobeLibraryRepresentation.prototype.getAuthenticatedContentURL = function (callback) {\n        var url = this.getContentURL();\n        var syncManager = this._element._library._collection._syncManager;\n        syncManager.appendAccessTokenToURL(url, callback);\n    };\n\n    /**\n     * Returns a Boolean, indicating whether the representation is an external link. If `true`, this means that the content\n     * for the representation is not embedded in the DCX; instead, it's downloaded from an external URL.\n     *\n     * To create a representation that's an external link, call {@link AdobeLibraryRepresentation#updateContentFromURL}, passing\n     * `true` as the first parameter.\n     *\n     * @returns {Boolean} Whether the representation is an external link.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.isExternalLink = function () {\n        return this._dcxNode !== undefined && this._dcxNode.type === AdobeLibraryConfig.LINK_REPRESENTATION_TYPE;\n    };\n\n    /**\n     * Test whether the external link is valid, by doing a HEAD request on the link. This will only return `false` if\n     * we know for sure it's not valid (e.g. the server returned a 404 or 403). If we're not sure, we'll return\n     * `true`, so calling this at a later time may result in it returning `false`.\n     *\n     * The result of the HEAD request is cached (unless it's an intermittent fault like a server error or network failure),\n     * so if the server returns a 404 on the first attempt, calling `testExternalLink` again will always return `false`, without\n     * doing additional HEAD requests.\n     *\n     * @param {Function} callback This gets called with the results of the test.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {Boolean} callback.success `false` if the external link is broken (e.g. it doesn't exist on the server, or\n     * we don't have access to it); `true` if it the link is available, or we're not sure.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.testExternalLink = function (callback) {\n\n        if (!this.isExternalLink() || !this.getContentURL()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Not an external link', this._element._library.id));\n            return;\n        }\n\n        this._testExternalLink(callback);\n    };\n\n    /**\n     * Synchronous call to return a cached error as a result of testing or downloading the external link. This is the same as\n     * calling {@link AdobeLibraryRepresentation#testExternalLink}, except that it does not perform a HEAD request if the\n     * result of testing the external link is not already cached.\n     *\n     * @returns {AdobeLibraryError} The cached error, or `null` if success or no cached error.\n     *\n     * @memberof AdobeLibraryRepresentation\n     * @instance\n     */\n    AdobeLibraryRepresentation.prototype.getCachedExternalLinkError = function () {\n\n        if (!this.isExternalLink() || !this.getContentURL()) {\n            return new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Not an external link', this._element._library.id);\n        }\n\n        var cachedPath = this._getCachedExternalLinkPath();\n        return cachedPath.err;\n    };\n\n    return AdobeLibraryRepresentation;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define, console */\n\n/**\n * @class AdobeLibraryAnalytics\n * @classdesc\n * Analytics service that know how to report metrics via analytics objects passed in startup.\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryAnalytics',['require','exports','module','./AdobeLibraryServices','./AdobeLibraryConfig'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n\n    var lastUpdatedElement;\n    var lastUpdatedElementOn;\n\n    function getElementType(element) {\n        if (element.type) {\n            var matches = element.type.match(/application\\/vnd\\.adobe\\.element\\.(.*)\\+dcx/);\n\n            return (matches && matches.length === 2) ? matches[1] : element.type;\n        }\n\n        return null;\n    }\n\n    function getLibraryProperties(library) {\n        if (!library) {\n            return {};\n        }\n\n        var properties = {\n            libraryID: library.id,\n            libraryElementCount: library._elements.length\n        };\n\n        if (library.collaboration) {\n            properties.libraryShared = library.collaboration;\n        }\n\n        return properties;\n    }\n\n    function getElementTrackingData(element) {\n        // tracking data is stored in values with the key 'trackingdata' in the primary representation\n        var primary = element.getPrimaryRepresentation();\n\n        var trackingdata = null;\n        if (primary) {\n            primary.getValues().forEach(function (value) {\n                if (value.key === 'trackingdata') {\n                    if (!trackingdata) {\n                        trackingdata = {};\n                    }\n                    trackingdata[value.namespace] = value.value;\n                }\n            });\n        }\n        return trackingdata;\n    }\n\n    function getElementProperties(element) {\n        if (!element) {\n            return {};\n        }\n\n        var properties = getLibraryProperties(element._library);\n        properties.elementID = element.id;\n        properties.elementType = getElementType(element);\n\n        var trackingdata = getElementTrackingData(element);\n        if (trackingdata) {\n            properties.trackingData = JSON.stringify(trackingdata);\n        }\n\n        return properties;\n    }\n\n    function getRepresentationProperties(representation) {\n        if (!representation) {\n            return {};\n        }\n\n        var properties = getElementProperties(representation._element);\n        properties.representationType = representation.type;\n\n        return properties;\n    }\n\n    function isReportingEnabled() {\n        return AdobeLibraryServices.analytics !== null && AdobeLibraryServices.analytics !== undefined;\n    }\n\n    function reportError(error) {\n        if (isReportingEnabled() && error) {\n            AdobeLibraryServices.analytics.reportError(error.code + (error.underlyingError ? (':' + error.underlyingError.code) : ''));\n        }\n    }\n\n    var reportCreateLibrary = function (library) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('createLibrary', { libraryID: library.id });\n        }\n    };\n\n    var reportDeleteLibrary = function (library) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('deleteLibrary', getLibraryProperties(library));\n        }\n    };\n\n    var reportCreateElement = function (element) {\n        if (isReportingEnabled()) {\n            lastUpdatedElement = element;\n            lastUpdatedElementOn = Date.now();\n\n            AdobeLibraryServices.analytics.reportEvent('createElement', getElementProperties(element));\n        }\n    };\n\n    var reportUpdateElement = function (element, onlyInfoChanged) {\n        if (isReportingEnabled()) {\n            if (element === lastUpdatedElement) {\n                if (Date.now() - lastUpdatedElementOn < AdobeLibraryConfig.ANALYTICS_ELEMENT_UPDATE_THRESHOLD) {\n                    // We have reported the update on the same element within this threshold, so ignore this one.\n                    // The reason we perform this check is because element.commit gets called everytime a new representation\n                    // added or removed (one per each change) and one update can included several representation changes.\n                    return;\n                }\n            }\n\n            lastUpdatedElement = element;\n            lastUpdatedElementOn = Date.now();\n\n            var properties = getElementProperties(element);\n            properties.updateType = (onlyInfoChanged ? 'info' : 'representation');\n\n            AdobeLibraryServices.analytics.reportEvent('updateElement', properties);\n        }\n    };\n\n    var reportUseElement = function (representation, opType, details) {\n        if (isReportingEnabled()) {\n            var properties = getRepresentationProperties(representation);\n            properties.opType = opType;\n            properties.details = details;\n\n            AdobeLibraryServices.analytics.reportEvent('useElement', properties);\n        }\n    };\n\n    var reportCheckoutElement = function (element, details) {\n        if (isReportingEnabled()) {\n            var properties = getElementProperties(element);\n            properties.details = details;\n\n            AdobeLibraryServices.analytics.reportEvent('checkoutElement', properties);\n        }\n    };\n\n    var reportDeleteElement = function (element) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('deleteElement', getElementProperties(element));\n        }\n    };\n\n    var reportCopyElement = function (element, oldElement) {\n        if (isReportingEnabled()) {\n            lastUpdatedElement = element;\n            lastUpdatedElementOn = Date.now();\n\n            var properties = getElementProperties(element);\n            properties.oldLibraryID = oldElement._library.id;\n            properties.oldElementID = oldElement.id;\n\n            AdobeLibraryServices.analytics.reportEvent('copyElement', properties);\n        }\n    };\n\n    var reportMoveElement = function (element, oldElement) {\n        if (isReportingEnabled()) {\n            lastUpdatedElement = element;\n            lastUpdatedElementOn = Date.now();\n\n            var properties = getElementProperties(element);\n            properties.oldLibraryID = oldElement._library.id;\n            properties.oldElementID = oldElement.id;\n\n            AdobeLibraryServices.analytics.reportEvent('moveElement', properties);\n        }\n    };\n\n    var reportCollisionElement = function (element) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('collisionLibrary', getElementProperties(element));\n        }\n    };\n\n    var reportCreateRepresentation = function (representation) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('createRepresentation', getRepresentationProperties(representation));\n        }\n    };\n\n    var reportDeleteRepresentation = function (representation) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('deleteRepresentation', getRepresentationProperties(representation));\n        }\n    };\n\n    var reportCreateLink = function (element, opType) {\n        if (isReportingEnabled()) {\n            var properties = getElementProperties(element);\n            properties.opType = opType;\n            AdobeLibraryServices.analytics.reportEvent('createLink', properties);\n        }\n    };\n\n    var reportShareElementLink = function (element) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('shareElementLink', getElementProperties(element));\n        }\n    };\n\n    var reportShareLibraryLink = function (library) {\n        if (isReportingEnabled()) {\n            AdobeLibraryServices.analytics.reportEvent('shareLibraryLink', getLibraryProperties(library));\n        }\n    };\n\n    var reportUnexpectedState = function (library, details) {\n        if (isReportingEnabled()) {\n            var properties = getLibraryProperties(library);\n            properties.details = details;\n            properties.logs = true;\n\n            AdobeLibraryServices.analytics.reportEvent('unexpectedState', properties);\n        }\n    };\n\n    return {\n        reportCreateLibrary: reportCreateLibrary,\n        reportDeleteLibrary: reportDeleteLibrary,\n        reportCreateElement: reportCreateElement,\n        reportUpdateElement: reportUpdateElement,\n        reportCopyElement: reportCopyElement,\n        reportMoveElement: reportMoveElement,\n        reportUseElement: reportUseElement,\n        reportCheckoutElement: reportCheckoutElement,\n        reportDeleteElement: reportDeleteElement,\n        reportCollisionElement: reportCollisionElement,\n        reportCreateRepresentation: reportCreateRepresentation,\n        reportDeleteRepresentation: reportDeleteRepresentation,\n        reportCreateLink: reportCreateLink,\n        reportShareElementLink: reportShareElementLink,\n        reportShareLibraryLink: reportShareLibraryLink,\n        reportError: reportError,\n        reportUnexpectedState: reportUnexpectedState\n    };\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, ArrayBuffer, Uint8Array */\n\n/**\n * @class AdobeLibraryLock\n * @classdesc\n * Obtaining and releasing locks, for asynchronous operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryLock',['require','exports','module'],function (require, exports, module) {\n    'use strict';\n\n    // Constructor\n    // Note: this is for internal use by the design library\n    function AdobeLibraryLock() {\n        this._isLocked = false;\n        this._pendingContinuations = [];\n    }\n\n    /**\n        Public API\n    **/\n\n    AdobeLibraryLock.prototype.obtain = function (continuation, thisObject) {\n        if (this._isLocked) {\n            this._pendingContinuations.push({continuation: continuation, thisObject: thisObject});\n        } else {\n            this._isLocked = true;\n            continuation.apply(thisObject, [null]);\n        }\n    };\n\n    AdobeLibraryLock.prototype.release = function () {\n        if (this._pendingContinuations.length > 0) {\n            var cont = this._pendingContinuations.shift();\n            setTimeout(function () {\n                cont.continuation.apply(cont.thisObject, [null]);\n            });\n        } else {\n            this._isLocked = false;\n        }\n    };\n\n    AdobeLibraryLock.prototype.abortPendingOperations = function (error) {\n        var continuations = this._pendingContinuations;\n        this._pendingContinuations = [];\n\n        continuations.forEach(function (cont) {\n            cont.continuation.apply(cont.thisObject, [error]);\n        });\n    };\n\n    AdobeLibraryLock.prototype.isLocked = function () {\n        return this._isLocked;\n    };\n\n    AdobeLibraryLock.prototype.hasPendingRequest = function () {\n        return this._pendingContinuations.length > 0;\n    };\n\n    return AdobeLibraryLock;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryAsyncJoin\n * @classdesc\n * A utility for joining asynchronous operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryAsyncJoin',['require','exports','module','../AdobeLibraryError'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryError = require('../AdobeLibraryError');\n\n    // Constructor\n    function AdobeLibraryAsyncJoin() {\n        this._operations = [];\n        this._isRunning = false;\n    }\n\n    // Queue up an operation\n    // An operation is a function that will be called with the given array of arguments, plus\n    // a callback argument at the end, provided by us.\n    // It should call the callback precisely once, with two parameters: error, and optional result\n    AdobeLibraryAsyncJoin.prototype.addOperation = function (operation, argsArray, thisObject) {\n\n        if (this._isRunning) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot add operations after calling run()');\n        }\n\n        this._operations.push({\n            operation: operation,\n            argsArray: argsArray || [],\n            thisObject: thisObject\n        });\n    };\n\n    // Run all the operations in parallel, and call the callback on completion\n    // Callback gets called with:\n    //   err: the first error that happens (if any)\n    //   hasResults: a boolean that's true if any of the results are non-falsy\n    //   results: an array of the return values for all the operations\n    AdobeLibraryAsyncJoin.prototype.run = function (_callback, reportErrorFunction) {\n\n        function callback(err, hasResults, results) {\n            if (_callback) {\n                _callback(err, hasResults, results);\n            }\n        }\n\n        if (this._isRunning) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot call run() more than once');\n        }\n\n        // Mark as running, so we prevent you from running again, or adding any new operations\n        this._isRunning = true;\n\n        var numOperations = this._operations.length;\n        if (numOperations === 0) {\n            callback(null, false, []);\n        }\n\n        var count = 0;\n        var hasReturned = false;\n        var lastError;\n        var completed = [];\n        var results = [];\n        function finishedCallback(err, result, index) {\n            if (err && reportErrorFunction) {\n                reportErrorFunction(err);\n            }\n\n            // Don't continue if we already made the callback - this ensures we only ever do the callback once\n            if (hasReturned) {\n                return;\n            }\n\n            lastError = lastError || err;\n\n            // Return an error if the same operation completes multiple times\n            if (completed[index]) {\n                hasReturned = true;\n                callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Operation not valid: calls callback multiple times'));\n                return;\n            }\n\n            count++;\n            results[index] = result;\n            completed[index] = true;\n\n            if (count === numOperations) {\n                hasReturned = true;\n                var hasResults = results.reduce(function (a, b) { return a || b; }, false) ? true : false;\n                callback(lastError || null, hasResults, results);\n            }\n        }\n\n        this._operations.forEach(function (op, index) {\n\n            // Add the callback to the end of the operation's list of arguments\n            op.argsArray.push(function (err, result) {\n                finishedCallback(err, result, index);\n            });\n\n            op.operation.apply(op.thisObject, op.argsArray);\n        });\n    };\n\n    return AdobeLibraryAsyncJoin;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2015 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define */\n\n/**\n * @class AdobeLibraryRenditionUtils\n * @classdesc\n * Utility functions for CC Library rendition operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryRenditionUtils',['require','exports','module','../AdobeLibraryConfig','../AdobeLibraryServices','./AdobeLibraryAsyncJoin','./AdobeLibraryFileUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryConfig = require('../AdobeLibraryConfig');\n    var AdobeLibraryServices = require('../AdobeLibraryServices');\n    var AdobeLibraryAsyncJoin = require('./AdobeLibraryAsyncJoin');\n    var AdobeLibraryFileUtils = require('./AdobeLibraryFileUtils');\n\n\n    // Static object\n    var AdobeLibraryRenditionUtils = {};\n\n    /**\n        Configuration of supported renditions\n    **/\n\n    // Renditions: list of supported conversions\n    // Obtained from: https://wiki.corp.adobe.com/pages/viewpage.action?spaceKey=cloudservices&title=Format+support\n    // The Storage Service, which we use to perform conversions, uses the \"SpeedOverQuality\" mode to generate thumbnails.\n    // The following table lists all mime-types that can be rendered to PNG using the SpeedOverQuality mode.\n    var PNG_RENDITION_SUPPORTED = {\n        'application/x-indesign':                                                     true,\n        'application/postscript':                                                     true,\n        'application/illustrator':                                                    true,\n        'application/pdf':                                                            true,\n        'application/vnd.adobe.psremix':                                              true,\n        'application/vnd.adobe.pstouch':                                              true,\n        'application/vnd.adobe.ideas':                                                true,\n        'application/vnd.adobe.ase':                                                  true,\n        'image/jpeg':                                                                 true,\n        'image/jpg':                                                                  true,\n        'image/pjpeg':                                                                true,\n        'image/tiff':                                                                 true,\n        'image/gif':                                                                  true,\n        'image/bmp':                                                                  true,\n        'image/x-ms-bmp':                                                             true,\n        'image/svg+xml':                                                              true,\n        'image/png':                                                                  true,\n        'image/x-png':                                                                true,\n        'image/jp2':                                                                  true,\n        'image/psd':                                                                  true,\n        'image/vnd.adobe.photoshop':                                                  true,\n        'application/photoshop':                                                      true,\n        'application/x-photoshop':                                                    true,\n        'image/raw':                                                                  true,\n        'image/dng':                                                                  true,\n        'image/x-adobe-dng':                                                          true,\n        'video/mp4':                                                                  true,\n        'video/mpeg':                                                                 true,\n        'video/x-ms-wmv':                                                             true,\n        'video/3gpp':                                                                 true,\n        'video/3gpp2':                                                                true,\n        'video/quicktime':                                                            true,\n        'video/x-msvideo':                                                            true,\n        'video/x-flv':                                                                true,\n        'video/x-ms-asf':                                                             true,\n        'video/x-m4v':                                                                true,\n        'video/mp2t':                                                                 true,\n        'application/mxf':                                                            true,\n        'application/x-shockwave-flash':                                              true,\n        'application/vnd.adobe.brushes.brush+ucf':                                    true,\n        'application/vnd.adobe.collage':                                              true,\n        'application/vnd.adobe.proto':                                                true,\n        'application/msword':                                                         true,\n        'application/msexcel':                                                        true,\n        'application/mspowerpoint':                                                   true,\n        'application/vnd.ms-publisher':                                               true,\n        'application/vnd.openxmlformats-officedocument.wordprocessingml.document':    true,\n        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':          true,\n        'application/vnd.openxmlformats-officedocument.presentationml.presentation':  true,\n        'application/vnd.adobe.charts+zip':                                           true,\n        'text/plain':                                                                 true,\n        'text/rtf':                                                                   true\n    };\n\n\n    /**\n        Private functions\n    **/\n\n    var gcRenditionCacheItem = function (path, callback) {\n        var fs = AdobeLibraryServices.fs;\n        fs.stat(path, function (err, stat) {\n            if (err) { callback(err); return; }\n\n            if (stat && stat.isDirectory()) {\n                AdobeLibraryFileUtils.recursiveDeleteDirectory(path, callback);\n            } else {\n                fs.unlink(path, callback);\n            }\n        });\n    };\n\n    // AFTER saving the rendition cache, we make sure the files it references actually exist on disk\n    var gcRenditionCache = function (library, renditionCache, callback) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var fs = AdobeLibraryServices.fs;\n\n        // Turn off GC if dcx GC is turned off\n        if (!library._dcxComposite.autoRemoveUnusedLocalFiles) {\n            callback(null);\n            return;\n        }\n\n        // Construct a map of all the files referenced by the rendition cache:\n        var referencedFiles = {};\n        Object.keys(renditionCache.renditions).forEach(function (elementId) {\n            var elementRenditions = renditionCache.renditions[elementId];\n            Object.keys(elementRenditions).forEach(function (size) {\n                var fileName = elementRenditions[size];\n                referencedFiles[fileName] = true;\n\n                // If we the file was added as a pending item, we can safely remove it - it won't get GCed because we have a reference to it!\n                delete library._pendingRenditionCacheItems[fileName];\n            });\n        });\n\n        // Read the contents of the rendition cache directory, and delete any files that aren't in the above map\n        var renditionCachePath = library._getRenditionCacheDir();\n        fs.readdir(renditionCachePath, function (err, files) {\n            if (err) { callback(err); return; }\n\n            var asyncJoin = new AdobeLibraryAsyncJoin();\n\n            files.forEach(function (fileName) {\n                // Normalise fileName\n                var normalFileName = AdobeLibraryFileUtils.normaliseTempFileName(fileName);\n\n                if (fileName !== AdobeLibraryConfig.RENDITION_CACHE_FILE && !referencedFiles[fileName] && !library._pendingRenditionCacheItems[normalFileName]) {\n                    asyncJoin.addOperation(gcRenditionCacheItem, [renditionCachePath + pathSep + fileName]);\n                }\n            });\n\n            asyncJoin.run(callback);\n        });\n    };\n\n\n    /**\n        Public APIs\n    **/\n\n    // Load from disk\n    AdobeLibraryRenditionUtils.readRenditionCacheData = function (library, callback) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var fs = AdobeLibraryServices.fs;\n\n        var renditionCachePath = library._getRenditionCacheDir();\n        fs.readFile(renditionCachePath + pathSep + AdobeLibraryConfig.RENDITION_CACHE_FILE, 'utf8', function (err, cacheData) {\n\n            // Don't mind if we can't read the cache - we can always recover it\n            var renditionCache = {};\n            if (!err && cacheData) {\n                try {\n                    renditionCache = JSON.parse(cacheData);\n                } catch (ignore) {\n                }\n            }\n            renditionCache.renditions = renditionCache.renditions || {};\n\n            callback(null, renditionCache);\n        });\n    };\n\n    // Save to disk\n    AdobeLibraryRenditionUtils.writeRenditionCacheData = function (library, renditionCache, callback) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var fs = AdobeLibraryServices.fs;\n\n        var renditionCachePath = library._getRenditionCacheDir();\n        AdobeLibraryFileUtils.ensurePathExists(renditionCachePath, function (err) {\n            if (err) { callback(err); return; }\n\n            var destPath = renditionCachePath + pathSep + AdobeLibraryConfig.RENDITION_CACHE_FILE;\n            var tempPath = destPath + AdobeLibraryServices.uuid();\n\n            // Write to a temp file, and copy, to ensure it's an atomic write\n            fs.writeFile(tempPath, JSON.stringify(renditionCache, undefined, 2), 'utf8', function (err) {\n                if (err) { callback(err); return; }\n\n                // move to destination\n                fs.rename(tempPath, destPath, function (err) {\n                    if (err) { callback(err); return; }\n\n                    // Garbage-collect any unreferenced renditions\n                    gcRenditionCache(library, renditionCache, callback);\n                });\n            });\n        });\n    };\n\n    // Utility for copying over a rendition cache from one element to another\n    AdobeLibraryRenditionUtils.copyRenditionCache = function (element, oldElement, oldRenditionCache, callback) {\n        var oldRoot = oldElement._library._getRenditionCacheDir() + AdobeLibraryServices.getPathSeparator();\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n\n        var renditions = oldRenditionCache || {};\n        Object.keys(renditions).forEach(function (size) {\n            asyncJoin.addOperation(element.setRenditionCache, [size, oldRoot + renditions[size]], element);\n        });\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            asyncJoin.run();\n            callback(null);\n\n        } else {\n            asyncJoin.run(callback);\n        }\n    };\n\n    // Return true if the given type supports a png rendition\n    AdobeLibraryRenditionUtils.canComputeRenditionFromMimeType = function (mimeType) {\n        if (PNG_RENDITION_SUPPORTED[mimeType]) {\n            return true;\n        }\n        return false;\n    };\n\n    // Return true if the given type supports a png rendition\n    AdobeLibraryRenditionUtils.canComputeRendition = function (representation) {\n        var hasComponent = representation._dcxComponent !== undefined;\n        if (hasComponent && AdobeLibraryRenditionUtils.canComputeRenditionFromMimeType(representation.type)) {\n            return true;\n        }\n        return false;\n    };\n\n    AdobeLibraryRenditionUtils.shouldPrefetchFullRendition = function (element) {\n        var fullRenditionConfig = AdobeLibraryConfig.FULL_RENDITION_CONFIG || {};\n        var fullConfig = fullRenditionConfig[element.type];\n\n        if (!fullConfig) {\n            return false;\n        }\n\n        var shouldGenerateFull = false;\n        Object.keys(fullConfig).forEach(function (id) {\n            var config = fullConfig[id];\n\n            // For now, we only have one supported condition type - we could add more in the future\n            if (config.condition === 'IF_NO_MATCHING_REPRESENTATION' && config.types) {\n                var noMatchingRepresentations = element.representations.every(function (representation) {\n                    return config.types.indexOf(representation.type) === -1;\n                });\n                shouldGenerateFull = shouldGenerateFull || noMatchingRepresentations;\n            }\n        });\n\n        return shouldGenerateFull;\n    };\n\n    // Should we prefetch the content of an external link? By default we shouldn't, but we allow the\n    // config to determine this - it's currently by element type, so either all links for a certain\n    // element type are prefetched (e.g. for images), or none are (e.g. for video).\n    AdobeLibraryRenditionUtils.shouldPrefetchExternalLink = function (representation) {\n        if (!representation.isExternalLink()) {\n            return false;\n        }\n        var prefetchConfig = AdobeLibraryConfig.EXTERNAL_LINK_PREFETCH || {};\n        return prefetchConfig[representation.element.type] ? true : false;\n    };\n\n    // Pre-fetch renditions of the required sizes, after syncing (so they're available for offline use)\n    AdobeLibraryRenditionUtils.prefetchRenditions = function (composite, callback) {\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n\n        var sizeMap = AdobeLibraryConfig.RENDITION_SIZES || {};\n\n        composite.elements.forEach(function (element) {\n            var sizes = sizeMap[element.type] || sizeMap['*'] || [];\n\n            sizes.forEach(function (size) {\n                asyncJoin.addOperation(element.getRenditionPath, [size], element);\n            });\n\n            if (AdobeLibraryRenditionUtils.shouldPrefetchFullRendition(element)) {\n                asyncJoin.addOperation(element.getRenditionPath, [undefined], element);\n            }\n\n            // Also handle pre-fetching of external links\n            element.representations.forEach(function (representation) {\n                if (AdobeLibraryRenditionUtils.shouldPrefetchExternalLink(representation)) {\n                    // Do the download if not already\n                    asyncJoin.addOperation(representation.getContentPath, [], representation);\n                } else if (representation.isExternalLink()) {\n                    // Don't do the download, but still check the link (doing a HEAD request).\n                    asyncJoin.addOperation(representation.testExternalLink, [], representation);\n                }\n            });\n        });\n\n        asyncJoin.run(function (err) {\n            if (callback) {\n                callback(err);\n            }\n        });\n    };\n\n    AdobeLibraryRenditionUtils.addToRenditionSizeConfig = function (newRenditionSizes) {\n        var current = AdobeLibraryConfig.RENDITION_SIZES;\n\n        var currentDefaultSizes = current['*'] || [];\n        currentDefaultSizes = JSON.parse(JSON.stringify(currentDefaultSizes)); // Make a copy\n        var newDefaultSizes = newRenditionSizes['*'] || [];\n\n        // If there are any current element types that don't have a new configuration entry, they should\n        // inherit the default sizes in the new configuration\n        Object.keys(current).forEach(function (elementType) {\n            if (!newRenditionSizes[elementType]) {\n                var sizes = current[elementType];\n                newDefaultSizes.forEach(function (size) {\n                    if (sizes.indexOf(size) === -1) {\n                        sizes.push(size);\n                    }\n                });\n                current[elementType] = sizes;\n            }\n        });\n\n        // Integrate the configuration for all the new element types\n        Object.keys(newRenditionSizes).forEach(function (elementType) {\n            // If we add a new element type, we move over any existing default sizes to this category\n            var sizes = current[elementType] || JSON.parse(JSON.stringify(currentDefaultSizes));\n            var newSizes = newRenditionSizes[elementType];\n\n            newSizes.forEach(function (size) {\n                if (sizes.indexOf(size) === -1) {\n                    sizes.push(size);\n                }\n            });\n\n            current[elementType] = sizes;\n        });\n\n        AdobeLibraryConfig.setParameter('RENDITION_SIZES', current);\n    };\n\n    AdobeLibraryRenditionUtils.addToFullRenditionConfig = function (newFullSizeConfig) {\n        var current = AdobeLibraryConfig.FULL_RENDITION_CONFIG;\n\n        Object.keys(newFullSizeConfig).forEach(function (elementType) {\n            var conditions = current[elementType] || {};\n            var newConditions = newFullSizeConfig[elementType];\n\n            newConditions.forEach(function (newCondition) {\n                if (newCondition.id) {\n                    conditions[newCondition.id] = newCondition;\n                }\n            });\n\n            current[elementType] = conditions;\n        });\n\n        AdobeLibraryConfig.setParameter('FULL_RENDITION_CONFIG', current);\n    };\n\n    // Utility for updating the pending setRenditionCache operations\n    AdobeLibraryRenditionUtils.addToPendingSetRenditionCache = function (pending, element, size, path, callback) {\n        pending = pending || {data: [], callbacks: []};\n\n        // If we had a pending CLEAR, but we're overwriting it with a set value, we should remove the CLEAR\n        var indicesToRemove = [];\n        pending.data.forEach(function (data, index) {\n            if (!pending.callbacks[index] && data.element === element.id && data.size === size && data.path === 'CLEAR') {\n                indicesToRemove.unshift(index); // Important to add it backwards, so we can use splice when we iterate\n            }\n        });\n        indicesToRemove.forEach(function (index) {\n            pending.data.splice(index, 1);\n            pending.callbacks.splice(index, 1);\n        });\n\n        // Add the cache update\n        pending.data.push({\n            element: element.id,\n            size: size,\n            path: path\n        });\n        pending.callbacks.push(callback);\n\n        return pending;\n    };\n\n    return AdobeLibraryRenditionUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true, regexp: true */\n/*global define */\n\n/**\n * @class AdobeLibraryFeatureUtils\n * @classdesc\n * Utility functions for feature flags - determining what's supported, based on the version of the\n * connected CCLibrary process\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryFeatureUtils',['require','exports','module','../AdobeLibraryServices'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('../AdobeLibraryServices');\n\n\n    // Static object\n    var AdobeLibraryFeatureUtils = {};\n\n\n    /**\n        Public API\n    **/\n\n    // Whether we support clearing the rendition cache.\n    // NOTE: This will always be disabled for now - we want to get the code in, but avoid disrupting existing clients\n    AdobeLibraryFeatureUtils.supportsClearRenditionCache = function () {\n        var serviceInfo = AdobeLibraryServices.storageInterface.getServiceInfo();\n        var serviceVersion = serviceInfo ? serviceInfo.apiVersion : 0;\n\n        return serviceVersion >= 7;\n    };\n\n    return AdobeLibraryFeatureUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, ArrayBuffer, Uint8Array */\n\n/**\n * @class AdobeLibraryListenerManager\n * @classdesc\n * Manager for adding and removing listeners - there's a lot of duplicate code that does the same thing!!\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('utils/AdobeLibraryListenerManager',['require','exports','module','../AdobeLibraryServices','../AdobeLibraryError'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('../AdobeLibraryServices');\n    var AdobeLibraryError = require('../AdobeLibraryError');\n\n\n    // Constructor\n    // Note: this is for internal use by the design library\n    function AdobeLibraryListenerManager(restrictedTypes) {\n        this._restrictedTypes = restrictedTypes;\n        this._listeners = {};\n    }\n\n    AdobeLibraryListenerManager.prototype._checkType = function (type) {\n        if (this._restrictedTypes && this._restrictedTypes.indexOf(type) === -1) {\n            var allowed = '[' + this._restrictedTypes.join(', ') + ']';\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, type + ' is not allowed. Should be one of: ' + allowed);\n        }\n    };\n\n    /**\n        Public API\n    **/\n\n    AdobeLibraryListenerManager.prototype.add = function (type, callback) {\n        this._checkType(type);\n        this._listeners[type] = this._listeners[type] || [];\n        this._listeners[type].push(callback);\n    };\n\n    AdobeLibraryListenerManager.prototype.remove = function (type, callback) {\n        this._checkType(type);\n        var listeners = this._listeners[type];\n        if (listeners) {\n            var index = listeners.indexOf(callback);\n            if (index !== -1) {\n                listeners.splice(index, 1);\n            }\n        }\n    };\n\n    AdobeLibraryListenerManager.prototype.removeAll = function (type) {\n        if (type) {\n            this._checkType(type);\n            delete this._listeners[type];\n        } else {\n            this._listeners = {};\n        }\n    };\n\n    // Safe notification of listeners\n    AdobeLibraryListenerManager.prototype.notify = function (type, args) {\n        this._checkType(type);\n        var listeners = this._listeners[type];\n        if (listeners) {\n            // Important: we make a copy of the listeners array, in case it gets modified by any of the callbacks!\n            listeners.slice(0).forEach(function (callback) {\n                try {\n                    callback.apply(undefined, args || []);\n                } catch (err) {\n                    AdobeLibraryServices.log('Error in listener callback: ' + (err ? err.toString() : ''));\n                    if (err && err.stack) {\n                        AdobeLibraryServices.log(err.stack);\n                    }\n                }\n            });\n        }\n    };\n\n    AdobeLibraryListenerManager.prototype.hasListeners = function (type) {\n        this._checkType(type);\n        var listeners = this._listeners[type];\n        if (listeners && listeners.length > 0) {\n            return true;\n        }\n        return false;\n    };\n\n    AdobeLibraryListenerManager.prototype.forEach = function (callback) {\n        var listeners = this._listeners;\n\n        Object.keys(listeners).forEach(function (type) {\n            listeners[type].forEach(function (cb) {\n                callback(type, cb);\n            });\n        });\n    };\n\n    return AdobeLibraryListenerManager;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, ArrayBuffer, Uint8Array */\n\n/**\n * @class AdobeLibraryElement\n * @classdesc\n * An element in a library.\n *\n * @description\n * This class has a private constructor. The only way to obtain an instance of AdobeLibraryElement\n * is via an {@link AdobeLibraryComposite}.\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryElement',['require','exports','module','./AdobeLibraryServices','./AdobeLibraryConfig','./AdobeLibraryRepresentation','./AdobeLibraryAnalytics','./AdobeLibraryError','./utils/AdobeLibraryLock','./utils/AdobeLibraryManifestUtils','./utils/AdobeLibraryFileUtils','./utils/AdobeLibraryRenditionUtils','./utils/AdobeLibraryErrorUtils','./utils/AdobeLibraryFeatureUtils','./utils/AdobeLibraryListenerManager'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryRepresentation = require('./AdobeLibraryRepresentation');\n    var AdobeLibraryAnalytics = require('./AdobeLibraryAnalytics');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n\n    var AdobeLibraryLock = require('./utils/AdobeLibraryLock');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n    var AdobeLibraryRenditionUtils = require('./utils/AdobeLibraryRenditionUtils');\n    var AdobeLibraryErrorUtils = require('./utils/AdobeLibraryErrorUtils');\n    var AdobeLibraryFeatureUtils = require('./utils/AdobeLibraryFeatureUtils');\n    var AdobeLibraryListenerManager = require('./utils/AdobeLibraryListenerManager');\n\n    // Constructor\n    // Note: you should never call this directly; always through AdobeLibrary.createElement()\n    function AdobeLibraryElement(library, dcxNode) {\n        this._library = library;\n\n        // Internal structures:\n        this._renditionCache = {};\n        this._lock = new AdobeLibraryLock();\n        this._listenerManager = new AdobeLibraryListenerManager(['change']);\n\n        // Load the dcx node:\n        this._setDCXNode(dcxNode);\n    }\n\n    // Private: set a dcx node. Clears out any existing representations and sets them based on the node\n    // This gets called (a) in the constructor, when you add a new element\n    // and (b) during a pull, when we merge into a new branch - we need to swap over the underlying dcx node.\n    // Note: it's up to the caller to notify the change listeners, if indeed anything changed\n    AdobeLibraryElement.prototype._setDCXNode = function (dcxNode, keepRenditionCache) {\n        var that = this;\n\n        this._dcxNode = dcxNode;\n        this._representations = [];\n        this._deletedLocally = false;\n\n        var nodeRepresentations = this._library._dcxBranch.getChildrenOf(dcxNode);\n        nodeRepresentations.forEach(function (node) {\n            var representation = new AdobeLibraryRepresentation(that, node);\n            that._representations.push(representation);\n        });\n\n        var componentRepresentations = this._library._dcxBranch.getComponentsOf(dcxNode);\n        componentRepresentations.forEach(function (component) {\n            var representation = new AdobeLibraryRepresentation(that, undefined, component);\n            that._representations.push(representation);\n        });\n\n        // Make sure the representations are sorted in the same order they were added\n        AdobeLibraryManifestUtils.sortRepresentations(this._representations);\n\n        // Setup the category correctly, based on the DCX data\n        var categoryId = dcxNode.getValue(AdobeLibraryConfig.CATEGORY_KEY);\n        this._library._categories.forEach(function (category) {\n            if (category.id === categoryId) {\n                that._category = category;\n            }\n        });\n\n        // Clear the rendition cache:\n        // If keepRenditionCache is true, this will only clear any errors in the rendition cache\n        // If keepRenditionCache is false, it'll clear everything, except for external links that are unchanged and already cached.\n        this._clearRenditionCache(keepRenditionCache, false);\n\n        // Clear derived data\n        this._displayName = undefined;\n    };\n\n    // Private: prevent further operations when the library is destroyed\n    AdobeLibraryElement.prototype._markDeletedLocally = function (isDeleted) {\n        this._deletedLocally = isDeleted;\n\n        // Mark the representations as deleted\n        this._representations.forEach(function (representation) {\n            representation._markDeletedLocally(isDeleted);\n        });\n\n        // If deleted, remove change listeners\n        // NOTE: we don't notify the change listeners, because they're listening to something that was deleted\n        // If they want to know if the element is deleted, they should listen to the library itself.\n        if (isDeleted) {\n            this._listenerManager.removeAll();\n        }\n    };\n\n    // Private: remove all change listeners\n    AdobeLibraryElement.prototype._removeAllListeners = function () {\n        this._listenerManager.removeAll();\n    };\n\n    // Private: convert to internal JSON format that can be serialised to disk (will be replaced by DCX)\n    AdobeLibraryElement.prototype._toJSON = function () {\n        var obj = {\n            id: this.id,\n            name: this.name,\n            type: this.type,\n            category: this._category && this._category._id,\n            representations: []\n        };\n\n        this._representations.forEach(function (representation) {\n            obj.representations.push(representation._toJSON());\n        });\n        // We don't care about the representation order, so sort them for comparison:\n        obj.representations.sort(function (a, b) {\n            if (a.type > b.type) {\n                return 1;\n            }\n            if (a.type < b.type) {\n                return -1;\n            }\n            return 0;\n        });\n\n        return obj;\n    };\n\n    // Private APIs - for handling representations\n    AdobeLibraryElement.prototype._addRepresentation = function (representation, insertAtStart) {\n        if (insertAtStart) {\n            this._representations.unshift(representation);\n        } else {\n            this._representations.push(representation);\n        }\n    };\n\n    AdobeLibraryElement.prototype._removeRepresentation = function (representation) {\n        var index = this._representations.indexOf(representation);\n        if (index !== -1) {\n            this._representations.splice(index, 1);\n        }\n    };\n\n    // Private: Create new DCX node and representation\n    // This is separated out so we can call it internally (e.g. for copy operations), so we don't do extra stuff like analytics\n    AdobeLibraryElement.prototype._doCreateRepresentation = function (type, relationship, insertAtStart) {\n        var dcxNode = this._library._dcxBranch.addChild(undefined, undefined, insertAtStart ? 0 : undefined, this._dcxNode);\n        dcxNode.type = type;\n        dcxNode.setValue(AdobeLibraryConfig.RELATIONSHIP_KEY, relationship);\n\n        // Specify an order at the time we create the representation, so we can preserve this on re-loading\n        if (!insertAtStart) {\n            var lastRepresentation = this.representations[this.representations.length - 1];\n            var order = Math.max(this.representations.length, lastRepresentation ? lastRepresentation._getOrder() + 1 : 0);\n            dcxNode.setValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY, order);\n        } else {\n            // We're inserting it at the end, so need to set its order to 0, and bump the order of the other representations!\n            dcxNode.setValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY, 0);\n            this._representations.forEach(function (representation) {\n                var element = representation._getDCXElement();\n                var oldOrder = element.getValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY);\n                if (oldOrder !== undefined) {\n                    element.setValue(AdobeLibraryConfig.REPRESENTATION_ORDER_KEY, oldOrder + 1);\n                }\n            });\n        }\n\n        var representation = new AdobeLibraryRepresentation(this, dcxNode);\n        this._addRepresentation(representation, insertAtStart);\n\n        return representation;\n    };\n\n    // Private: get a full path to the rendition of the given size, if it's in the cache (otherwise, returns undefined)\n    AdobeLibraryElement.prototype._lookupRenditionPath = function (size) {\n        var existsSync = 'existsSync'; // Avoid linter warning\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n\n        var cachedFile = this._renditionCache[size];\n        if (cachedFile && cachedFile !== AdobeLibraryConfig.RENDITION_CACHE_PLACEHOLDER && cachedFile) {\n            if (cachedFile === AdobeLibraryConfig.RENDITION_CACHE_PLACEHOLDER || AdobeLibraryErrorUtils.isErrorCode(cachedFile)) {\n                // Special case - it's not a filename, but an error or placeholder\n                return cachedFile;\n            }\n\n            // It's a filename, so convert it into a path and check it exists\n            var path = this._library._getRenditionCacheDir() + pathSep + cachedFile;\n            if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE || AdobeLibraryServices.fs[existsSync](path)) {\n                // Only return the path if it really exists - otherwise, it's as though we don't have a rendition cached\n                return path;\n            }\n        }\n        return undefined;\n    };\n\n    // Private: get a file to store a new rendition in - this returns both the path, and the filename, for convenience\n    AdobeLibraryElement.prototype._getNewRenditionPath = function (extension, callback) {\n        var that = this;\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n\n        var rootPath = this._library._getRenditionCacheDir();\n        AdobeLibraryFileUtils.ensurePathExists(rootPath, function (err) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            var fileName = AdobeLibraryServices.uuid() + '.' + (extension || 'png');\n            var path = rootPath + pathSep + fileName;\n            callback(err, path, fileName);\n        });\n    };\n\n    // Private: update the modified timestamp\n    AdobeLibraryElement.prototype._updateModifiedTime = function () {\n        var modifiedTime = new Date().valueOf();\n        this._dcxNode.setValue(AdobeLibraryConfig.MODIFIED_KEY, modifiedTime);\n    };\n\n    // Private: update the created timestamp (also sets modified)\n    AdobeLibraryElement.prototype._updateCreatedTime = function () {\n        var createdTime = new Date().valueOf();\n        this._dcxNode.setValue(AdobeLibraryConfig.CREATED_KEY, createdTime);\n        this._dcxNode.setValue(AdobeLibraryConfig.MODIFIED_KEY, createdTime);\n    };\n\n    // Private: clear the rendition cache\n    // This does NOT clear the cache for any externally-linked representations that still exist - the only\n    // way to clear it is to remove the representation and add a new one.\n    // Cached errors will always be cleared. If you pass errorsOnly, it will not clear any existing thumbnails.\n    AdobeLibraryElement.prototype._clearRenditionCache = function (errorsOnly, sendMessage) {\n        var that = this;\n\n        var renditionCache = this._renditionCache;\n        this._renditionCache = {};\n\n        var sendClearMessage = sendMessage && AdobeLibraryConfig.SHARED_LOCAL_STORAGE && AdobeLibraryFeatureUtils.supportsClearRenditionCache();\n\n        Object.keys(renditionCache).forEach(function (size) {\n            if ((errorsOnly || that.getRepresentationById(size)) && !AdobeLibraryErrorUtils.isErrorCode(renditionCache[size])) {\n                // Copy over the cache for any representations that didn't change\n                // Or for any non-error if the errorsOnly flag is true\n                that._renditionCache[size] = renditionCache[size];\n\n            } else if (sendClearMessage) {\n                AdobeLibraryServices.storageInterface.setRenditionCache(that, size, 'CLEAR');\n            }\n        });\n    };\n\n    // Private: commit changes and update the modified timestamp + notify listeners\n    AdobeLibraryElement.prototype._commit = function (infoOnly) {\n        this._displayName = undefined; // Need to reset this, because any changes could invalidate this\n        this._updateModifiedTime();\n        this._clearRenditionCache(true, true);\n        this._library._commit();\n        this._listenerManager.notify('change');\n        AdobeLibraryAnalytics.reportUpdateElement(this, infoOnly);\n    };\n\n    // Private: call this if the _only_ thing we changed was the rendition cache: this won't change the timestamp\n    AdobeLibraryElement.prototype._commitRenditionCache = function () {\n        this._library._commit(true, true); // Don't change the modification time, and don't push - just saves the rendition cache\n\n        // Still need to notify changed listeners, because there's a new rendition set\n        this._listenerManager.notify('change');\n    };\n\n    // Private: set a value in the rendition cache, and save it.\n    // NOTE: only call this if you have the lock!\n    AdobeLibraryElement.prototype._setRenditionCache = function (size, fileName, notifyDownloadRendition) {\n        this._renditionCache[size] = fileName;\n        this._commitRenditionCache();\n\n        // Rendition cache changed due to a download, so we notify clients - just of the change to this element\n        if (notifyDownloadRendition) {\n            AdobeLibraryServices.storageInterface.notifyDownloadRendition(this);\n        }\n    };\n\n    // Private: wrap an operation, and notify change listeners\n    AdobeLibraryElement.prototype._wrapOperation = function (operation, thisObject) {\n        var retValue = this._library._wrapOperation(function () {\n            var innerRetValue = this._library._wrapOperation(operation, thisObject);\n            this._updateModifiedTime();\n            return innerRetValue;\n        }, this);\n        this._listenerManager.notify('change');\n        return retValue;\n    };\n\n    // Private: custom pretty printer for testing\n    AdobeLibraryElement.prototype.jasmineToString = function () {\n        return this.toString();\n    };\n\n\n    /**\n        Public API\n    **/\n\n    // Getters/setters for properties\n    Object.defineProperties(AdobeLibraryElement.prototype, {\n        /**\n         * The id of the element (this will never change, after the element is created).\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {String}\n         * @instance\n         */\n        id: {\n            get: function () {\n                return this._dcxNode.id;\n            },\n            set: function (id) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the id of an existing element', this._library.id);\n            }\n        },\n        /**\n         * The library that the element belongs to.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {AdobeLibraryComposite}\n         * @instance\n         */\n        library: {\n            get: function () {\n                return this._library;\n            },\n            set: function (library) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'library is a read-only property', this._library.id);\n            }\n        },\n        /**\n         * Whether or not write operations are permitted on the element. If `false`, you'll receive an {@AdobeLibraryError.NOT_ALLOWED} error\n         * if you try to modify the element.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Boolean}\n         * @instance\n         */\n        writable: {\n            get: function () {\n                return this._library.writable;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'writable is a read-only property', this.id);\n            }\n        },\n        /**\n         * The index of the element in the library.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Number}\n         * @instance\n         * @see {@link AdobeLibraryComposite#elements}\n         */\n        index: {\n            get: function () {\n                return this._library._elements.indexOf(this);\n            },\n            set: function (index) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'index is a read-only property', this._library.id);\n            }\n        },\n        /**\n         * The name of the element. To modify the name, just set this to a new value, and it will automatically save and sync\n         * the change to the server.\n         *\n         * Changing the name of a deleted element will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {String}\n         * @instance\n         */\n        name: {\n            get: function () {\n                return this._dcxNode.name || '';\n            },\n            set: function (name) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n                }\n\n                this._dcxNode.name = name;\n                this._commit(true);\n            }\n        },\n        /**\n         * The name of the element to display in the UI. This uses the `getDisplayName` dependency, if passed into\n         * {@link CCLibraries.configure} (otherwise, it returns the same thing string as {@link AdobeLibraryElement#name}.\n         *\n         * This is really a utility property, for the case that you want to display a different name in the UI than\n         * the actual name of the element - for example, in the desktop apps, we display the hex value of the colour\n         * as the display name, if the colour has no name.\n         *\n         * If the element changes, the display name gets recomputed the next time you ask for it. Otherwise, it returns\n         * a cached value - this is useful if computing the display name is an expensive operation, or it gets queried\n         * frequently.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {String}\n         * @instance\n         */\n        displayName: {\n            get: function () {\n                if (this._displayName === undefined) {\n                    this._displayName = AdobeLibraryServices.getDisplayName(this) || '';\n                }\n                return this._displayName;\n            },\n            set: function (name) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'displayName is a read-only property', this._library.id);\n            }\n        },\n        /**\n         * The type of the element.\n         *\n         * Element types should have the form `application/vnd.adobe.element.<nameOfType>+dcx`. These types are quite general, e.g.\n         * images (any graphic element), colours, and brushes.\n         * See [Creative Cloud Library Types](https://wiki.corp.adobe.com/display/ccprojects/Creative+Cloud+Libraries+DCX+Types)\n         * for the exact types supported.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {String}\n         * @instance\n         */\n        type: {\n            get: function () {\n                return this._dcxNode.type;\n            },\n            set: function (type) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the type of an existing element', this._library.id);\n            }\n        },\n        /**\n         * The tags associated with the element. This is simply an array of strings - there are no specific requirements for the form of\n         * these strings.\n         *\n         * Changing the tags of a deleted element will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Array.<String>}\n         * @instance\n         */\n        tags: {\n            get: function () {\n                return this._dcxNode.getValue('tags') || [];\n            },\n            set: function (tags) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n                }\n\n                if (!tags || tags.constructor !== Array) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'tags must be an array', this._library.id);\n                }\n\n                var isStringArray = tags.every(function (tag) {\n                    return typeof tag === 'string';\n                });\n                if (!isStringArray) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'tags must be an array of strings', this._library.id);\n                }\n\n                this._dcxNode.setValue('tags', tags);\n                this._commit();\n            }\n        },\n        /**\n         * **UNSUPPORTED** The category that the element belongs to.\n         *\n         * Changing the category of a deleted element will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {AdobeLibraryCategory|undefined}\n         * @instance\n         * @ignore\n         */\n        category: {\n            get: function () {\n                return this._category;\n            },\n            set: function (category) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n                }\n\n                if ((!category && this._library._categories.length > 0) || (category && this._library._categories.indexOf(category) === -1)) {\n                    throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid category', this._library.id);\n                }\n                this._library._removeElementFromFilter(this);\n                this._category = category;\n                this._library._addElementToFilter(this, true);\n\n                this._dcxNode.setValue(AdobeLibraryConfig.CATEGORY_KEY, category && category.id);\n                this._commit(true);\n            }\n        },\n        /**\n         * A number representing the time that the element was last modified. This gets updated whenever a change is made to the element,\n         * or any of its representations.\n         *\n         * This follows the primitive value of a `Date` object (see [`Date.valueOf`](http://www.w3schools.com/jsref/jsref_valueof_date.asp))\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Number}\n         * @instance\n         */\n        modified: {\n            get: function () {\n                return this._dcxNode.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n            },\n            set: function (modified) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the modified timestamp of an element directly', this._library.id);\n            }\n        },\n        /**\n         * A number representing the time that the element was created.\n         *\n         * This follows the primitive value of a `Date` object (see [`Date.valueOf`](http://www.w3schools.com/jsref/jsref_valueof_date.asp))\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Number}\n         * @instance\n         */\n        created: {\n            get: function () {\n                return this._dcxNode.getValue(AdobeLibraryConfig.CREATED_KEY);\n            },\n            set: function (created) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the created timestamp of an element directly', this._library.id);\n            }\n        },\n        /**\n         * An array of all the representations of the element\n         *\n         * Read-only - to add or remove representations, see {@link AdobeLibraryElement#createRepresentation} and\n         * {@link AdobeLibraryElement#removeRepresentation} respectively.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Array.<AdobeLibraryRepresentation>}\n         * @instance\n         */\n        representations: {\n            get: function () {\n                return this._representations;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot modify representation list directly', this._library.id);\n            }\n        },\n        /**\n         * This is `true`, if and only if the element is deleted locally. This is the case if the element has been removed\n         * from the library it belongs to, or if the libary it belongs to was deleted. You should stop referencing the\n         * element - any further operations will be met with an error.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryElement\n         * @type {Boolean}\n         * @instance\n         */\n        deletedLocally: {\n            get: function () {\n                return this._deletedLocally;\n            },\n            set: function (element) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'deletedLocally is a read-only property', this._library.id);\n            }\n        }\n    });\n\n    // Custom toString method for debugging - don't show internal fields\n    AdobeLibraryElement.prototype.toString = function () {\n        return JSON.stringify(this._toJSON());\n    };\n\n    /**\n        Change notifications\n    **/\n\n    /**\n     * Register a listener for changes in the element - this includes metadata, like the element name, as well as adding or\n     * removing representations, and any changes to representation content.\n     *\n     * Note that the change callback doesn't tell you what changed - it's intended to be used to trigger a redraw of the element.\n     *\n     * @param {Function} callback This gets called whenever the element changes.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY}\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.addChangeListener = function (callback) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        this._listenerManager.add('change', callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the element.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryElement#addChangeListener}.\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.removeChangeListener = function (callback) {\n        this._listenerManager.remove('change', callback);\n    };\n\n    /**\n        Representations\n    **/\n\n    /**\n     * Create a new representation, and add it to the element. This automatically saves the new representation to disk,\n     * and syncs it to the server.\n     * See {@link AdobeLibraryComposite#beginOperation} if you want to make changes to the representation (such\n     * as setting its content) before it's committed/pushed.\n     *\n     * Note: the first representation must have relationship `'primary'`, and there can only be one primary representation\n     * (see {@link AdobeLibraryRepresentation#relationship}).\n     *\n     * @param {String} type The type of the new representation (see {@link AdobeLibraryRepresentation#type}).\n     * @param {String} relationship The relationship of the new representation to the element\n     * (see {@link AdobeLibraryRepresentation#relationship}).\n     * @returns {AdobeLibraryRepresentation} The new representation.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER|AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.createRepresentation = function (type, relationship) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n        }\n\n        return this._wrapOperation(function () {\n\n            if (type === AdobeLibraryConfig.LINK_REPRESENTATION_TYPE) {\n                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot create external link representation directly - use updateContentFromURL instead', this._library.id);\n            }\n\n            if (AdobeLibraryConfig.VALID_RELATIONS.indexOf(relationship) === -1) {\n                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Unsupported relationship', this._library.id);\n            }\n\n            if (this._representations.length === 0 && relationship !== 'primary') {\n                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'First representation must be primary', this._library.id);\n            }\n\n            if (this._representations.length > 0 && relationship === 'primary') {\n                var that = this;\n                this._representations.forEach(function (rep) {\n                    if (rep.relationship === 'primary') {\n                        throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot have more than one primary representation', that._library.id);\n                    }\n                });\n            }\n\n            // Create the representation\n            var representation = this._doCreateRepresentation(type, relationship);\n            this._clearRenditionCache(false, true);\n\n            AdobeLibraryAnalytics.reportCreateRepresentation(representation);\n\n            return representation;\n        }, this);\n    };\n\n    /**\n     * This is a special case of {@link AdobeLibraryElement#createRepresentation}. This demotes the current primary\n     * representation, and creates a new primary representation with the given type.\n     *\n     * Unlike {@link AdobeLibraryElement#createRepresentation}, this does not clear the rendition cache. Only use this\n     * if you are adding a higher-fidelity version of existing representations - for example, when you license an Adobe\n     * Stock image, in which case you add a full-resolution licensed image in addition to the comp.\n     *\n     * @param {String} type The type of the new primary representation (see {@link AdobeLibraryRepresentation#type}).\n     * @returns {AdobeLibraryRepresentation} The new representation.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER|AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.createHigherFidelityPrimaryRepresentation = function (type) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n        }\n\n        return this._wrapOperation(function () {\n\n            if (type === AdobeLibraryConfig.LINK_REPRESENTATION_TYPE) {\n                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot create external link representation directly - use updateContentFromURL instead', this._library.id);\n            }\n\n            var primary = this.getPrimaryRepresentation();\n            if (!primary) {\n                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Must already have a primary representation', this._library.id);\n            }\n\n            // Demote the current primary!\n            if (primary._dcxComponent) {\n                primary._dcxComponent.relationship = 'rendition';\n            } else {\n                primary._dcxNode.setValue(AdobeLibraryConfig.RELATIONSHIP_KEY, 'rendition');\n            }\n\n            // Create the representation (at the beginning): Note: we don't clear the rendition cache!\n            var representation = this._doCreateRepresentation(type, 'primary', true);\n\n            AdobeLibraryAnalytics.reportCreateRepresentation(representation);\n\n            return representation;\n        }, this);\n    };\n\n    /**\n     * Remove a representation from the element. This automatically saves the change to disk, and syncs it to the server.\n     *\n     * @param {AdobeLibraryRepresentation} representation The representation to remove.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.removeRepresentation = function (representation) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n        }\n\n        return this._wrapOperation(function () {\n            this._removeRepresentation(representation);\n\n            // Remove from DCX document\n            if (representation._dcxComponent) {\n                this._library._dcxBranch.removeComponent(representation._dcxComponent);\n            } else {\n                this._library._dcxBranch.removeChild(representation._dcxNode);\n            }\n            this._clearRenditionCache(false, true);\n\n            AdobeLibraryAnalytics.reportDeleteRepresentation(representation);\n\n            // Unbind the representation so we can't continue to use it\n            representation._markDeletedLocally(true);\n        }, this);\n    };\n\n    /**\n     * Remove all of the element's representations. This automatically saves the change to disk, and syncs it to the server.\n     *\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.removeAllRepresentations = function () {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n        }\n\n        return this._wrapOperation(function () {\n            while (this._representations[0]) {\n                this.removeRepresentation(this._representations[0]);\n            }\n        }, this);\n    };\n\n    /**\n     * Get the primary representation of the element. This is just a utility function, to save you searching through\n     * the array {@link AdobeLibraryElement#representations}.\n     *\n     * @returns {AdobeLibraryRepresentation} The primary representation.\n     *\n     * @memberof AdobeLibraryElement\n     * @see {@link AdobeLibraryRepresentation#relationship}\n     */\n    AdobeLibraryElement.prototype.getPrimaryRepresentation = function () {\n        var primary;\n        this._representations.forEach(function (representation) {\n            if (!primary && representation.relationship === 'primary') {\n                primary = representation;\n            }\n        });\n        return primary;\n    };\n\n    /**\n        Renditions\n    **/\n\n    // Private: find the rendition candidate to use\n    AdobeLibraryElement.prototype._getRenditionCandidate = function (size) {\n        // If not, see if we have a representation that's marked as a rendition\n        var renditionCandidate;\n        var renditionCandidateComparisonSize = 0;\n\n        var i, r, rSize, rComparisonSize, isPrimary, isRendition, canReplaceRenditionCandidate;\n        for (i = 0; i < this._representations.length; i++) {\n            r = this._representations[i];\n            rSize = Math.max(r.width || 0, r.height || 0);\n            rComparisonSize = r.isFullSize ? Number.POSITIVE_INFINITY : rSize;\n            isPrimary = r.relationship === 'primary';\n            isRendition = r.relationship === 'rendition';\n\n            canReplaceRenditionCandidate = !renditionCandidate ||\n                (isPrimary && renditionCandidate.relationship !== 'primary') ||\n                (isRendition && renditionCandidate.relationship !== 'primary' && renditionCandidate.relationship !== 'rendition') ||\n                (isRendition && renditionCandidate.relationship === 'rendition' && rComparisonSize > renditionCandidateComparisonSize);\n\n            if (canReplaceRenditionCandidate && AdobeLibraryRenditionUtils.canComputeRendition(r)) {\n                renditionCandidate = r;\n                renditionCandidateComparisonSize = rComparisonSize;\n            }\n\n            if (isRendition && r.type === 'image/png' && size && rSize === size) {\n                // Use this representation as the rendition: stop searching\n                break;\n            }\n        }\n\n        return renditionCandidate;\n    };\n\n    /**\n     * Get a URL to a rendition of the element, with the requested size. If you're not using shared local storage, the\n     * URL is self-contained (including the access token), so you can call it by doing a simple GET, without\n     * setting any headers. Otherwise (in the case of shared local storage), the URL will not include the access token -\n     * this will need to be set as an Authorization header when calling the URL (along with an Accept header to\n     * specify the desired rendition format).\n     *\n     * Calling this on a deleted element will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Number} size The rendition is guaranteed to fit into a square of `size` x `size` pixels. If the original\n     * image is bigger, it will be scaled down, but it will never be scaled up. If `size` is `undefined`, we will\n     * return a full-size rendition.\n     * @param {Function} callback This gets called with the URL.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success. If there is no suitable\n     * representation to generate a rendition from, this will be {@link AdobeLibraryError.RENDITION_NOT_AVAILABLE}.\n     * @param {String} callback.url The URL of the rendition.\n     *\n     * @memberof AdobeLibraryElement\n     * @instance\n     * @see {@link AdobeLibraryElement#getRenditionPath}\n     */\n    AdobeLibraryElement.prototype.getRenditionUrl = function (size, callback) {\n        var that = this;\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        // If we're in the middle of modifying the library, wait for it to commit before we let you get the rendition\n        // Otherwise, we might return an incorrect rendition\n        this._library._waitForCommit(function () {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            var renditionCandidate = that._getRenditionCandidate(size);\n            if (renditionCandidate) {\n                var syncManager = that._library._collection._syncManager;\n                syncManager.getSharedCloudRenditionUrl(renditionCandidate, size, callback);\n                return;\n            }\n\n            // No way of generating a rendition: don't return a path\n            callback(new AdobeLibraryError(AdobeLibraryError.RENDITION_NOT_AVAILABLE, 'no representation that can be converted into a rendition', that._library.id));\n        });\n    };\n\n    /**\n     * Get a path to a file on disk, which is a rendition of the element, with the requested size.\n     * If the rendition is not already cached on disk, we will download it from shared cloud.\n     *\n     * Note: once the rendition is downloaded, it's cached locally. This allows you to work offline.\n     * If the element has any representations added, removed, or modified, the cache is invalidated.\n     *\n     * This requires a filesystem (otherwise, you'll get a {@link AdobeLibraryError.REQUIRES_FILESYSTEM} error).\n     *\n     * Calling this on a deleted element will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Number} size The rendition is guaranteed to fit into a square of `size` x `size` pixels. If the original\n     * image is bigger, it will be scaled down, but it will never be scaled up. If `size` is `undefined`, we will\n     * return a full-size rendition.\n     * @param {Function} callback This gets called with the path to the rendition.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success. If there is no suitable\n     * representation to generate a rendition from, this will be {@link AdobeLibraryError.RENDITION_NOT_AVAILABLE}.\n     * @param {String} callback.path The path to the rendition.\n     *\n     * @memberof AdobeLibraryElement\n     * @instance\n     * @see {@link AdobeLibraryElement#getRenditionUrl}\n     */\n    AdobeLibraryElement.prototype.getRenditionPath = function (size, _callback) {\n        var that = this;\n\n        // The rendition cache requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            _callback(new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'path-based APIs require a filesystem', this._library.id));\n            return;\n        }\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, _callback)) { return; }\n\n        // If we're in the middle of modifying the library, wait for it to commit before we let you get the rendition\n        // Otherwise, we might return an incorrect rendition\n        this._library._waitForCommit(function () {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, _callback)) { return; }\n\n            // If we're in shared local storage, we let the storage interface set the rendition cache\n            if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n                AdobeLibraryServices.storageInterface.getRenditionPath(that, size, _callback);\n                return;\n            }\n\n            var callback = function (err, data) {\n                that._lock.release();\n                _callback(err, data);\n            };\n\n            that._lock.obtain(function () {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                // First, see if we have a rendition that's already cached\n                var renditionCachePath = this._lookupRenditionPath(size || 'full');\n                if (renditionCachePath) {\n                    callback(null, renditionCachePath);\n                    return;\n                }\n\n                var renditionCandidate = this._getRenditionCandidate(size);\n                if (renditionCandidate) {\n\n                    // First, check if we can use the candidate directly as the rendition\n                    if (renditionCandidate.relationship === 'rendition' &&\n                            renditionCandidate.type === 'image/png' && size &&\n                            Math.max(renditionCandidate.width || 0, renditionCandidate.height || 0) === size) {\n                        renditionCandidate.getContentPath(callback);\n                        return;\n                    }\n\n                    // If this fails, and there's a rendition candidate: use shared cloud to convert it into a rendition\n                    var syncManager = this._library._collection._syncManager;\n                    syncManager.getSharedCloudRendition(renditionCandidate, size, function (err, downloadedFilePath) {\n                        if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                        if (err) {\n                            callback(new AdobeLibraryError(AdobeLibraryError.RENDITION_NOT_AVAILABLE, 'error generating rendition from shared cloud', that._library.id, err));\n                            return;\n                        }\n\n                        that._getNewRenditionPath(undefined, function (err, newPath, newFileName) {\n                            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                            if (err) {\n                                callback(AdobeLibraryErrorUtils.getCommitError(err, that._library.id, 'unable to create rendition cache directory'));\n                                return;\n                            }\n\n                            that._library._pendingRenditionCacheItems[newFileName] = true; // We add the file to a list to avoid GCing it before the cache gets written\n                            AdobeLibraryServices.fs.rename(downloadedFilePath, newPath, function (err) {\n\n                                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                                if (err) {\n                                    callback(AdobeLibraryErrorUtils.getCommitError(err, that._library.id, 'unable to write rendition to cache'));\n                                    return;\n                                }\n\n                                that._setRenditionCache(size || 'full', newFileName, true);\n                                callback(null, newPath);\n                            });\n\n                        });\n                    });\n\n                    return;\n                }\n\n                // No way of generating a rendition: don't return a path\n                callback(new AdobeLibraryError(AdobeLibraryError.RENDITION_NOT_AVAILABLE, 'no representation that can be converted into a rendition', that._library.id));\n\n            }, that);\n        });\n    };\n\n    /**\n     * Manually set a rendition in the local rendition cache, of the given size. Since the rendition cache gets\n     * invalidated every time you modify any of the element's representations, you need to call `setRenditionCache`\n     * to support offline workflows. If you don't update the local cache, we'll fetch a rendition from shared\n     * cloud, the next time you call {@link AdobeLibraryElement#getRenditionPath}. Since this won't work when you're\n     * offline, the rendition cache is a way for you to immediately update the thumbnail after editing or adding an element.\n     *\n     * Note: this isn't the same as setting a representation - the cache is only stored locally, and is not uploaded\n     * to the server. If there is no way for shared cloud to regenerate the rendition (e.g. you have a custom data\n     * format), then you should also add the rendition as a representation, with relationship `'rendition'`.\n     *\n     * This requires a filesystem (otherwise, you'll get a {@link AdobeLibraryError.REQUIRES_FILESYSTEM} error).\n     *\n     * Calling this on a deleted element will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Number} size The maximum of the width and height of the rendition, or `undefined`, to set a full-size rendition.\n     * @param {String} path The path to the file on disk, to use as a rendition. This must be a PNG image.\n     * @param {Function} callback This gets called when the cache has finished updating.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success. If there is no suitable\n     * representation to generate a rendition from, this will be {@link AdobeLibraryError.RENDITION_NOT_AVAILABLE}.\n     * @param {String} callback.newPath The new path to the rendition (a copy of the specified file).\n     *\n     * @memberof AdobeLibraryElement\n     * @instance\n     */\n    AdobeLibraryElement.prototype.setRenditionCache = function (size, path, _callback) {\n\n        // Path must be a string\n        if (typeof path !== 'string') {\n            _callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'path must be a string', this._library.id));\n            return;\n        }\n\n        // The rendition cache requires a filesystem\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            _callback(new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'path-based APIs require a filesystem', this._library.id));\n            return;\n        }\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, _callback)) { return; }\n\n        if (!this.writable) {\n            _callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id));\n            return;\n        }\n\n        // If we're in shared local storage, we let the storage interface set the rendition cache\n        // TOFIX: need to copy file somewhere temporarily, so it doesn't get deleted\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            AdobeLibraryServices.storageInterface.setRenditionCache(this, size, path, _callback);\n            return;\n        }\n\n        var that = this;\n        var callback = function (err, data) {\n            that._lock.release();\n            _callback(err, data);\n        };\n\n        this._lock.obtain(function () {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            this._getNewRenditionPath(AdobeLibraryFileUtils.getFileExtension(path), function (err, newPath, newFileName) {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                if (err) {\n                    callback(AdobeLibraryErrorUtils.getCommitError(err, that._library.id, 'unable to create rendition cache directory'));\n                    return;\n                }\n\n                that._library._pendingRenditionCacheItems[newFileName] = true; // We add the file to a list to avoid GCing it before the cache gets written\n                AdobeLibraryFileUtils.copyFile(path, newPath, function (err) {\n                    if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                    if (err) {\n                        callback(AdobeLibraryErrorUtils.getCommitError(err, that._library.id, 'unable to write rendition to cache'));\n                        return;\n                    }\n\n                    that._setRenditionCache(size || 'full', newFileName, false);\n                    callback(null, newPath);\n                });\n            });\n        }, this);\n    };\n\n    /**\n     * Get a unique reference string for the element. This reference string can be used anytime to retrieve this element object.\n     * @see {@link CCLibraries.resolveElementReference}\n     *\n     * @returns {String} A unique reference string that represents this element.\n     *\n     * @memberof AdobeLibraryElement\n     */\n    AdobeLibraryElement.prototype.getReference = function () {\n        return AdobeLibraryManifestUtils.getElementReference(this.library._collection._syncManager._storageHost, this.library.id, this.id);\n    };\n\n    /**\n     * Find a representation by id, belonging to this element.\n     *\n     * @param {Uuid} id A representation id.\n     * @returns {AdobeLibraryRepresentation} The representation with the given id, or `undefined` if no such representation exists.\n     *\n     * @memberof AdobeLibraryElement\n     * @instance\n     */\n    AdobeLibraryElement.prototype.getRepresentationById = function (id) {\n        var foundRepresentation;\n\n        this.representations.forEach(function (representation) {\n            if (representation.id === id) {\n                foundRepresentation = representation;\n            }\n        });\n\n        return foundRepresentation;\n    };\n\n    return AdobeLibraryElement;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryCategory\n * @classdesc\n * Categories for library elements - not yet implemented/exposed\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryCategory',['require','exports','module','./AdobeLibraryError','./utils/AdobeLibraryManifestUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryError = require('./AdobeLibraryError');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n\n\n    // Constructor\n    // Note: you should never call this directly; always through AdobeLibrary.createCategory()\n    function AdobeLibraryCategory(library, dcxNode) {\n        this._library = library;\n        this._dcxNode = dcxNode;\n        this._deletedLocally = false;\n    }\n\n    // Private: prevent further operations when the category is destroyed\n    AdobeLibraryCategory.prototype._markDeletedLocally = function (isDeleted) {\n        this._deletedLocally = isDeleted;\n    };\n\n    // Private: convert to internal JSON format that can be serialised to disk (will be replaced by DCX)\n    AdobeLibraryCategory.prototype._toJSON = function () {\n        var obj = {\n            id: this.id,\n            name: this.name\n        };\n\n        return obj;\n    };\n\n    // Private: custom pretty printer for testing\n    AdobeLibraryCategory.prototype.jasmineToString = function () {\n        return this.toString();\n    };\n\n    // Getters/setters for properties\n    Object.defineProperties(AdobeLibraryCategory.prototype, {\n        id: {\n            get: function () {\n                return this._dcxNode.id;\n            },\n            set: function (id) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the id of an existing category', this._library.id);\n            }\n        },\n        writable: {\n            get: function () {\n                return this._library.writable;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'writable is a read-only property', this._library.id);\n            }\n        },\n        name: {\n            get: function () {\n                return this._dcxNode.name;\n            },\n            set: function (name) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this._library.id);\n                }\n\n                this._dcxNode.name = name;\n                this._library._commit();\n            }\n        },\n        deletedLocally: {\n            get: function () {\n                return this._deletedLocally;\n            },\n            set: function (element) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'deletedLocally is a read-only property', this._library.id);\n            }\n        }\n    });\n\n    // Custom toString method for debugging - don't show internal fields\n    AdobeLibraryCategory.prototype.toString = function () {\n        return JSON.stringify(this._toJSON());\n    };\n\n    return AdobeLibraryCategory;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define */\n\n/**\n * @class AdobeLibraryComposite\n * @classdesc\n * A single Creative Cloud Library. Manages the following:\n *\n * * Library-level metadata (e.g. name, created and modified timestamps).\n * * Creating and deleting library elements.\n * * Transactional library operations.\n * * Copying/moving elements between different libraries.\n * * Change notifications for library changes.\n * * Filtering elements by type.\n *\n * @description\n * This class has a private constructor. The only way to obtain an instance of AdobeLibraryComposite\n * is via an {@link AdobeLibraryCollection}.\n */\n\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryComposite',['require','exports','module','./components/dcx-js/src/AdobeDCXError','./AdobeLibraryElement','./AdobeLibraryCategory','./AdobeLibraryConfig','./AdobeLibraryAnalytics','./AdobeLibraryError','./AdobeLibraryServices','./utils/AdobeLibraryAsyncJoin','./utils/AdobeLibraryLock','./utils/AdobeLibraryRenditionUtils','./utils/AdobeLibraryManifestUtils','./utils/AdobeLibraryErrorUtils','./utils/AdobeLibraryFileUtils','./utils/AdobeLibraryListenerManager'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeDCXError = require('./components/dcx-js/src/AdobeDCXError');\n\n    var AdobeLibraryElement = require('./AdobeLibraryElement');\n    var AdobeLibraryCategory = require('./AdobeLibraryCategory');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryAnalytics = require('./AdobeLibraryAnalytics');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n\n    var AdobeLibraryAsyncJoin = require('./utils/AdobeLibraryAsyncJoin');\n    var AdobeLibraryLock = require('./utils/AdobeLibraryLock');\n    var AdobeLibraryRenditionUtils = require('./utils/AdobeLibraryRenditionUtils');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n    var AdobeLibraryErrorUtils = require('./utils/AdobeLibraryErrorUtils');\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n    var AdobeLibraryListenerManager = require('./utils/AdobeLibraryListenerManager');\n\n    // Constructor\n    // Note: you should never call this directly; always through AdobeLibraryCollection.createLibrary()\n    function AdobeLibraryComposite(collection, dcxComposite) {\n        var that = this;\n\n        //\n        // 1) Setup internal data\n        //\n\n        // Core data:\n        this._collection = collection;\n        this._dcxComposite = dcxComposite;\n        this._dcxBranch = dcxComposite.current;\n        this._listenerManager = new AdobeLibraryListenerManager(['change']);\n        this._writable = true;\n\n        // Caches:\n        this._filterCache = {};\n\n        // Committing and transactions:\n        this._transactionCount = 0;\n        this._commitInProgress = false;\n        this._pendingCommit = false;\n        this._onCommitCallbacks = [];\n        this._renditionCacheLock = new AdobeLibraryLock();\n        this._pendingRenditionCacheItems = {};\n\n        // Network activity:\n        this._networkLock = new AdobeLibraryLock();\n        this._syncState = undefined;\n        this._deletedLocally = false;\n        this._deletedFromServer = false; // This flag gets set if we discover the library was deleted from the server\n        this._waitForSyncToFinishCallbacks = [];\n\n        // Error recording:\n        this._errors = [];\n        this._pushFailedDueToQuota = false;\n        this._numUpdateConflicts = 0;\n\n        //\n        // 2) Load the DCX composite, and get the elements and categories nodes. Need to create them if not found\n        //\n\n        var dcxChildren = this._dcxBranch.getChildrenOf();\n        dcxChildren.forEach(function (node) {\n            if (node.name === AdobeLibraryConfig.ELEMENTS_NAME) {\n                that._dcxElementsNode = node;\n            } else if (node.name === AdobeLibraryConfig.CATEGORIES_NAME) {\n                that._dcxCategoriesNode = node;\n            }\n        });\n\n        if (!this._dcxElementsNode) {\n            this._dcxElementsNode = this._dcxBranch.addChild(AdobeLibraryConfig.ELEMENTS_NAME);\n        }\n\n        if (!this._dcxCategoriesNode) {\n            this._dcxCategoriesNode = this._dcxBranch.addChild(AdobeLibraryConfig.CATEGORIES_NAME);\n        }\n\n        //\n        // 3) Go through the elements and categories arrays, and create the corresponding AdobeLibrary objects\n        //\n\n        this._categories = [];\n\n        var categoryNodes = this._dcxBranch.getChildrenOf(this._dcxCategoriesNode);\n        categoryNodes.forEach(function (node) {\n            var category = new AdobeLibraryCategory(that, node);\n            that._categories.push(category);\n        });\n\n        this._elements = [];\n\n        var elementNodes = this._dcxBranch.getChildrenOf(this._dcxElementsNode);\n        elementNodes.forEach(function (node) {\n            var element = new AdobeLibraryElement(that, node);\n            that._addElementToFilter(element);\n\n            that._elements.push(element);\n        });\n\n        // TEMPORARY: store the base branch in memory if we don't have a file system\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            this._dcxBaseBranch = this._dcxBranch.copy();\n        }\n    }\n\n    // Private: prevent further operations when the library is destroyed\n    AdobeLibraryComposite.prototype._markDeletedLocally = function (isDeleted) {\n        this._deletedLocally = isDeleted;\n\n        // Mark the categories as deleted\n        this._categories.forEach(function (category) {\n            category._markDeletedLocally(isDeleted);\n        });\n\n        // Mark the elements as deleted\n        this._elements.forEach(function (element) {\n            element._markDeletedLocally(isDeleted);\n        });\n\n        // If deleted, remove change listeners\n        // NOTE: we don't notify the change listeners, because they're listening to something that was deleted\n        // If they want to know if the library is deleted, they should listen to the library collection itself.\n        if (isDeleted) {\n            this._listenerManager.removeAll();\n        }\n    };\n\n    // Private: remove all change listeners\n    AdobeLibraryComposite.prototype._removeAllListeners = function () {\n        this._listenerManager.removeAll();\n        this._elements.forEach(function (element) {\n            element._removeAllListeners();\n        });\n    };\n\n    // Private: convert to internal JSON format that can be serialised to disk (will be replaced by DCX)\n    AdobeLibraryComposite.prototype._toJSON = function () {\n        var obj = {\n            id: this.id,\n            name: this.name,\n            categories: [],\n            elements: [],\n            renditionCache: {}\n        };\n\n        this._categories.forEach(function (category) {\n            obj.categories.push(category._toJSON());\n        });\n\n        this._elements.forEach(function (element) {\n            obj.elements.push(element._toJSON());\n            obj.renditionCache[element.id] = JSON.parse(JSON.stringify(element._renditionCache));\n        });\n\n        return obj;\n    };\n\n    /**\n        Disk operations: committing, and rendition cache\n    **/\n\n    AdobeLibraryComposite.prototype._getRenditionCache = function () {\n        var renditions = {};\n        this._elements.forEach(function (element) {\n            renditions[element.id] = JSON.parse(JSON.stringify(element._renditionCache));\n        });\n        return renditions;\n    };\n\n    AdobeLibraryComposite.prototype._setRenditionCache = function (renditionCache) {\n        this._elements.forEach(function (element) {\n            if (renditionCache[element.id]) {\n                element._renditionCache = renditionCache[element.id];\n            }\n        });\n    };\n\n    // Private: load the rendition cache from disk\n    // NOTE: This ignores any errors, because they're non-fatal (it's just a cache, and we can recreate it)\n    AdobeLibraryComposite.prototype._loadRenditionCache = function (callback) {\n        var that = this;\n\n        AdobeLibraryRenditionUtils.readRenditionCacheData(this, function (err, renditionCache) {\n            if (!err && renditionCache) {\n                that._setRenditionCache(renditionCache.renditions);\n\n                // Backwards compatibility: load the collaboration state from the rendition cache, if it's there:\n                if (renditionCache.hasOwnProperty('collaboration')) {\n                    that._setCollaboration(renditionCache.collaboration);\n                }\n            }\n\n            callback(null);\n        });\n    };\n\n    // Private: save the rendition cache to disk. Note: you can call this directly, because we obtain a lock\n    AdobeLibraryComposite.prototype._saveRenditionCache = function (_callback) {\n        var that = this;\n\n        // Case with no filesystem: don't save anything\n        if (!AdobeLibraryServices.hasFileSystem() || AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            if (_callback) {\n                _callback(null);\n            }\n            return;\n        }\n\n        var callback = function (err) {\n            that._renditionCacheLock.release();\n            if (_callback) {\n                _callback(err);\n            }\n        };\n\n        this._renditionCacheLock.obtain(function () {\n            var renditionCache = {};\n            renditionCache.renditions = this._getRenditionCache();\n\n            // For backwards compatibility, also store the collaboration state:\n            renditionCache.collaboration = this.collaboration;\n\n            AdobeLibraryRenditionUtils.writeRenditionCacheData(this, renditionCache, callback);\n\n        }, this);\n    };\n\n    // Private: commit changes to library (save DCX document to disk)\n    // You should never call this - always call _commit.\n    AdobeLibraryComposite.prototype._doCommit = function (doPush) {\n        var that = this;\n\n        function push() {\n            // Set off a push\n            if (doPush && !AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n                // If deleted locally, we shouldn't be pushing\n                if (that._deletedLocally) { return; }\n\n                // We're going to do a sync, so clear any errors at the collection level\n                that._collection._clearSyncErrors();\n\n                that._push();\n                // We need to reset the backoff, if we've made a deliberate change to the library\n                that._collection._resetPollBackoff();\n            }\n        }\n\n        function doCommitCallbacks() {\n            // It's possible that the callbacks could add themselves to this array, so\n            // we clear out the array first, before iterating\n            var callbacks = that._onCommitCallbacks;\n            that._onCommitCallbacks = [];\n            callbacks.forEach(function (callback) {\n                // When we trigger a commit callbacks, it's possible that it could start a transaction,\n                // or do another commit itself. So... we'd better trigger it via _waitForCommit. That\n                // way, if the second callback happens, and the first is doing a commit, the second callback\n                // will be queued up again.\n                that._waitForCommit(callback);\n            });\n\n            // Set off a push\n            push();\n        }\n\n        // Case with no filesystem: just do the push\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            doCommitCallbacks();\n            return;\n        }\n\n        // After this point we have a filesystem, so we'll save to disk first\n\n        if (this._commitInProgress) {\n            this._pendingCommit = true;\n            return;\n        }\n\n        this._commitInProgress = true;\n\n        function checkError(err, message) {\n            if (err) {\n                err = AdobeLibraryErrorUtils.getCommitError(err, that.id, message);\n            }\n            that._collection._reportCommitError(err);\n        }\n\n        // Write to DCX, then save the rendition cache\n        AdobeLibraryServices.storageInterface.commitManifest(this, function (err) {\n            checkError(err, 'Failed to write composite to disk');\n\n            that._saveRenditionCache(function (err) {\n                checkError(err, 'Failed to write rendition cache to disk');\n\n                that._commitInProgress = false;\n                if (that._pendingCommit) {\n                    // Somebody tried to commit before we were finished, so do another commit\n                    that._pendingCommit = false;\n                    if (that._transactionCount === 0) {\n                        // Never commit if we're inside a transaction, as could be inconsistent state\n                        // (note: if we're inside a transaction, it will commit anyway after the transaction ends)\n                        that._doCommit(doPush);\n                    }\n                } else {\n                    doCommitCallbacks();\n                }\n            });\n        });\n    };\n\n    // Private: call this to register a callback, for when the commit has succeeded - this will make sure\n    // that you get called back after the commit finishes, if there's a commit in progress\n    AdobeLibraryComposite.prototype._waitForCommit = function (callback) {\n        if (this._commitInProgress || this._transactionCount > 0) {\n            this._onCommitCallbacks.push(callback);\n        } else {\n            callback();\n        }\n    };\n\n    // Private: notify a change to a library - this includes notifying the collection\n    AdobeLibraryComposite.prototype._notifyChange = function () {\n        this._listenerManager.notify('change');\n        this._collection._notifyChange();\n    };\n\n    // Private: attempt to commit changes to library, but only do so if we've finished a transaction\n    AdobeLibraryComposite.prototype._commit = function (commitWithoutPush, leaveModificationUnchanged) {\n        if (this._transactionCount === 0) {\n            if (!leaveModificationUnchanged) {\n                this._updateModifiedTime();\n                this._notifyChange();\n            }\n            this._doCommit(!commitWithoutPush);\n        }\n    };\n\n    // Private: wrap a function in begin/end operation\n    // Note: this doesn't revert anything (it's assumed that whoever aborts, ensures that nothing changed).\n    AdobeLibraryComposite.prototype._wrapOperation = function (operation, thisObject) {\n        this.beginOperation();\n        var result;\n        try {\n            result = operation.call(thisObject);\n        } catch (e) {\n            this._transactionCount--;\n            throw e;\n        }\n        this.endOperation();\n        return result;\n    };\n\n    // Private: update the modified timestamp\n    AdobeLibraryComposite.prototype._updateModifiedTime = function () {\n        var modifiedTime = new Date().valueOf();\n        this._dcxBranch.rootNode.setValue(AdobeLibraryConfig.MODIFIED_KEY, modifiedTime);\n    };\n\n    // Private: update the created timestamp (also sets modified)\n    AdobeLibraryComposite.prototype._updateCreatedTime = function () {\n        var createdTime = new Date().valueOf();\n        this._dcxBranch.rootNode.setValue(AdobeLibraryConfig.CREATED_KEY, createdTime);\n        this._dcxBranch.rootNode.setValue(AdobeLibraryConfig.MODIFIED_KEY, createdTime);\n    };\n\n\n    /**\n        Element filtering and category utilities\n    **/\n\n    // Private: ensure that item 1 and item 2 are in the given order (and adjacent):\n    // Assumes arrayName is always valid, since it's only called internally\n    AdobeLibraryComposite.prototype._ensureOrder = function (arrayName, item1, item2, item2Fixed) {\n        var array = this[arrayName];\n        var dcxParent = arrayName === '_categories' ? this._dcxCategoriesNode : this._dcxElementsNode;\n        var index1 = array.indexOf(item1);\n        var index2 = array.indexOf(item2);\n\n        // Special cases\n        if (index1 === -1 || index2 === -1) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Items not found', this.id);\n        }\n        if (index1 === index2 || index2 === index1 + 1) {\n            return;\n        }\n\n        if (item2Fixed) {\n            // Remove the item1 from its old location\n            array.splice(index1, 1);\n\n            // Place item1 before item2\n            index2 = array.indexOf(item2);\n            array.splice(index2, 0, item1);\n\n            // Update in the dcx document\n            this._dcxBranch.moveChild(item1._dcxNode, index2, dcxParent);\n\n        } else {\n            // Remove the item2 from its old location\n            array.splice(index2, 1);\n\n            // Place item2 after item1\n            index1 = array.indexOf(item1);\n            array.splice(index1 + 1, 0, item2);\n\n            // Update in the dcx document\n            this._dcxBranch.moveChild(item2._dcxNode, index1 + 1, dcxParent);\n        }\n    };\n\n    // Private: get a key representing the given type and category\n    AdobeLibraryComposite.prototype._getFilterKey = function (type, category) {\n        var isFilteredType = type && AdobeLibraryConfig.ELEMENT_TYPE_FILTERS.indexOf(type) !== -1;\n        return (isFilteredType ? type : '*') + '_' + (category ? category.id : '*');\n    };\n\n    // Private: when an element is updated or removed, need to remove it from its old filter array\n    AdobeLibraryComposite.prototype._removeElementFromFilter = function (element) {\n        var key = this._getFilterKey(element.type, element.category);\n        if (this._filterCache[key]) {\n            var index = this._filterCache[key].indexOf(element);\n            if (index !== -1) {\n                this._filterCache[key].splice(index, 1);\n            }\n        }\n    };\n\n    // Private: when an element is updated or created, need to add it to a new filter array\n    // Assumes the filter array doesn't already contain it\n    AdobeLibraryComposite.prototype._addElementToFilter = function (element, doSort) {\n        var key = this._getFilterKey(element.type, element.category);\n        this._filterCache[key] = this._filterCache[key] || [];\n        this._filterCache[key].push(element);\n        if (doSort) {\n            this._ensureFilterOrderForElement(element);\n        }\n    };\n\n    // Private: ensure that a given filter has the right order\n    AdobeLibraryComposite.prototype._ensureFilterOrderForElement = function (element) {\n        var key = this._getFilterKey(element.type, element.category);\n        this._filterCache[key] = this._filterCache[key] || [];\n        var elements = this._elements;\n        this._filterCache[key].sort(function (e1, e2) {\n            var index1 = elements.indexOf(e1);\n            var index2 = elements.indexOf(e2);\n            return index1 < index2 ? -1 : (index1 > index2 ? 1 : 0);\n        });\n    };\n\n    /**\n        Element creation/removal/copying\n    **/\n\n    // Private: creating an element (including the DCX node)\n    // This is for internal operations (e.g. copy/move) that need to create elements\n    AdobeLibraryComposite.prototype._doCreateElement = function (name, type, category, index) {\n\n        // Create node and add to DCX document\n        // Note: DCX requires us to set a path, even though we don't use it for anything\n        var dcxNode = this._dcxBranch.addChild(name, undefined, index, this._dcxElementsNode);\n        dcxNode.path = dcxNode.id;\n        dcxNode.type = type;\n        if (category) {\n            dcxNode.setValue(AdobeLibraryConfig.CATEGORY_KEY, category.id);\n        }\n\n        // Create corresponding element in our structure\n        var element = new AdobeLibraryElement(this, dcxNode);\n        element._updateCreatedTime();\n        if (index !== undefined && index >= 0 && index < this._elements.length) {\n            this._elements.splice(index, 0, element);\n        } else {\n            this._elements.push(element);\n        }\n        this._addElementToFilter(element, index !== undefined);\n\n        return element;\n    };\n\n    // Private: removing an element\n    AdobeLibraryComposite.prototype._doRemoveElement = function (element, removeDCXNode) {\n        var index = this._elements.indexOf(element);\n        if (index !== -1) {\n            this._elements.splice(index, 1);\n        }\n        this._removeElementFromFilter(element);\n\n        if (removeDCXNode) {\n            // Remove from DCX document\n            this._dcxBranch.removeChild(element._dcxNode);\n        }\n\n        // Unbind the element so we can't continue to use it\n        element._markDeletedLocally(true);\n    };\n\n    // Private: Copy or move the given element to the new library: this works both with and without the filesystem\n    AdobeLibraryComposite.prototype._doCopyDCXElement = function (element, copyToLibrary, deleteAfterCopy, newId, callback) {\n        var that = this;\n\n        // NOTE: we do the beginOperation on the new library, because that's the one being modified!!!\n        //       We need to ensure that endOperation() gets called afterwards, even if there was an error\n        copyToLibrary.beginOperation();\n        AdobeLibraryServices.storageInterface.notifyStartWrite(copyToLibrary, [this], function () {\n            // In shared local storage mode, we prevent auto-GC during the copy. That's being conservative, since we might not be copying any components,\n            // but it's better to be safe than sorry!\n\n            copyToLibrary._dcxBranch.copyChild(element._dcxNode, copyToLibrary._dcxElementsNode, undefined, newId, newId, function (err, copiedNode) {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                if (err) {\n                    copyToLibrary.endOperation();\n                    callback(err);\n                    return;\n                }\n\n                // Make the new element based on the copied node, and add it to the library we're copying to\n                var copiedElement = new AdobeLibraryElement(copyToLibrary, copiedNode);\n                copyToLibrary._addElementToFilter(copiedElement);\n                copyToLibrary._elements.push(copiedElement);\n\n                var finishedCopyRenditionCache = function () {\n                    if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                    copyToLibrary.endOperation();\n\n                    // Delete the original element, if it's a move\n                    if (deleteAfterCopy) {\n                        that._wrapOperation(function () {\n                            that._doRemoveElement(element, true);\n                        });\n                    }\n\n                    callback(null, copiedElement);\n                };\n\n                if (AdobeLibraryServices.hasFileSystem()) {\n                    // Copy over the rendition cache as well\n                    // NOTE: the copy calls into setRenditionCache, which takes care of obtaining the lock\n                    AdobeLibraryRenditionUtils.copyRenditionCache(copiedElement, element, element._renditionCache, finishedCopyRenditionCache);\n                } else {\n                    // Don't need to copy the rendition cache if you're in the browser\n                    finishedCopyRenditionCache();\n                }\n            });\n        });\n    };\n\n    // Private: Copy or move the given element to the new library\n    AdobeLibraryComposite.prototype._doCopyElement = function (element, copyToLibrary, deleteAfterCopy, callback) {\n\n        // Make sure the element exists in this library\n        if (element._library !== this || this._elements.indexOf(element) === -1) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'element doesn\\'t exist in library', this.id));\n            return;\n        }\n\n        // Can't copy if the new library will become too big\n        if (copyToLibrary._elements.length >= AdobeLibraryConfig.MAX_ELEMENTS) {\n            callback(new AdobeLibraryError(AdobeLibraryError.EXCEEDS_MAX_LIBRARY_SIZE,\n                                        'Library cannot have more than ' + AdobeLibraryConfig.MAX_ELEMENTS + ' elements', this.id));\n            return;\n        }\n\n        // Keep the element id same when moving/copying element unless\n        // the destination library already has an element with the same id\n        var newId = element.id;\n\n        var isUniqueId = copyToLibrary._elements.every(function (elem) {\n            return elem.id !== newId;\n        });\n\n        if (!isUniqueId) {\n            // The target has an element with the same id so give it a new id\n            newId = AdobeLibraryServices.uuid();\n        }\n\n        // Do the actual copy/move at the DCX level\n        this._doCopyDCXElement(element, copyToLibrary, deleteAfterCopy, newId, callback);\n    };\n\n    // Private: custom pretty printer for testing\n    AdobeLibraryComposite.prototype.jasmineToString = function () {\n        return this.toString();\n    };\n\n    /**\n        Sync-related operations\n    **/\n\n    // Private: set the sync state for the library (and update the overall sync state)\n    AdobeLibraryComposite.prototype._setSyncState = function (syncState) {\n        if (this._syncState !== syncState) {\n            this._syncState = syncState;\n            this._collection._updateSyncState();\n            this._checkSyncFinishedAndNotify();\n        }\n    };\n\n    // Private: get the sync state for the library\n    AdobeLibraryComposite.prototype._isSyncing = function () {\n        return this._syncState !== undefined;\n    };\n\n    // Private: check if we're not syncing, and notify any sync-finished listeners\n    AdobeLibraryComposite.prototype._checkSyncFinishedAndNotify = function () {\n        if (!this._isSyncing()) {\n            // It's possible that the callbacks could add themselves to this array, so\n            // we clear out the array first, before iterating\n            var callbacks = this._waitForSyncToFinishCallbacks;\n            this._waitForSyncToFinishCallbacks = [];\n            callbacks.forEach(function (callback) {\n                callback();\n            });\n        }\n    };\n\n    // Private: wait for the sync to complete\n    AdobeLibraryComposite.prototype._waitForSyncToFinish = function (callback) {\n        this._waitForSyncToFinishCallbacks.push(callback);\n        this._checkSyncFinishedAndNotify();\n    };\n\n    // Private: we store the collaboration data from the sync group\n    AdobeLibraryComposite.prototype._setCollaboration = function (collaboration) {\n        if (this.collaboration !== collaboration) {\n            var dcxCollaboration = AdobeLibraryManifestUtils.collaborationStateToDCX(collaboration);\n            this._dcxComposite.collaborationType = dcxCollaboration;\n\n            // Commit, to save the collaboration state to disk in the DCX; but we don't treat it as a modification, and we don't push.\n            this._commit(true, true);\n            // But, we still need to notify the change listeners, because the library state did change!\n            this._notifyChange();\n        }\n    };\n\n    // Private: returns true iff the given DCX error indicates the composite was deleted from the server\n    AdobeLibraryComposite.prototype._isDeletedError = function (err) {\n        var isDeleted = err && (err.code === AdobeDCXError.NO_COMPOSITE || err.code === AdobeDCXError.DELETED_COMPOSITE);\n        var isUnauthorised = err && err.code === AdobeDCXError.UNEXPECTED_RESPONSE && err.response && err.response.statusCode === 401;\n\n        // Either the composite was deleted, or we get a 401 unauthorised error, and it's a public library (same idea)\n        return isDeleted || (this.collection.isPublic && isUnauthorised);\n    };\n\n    // Private: merge logic into the pulled branch.\n    AdobeLibraryComposite.prototype._mergeAndSwitchToBranch = function (pulledBranch, baseBranch, callback) {\n        var that = this;\n\n        // Flag to tell us if we're merging local changes (i.e. we provided a specific base branch).\n        // This is passed into acceptPulledBranch, so it knows not to try to modify the pulled branch info on disk\n        var isLocalMerge = baseBranch !== undefined;\n        var originalPulledBranchData = pulledBranch.localData;\n\n        function continueWithBaseBranch(err, baseBranch) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            if (err) {\n                callback(AdobeLibraryErrorUtils.getCommitError(err, that.id));\n                return;\n            }\n\n            AdobeLibraryServices.log('Starting merge ' + (isLocalMerge ? '(local)' : '(remote)'));\n\n            // 1) Update library-level stuff\n            // TOFIX: need to deal with categories\n            // If the name was changed locally, this change wins over what was on the server - otherwise the server version wins\n            if (baseBranch.name !== that.name) {\n                pulledBranch.name = that.name;\n            }\n            // Modification time should never retrogress:\n            var pulledLibraryModified = pulledBranch.rootNode.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n            var maxLibraryModified = Math.max(pulledLibraryModified || 0, that.modified || 0);\n            if (maxLibraryModified && pulledLibraryModified !== maxLibraryModified) {\n                pulledBranch.rootNode.setValue(AdobeLibraryConfig.MODIFIED_KEY, maxLibraryModified);\n            }\n\n            // Get the top-level nodes in the new branch\n            var pulledBranchElementsNode;\n            var pulledBranchCategoriesNode;\n            var pulledBranchChildren = pulledBranch.getChildrenOf();\n            pulledBranchChildren.forEach(function (node) {\n                if (node.name === AdobeLibraryConfig.ELEMENTS_NAME) {\n                    pulledBranchElementsNode = node;\n                } else if (node.name === AdobeLibraryConfig.CATEGORIES_NAME) {\n                    pulledBranchCategoriesNode = node;\n                }\n            });\n            if (!pulledBranchElementsNode) {\n                pulledBranchElementsNode = pulledBranch.addChild(AdobeLibraryConfig.ELEMENTS_NAME);\n            }\n            if (!pulledBranchCategoriesNode) {\n                pulledBranchCategoriesNode = pulledBranch.addChild(AdobeLibraryConfig.CATEGORIES_NAME);\n            }\n\n\n            // 2) Iterate through the current elements, and update them to point to the pulled branch (or delete them)\n            var handledElements = {};\n            var pendingNotifications = [];\n            var pendingDeleteElements = [];\n            var pendingAsyncOperations = new AdobeLibraryAsyncJoin();\n\n            that._elements.forEach(function (element) {\n                // Element still points to old DCX node - read some properties we desire\n                var id = element.id;\n\n                var currentNode = element._dcxNode;\n                var currentModified = element.modified;\n\n                // Find the element in the new branch\n                var pulledNode = pulledBranch.getChildWithId(id);\n                var pulledModified = pulledNode && pulledNode.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n\n                // Find the base element, if there is one\n                var baseNode = baseBranch && baseBranch.getChildWithId(id);\n                var baseModified = baseNode && baseNode.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n\n                // Due to changes that preserve the element id on copy/move, it's possible we could have an element both locally\n                // and pulled with the same id, that's not in the base. In this case, baseModified will be undefined.\n                // If we set baseModified to 0, we'll correctly land in the merge conflict case, which will treat the two\n                // changes as conflicting, and make a copy.\n                if (currentModified && pulledModified && !baseModified) {\n                    baseModified = 0;\n                }\n\n                // Now, switch over to the new branch, so we can do our updates in this context\n                that._dcxBranch = pulledBranch;\n\n                // See https://wiki.corp.adobe.com/pages/viewpage.action?pageId=914394629\n                // Only deal with cases that require a change to the pulled branch\n                if ((!baseModified && !pulledModified) || (baseModified && !pulledModified && currentModified !== baseModified)) {\n                    AdobeLibraryServices.log('1: created locally');\n                    // a) A new element on the current branch\n                    // b) Deleted from the server, but have local changes\n                    // => copy the element onto the pulled branch, and update the pointers to it\n                    var copiedNode = pulledBranch.copyChild(currentNode, pulledBranchElementsNode, undefined, undefined, undefined);\n                    element._setDCXNode(copiedNode, true);\n\n                } else if (baseModified && !pulledModified && currentModified === baseModified) {\n                    AdobeLibraryServices.log('2: deleted on server');\n                    // Deleted on server - remove the element locally\n                    pendingDeleteElements.push(element);\n\n                } else if (baseModified === currentModified && baseModified === pulledModified) {\n                    AdobeLibraryServices.log('3: no changes');\n                    // No changes\n                    element._setDCXNode(pulledNode, true);\n\n                } else if (baseModified === currentModified && baseModified !== pulledModified) {\n                    AdobeLibraryServices.log('4: updated on server');\n                    // Updated on server (note that if it's a local merge, it's possible for the pulledModified to be older than the baseModified)\n                    // Note: we clear the rendition cache, unless it's a local merge (which means the new rendition should be there!)\n                    element._setDCXNode(pulledNode, isLocalMerge);\n                    pendingNotifications.push(element);\n\n                } else if (baseModified !== currentModified && baseModified === pulledModified) {\n                    AdobeLibraryServices.log('5: updated locally');\n                    // Updated locally => copy the element into the pulled branch\n                    var updatedNode = pulledBranch.replaceChild(currentNode, undefined, undefined);\n                    element._setDCXNode(updatedNode, true);\n\n                } else if (baseModified !== currentModified && baseModified !== pulledModified) {\n                    AdobeLibraryServices.log('6: updated locally and on server (conflict)');\n                    // Updated both locally and on server.\n                    // Element becomes pulled element, but create a new element as a copy of current element\n                    var oldRenditionCache = element._renditionCache;\n                    element._setDCXNode(pulledNode);\n                    pendingNotifications.push(element);\n\n                    var newId = AdobeLibraryServices.uuid();\n\n                    // Make a copy of the current element\n                    // Note: DCX requires us to set a path, even though we don't use it for anything\n                    // Note 2: This now works in both the browser and filesystem cases\n                    var newCopiedNode = pulledBranch.copyChild(currentNode, pulledBranchElementsNode, undefined, newId, newId);\n\n                    var newCopiedElement = new AdobeLibraryElement(that, newCopiedNode);\n                    that._addElementToFilter(newCopiedElement);\n                    that._elements.push(newCopiedElement);\n                    handledElements[newCopiedElement.id] = true;\n\n                    // Copy over the rendition cache as well, if in the filesystem\n                    if (AdobeLibraryServices.hasFileSystem()) {\n                        pendingAsyncOperations.addOperation(AdobeLibraryRenditionUtils.copyRenditionCache, [newCopiedElement, element, oldRenditionCache]);\n                    }\n\n                    AdobeLibraryAnalytics.reportCollisionElement(element);\n\n                } else {\n                    AdobeLibraryServices.log('ERROR: unexpected merge case: base=' + baseModified + ', current=' + currentModified + ', pulled=' + pulledModified);\n                }\n\n                // Switch back to the current branch for the next element in the loop\n                that._dcxBranch = that._dcxComposite.current;\n\n                handledElements[id] = true;\n            });\n\n            // Delete the elements we need to, since don't want to do that while we're iterating over the elements ;-)\n            pendingDeleteElements.forEach(function (element) {\n                that._doRemoveElement(element, false);\n            });\n\n\n            // 3) Switch over to new branch, and update the top-level node pointers\n            that._dcxBranch = pulledBranch;\n            that._dcxElementsNode = pulledBranchElementsNode;\n            that._dcxCategoriesNode = pulledBranchCategoriesNode;\n\n            // 4) Iterate through the nodes on the pulled branch\n            var elementNodes = that._dcxBranch.getChildrenOf(that._dcxElementsNode);\n            elementNodes.forEach(function (node) {\n                if (!handledElements[node.id]) {\n                    // It's an element that isn't on the current branch\n                    // Get the base element, if there is one\n\n                    var pulledModified = node.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n                    var baseNode = baseBranch && baseBranch.getChildWithId(node.id);\n                    var baseModified = baseNode && baseNode.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n\n                    // We're going to add the element UNLESS it was deleted locally, and there were no pulled changes\n                    if (baseModified && pulledModified && baseModified === pulledModified) {\n                        AdobeLibraryServices.log('7: deleted locally');\n                        // Delete the node from the branch\n                        pulledBranch.removeChild(node);\n\n                    } else {\n                        AdobeLibraryServices.log('8: created on server');\n                        // Create the element\n                        var element = new AdobeLibraryElement(that, node);\n                        that._addElementToFilter(element);\n\n                        that._elements.push(element);\n                    }\n                }\n            });\n\n            // 5) Now run all the asynchronous operations we queued up\n            // Note: Up to this point, everything has been synchronous. We need to block any commits now, while this is happening\n            // (we'll commit anyway, when we call resolvePullWithBranch\n            that._transactionCount++;\n            pendingAsyncOperations.run(function () {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                that._transactionCount--;\n\n                // 6) Accept the merged branch (this also writes it to disk)\n                AdobeLibraryServices.storageInterface.resolvePullWithBranch(that, pulledBranch, originalPulledBranchData, isLocalMerge, function (err) {\n                    if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                    if (err) {\n                        callback(AdobeLibraryErrorUtils.getCommitError(err, that.id));\n                        return;\n                    }\n\n                    // TEMPORARY: store the base branch in memory if we don't have a file system\n                    if (!AdobeLibraryServices.hasFileSystem()) {\n                        that._dcxBaseBranch = pulledBranch.copy();\n                    }\n\n                    // 7) Go through all the elements and spin off the rendition requests, so we get the correct thumbnails\n                    // Don't prefetch renditions if it's a local merge, because the rendition should be being set!\n                    if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE && !isLocalMerge) {\n                        AdobeLibraryRenditionUtils.prefetchRenditions(that);\n                    }\n\n                    // Notify any listeners, and commit the changes\n                    pendingNotifications.forEach(function (element) {\n                        element._listenerManager.notify('change');\n                    });\n                    that._notifyChange();\n\n                    callback(null);\n                });\n            });\n        }\n\n        // We can pull while we're making changes, but make sure we always finish a commit before we do a merge!!!!\n        this._waitForCommit(function () {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            if (baseBranch) {\n                // Explicitly specifying the base branch (should only be used in the shared local storage case)\n                continueWithBaseBranch(null, baseBranch);\n\n            } else if (that._dcxBranch.compositeState === 'unmodified') {\n                // Current branch is the same as the base branch\n                continueWithBaseBranch(null, that._dcxBranch);\n\n            } else {\n                if (AdobeLibraryServices.hasFileSystem()) {\n                    // Need to load the base branch\n                    that._dcxComposite.loadBaseBranch(continueWithBaseBranch);\n                } else {\n                    // For the in-browser case, we use the in-memory base branch\n                    continueWithBaseBranch(null, that._dcxBaseBranch);\n                }\n            }\n        });\n    };\n\n    // Private: pull from the server and merge\n    AdobeLibraryComposite.prototype._pull = function (_callback) {\n        var that = this;\n\n        if (!this._dcxComposite.href || !this._dcxBranch.isBound) {\n            // Can't pull if we've never pushed, so just return\n            _callback(null, false);\n            return;\n        }\n\n        if (this._deletedFromServer) {\n            // Don't try to pull if we were already deleted\n            _callback(null, false);\n            return;\n        }\n\n        // *** Obtain lock before going any further: can't be doing more than one push/pull at the same time!\n\n        var callback = function (err, didPull) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, _callback)) { return; }\n\n            // Setting sync state and error needs to happen before the networkLock is released,\n            // because we may immediately start syncing again\n            if (err) {\n                that._collection._reportSyncError(err);\n            }\n            that._setSyncState();\n\n            that._networkLock.release();\n\n            _callback(err, didPull);\n        };\n\n        this._networkLock.obtain(function (err) {\n            // Just return if aborted (couldn't obtain lock)\n            if (err) { _callback(null); return; }\n\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, _callback)) { return; }\n\n            this._setSyncState('downloading');\n            this._collection._syncManager.pullComposite(this._dcxComposite, this._collection, function (err, pulledBranch) {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, _callback)) { return; }\n\n                if (that._isDeletedError(err)) {\n                    if (AdobeLibraryServices.hasFileSystem() && that._dcxBranch.compositeState === 'modified' && that.collaboration !== 'incoming') {\n                        // If the composite (that you own) was modified locally, we immediately re-upload it, so we don't lose local changes\n                        that._doRebindToServer(_callback); // IMPORTANT: _callback, not callback, because we're releasing the lock here\n                        that._networkLock.release();\n\n                    } else {\n                        // If the composite was deleted on the server, mark it as deleted\n                        that._deletedFromServer = true;\n                        that._notifyChange();\n                        callback(null, true);\n                    }\n                    return;\n                }\n\n                if (err) {\n                    callback(AdobeLibraryErrorUtils.getSyncError(err, that.id));\n                    return;\n                }\n\n                if (!pulledBranch) {\n                    // Nothing changed\n                    callback(null, false);\n                    return;\n                }\n\n                that._mergeAndSwitchToBranch(pulledBranch, undefined, function (err) {\n                    if (AdobeLibraryManifestUtils.checkDeletedState(that, _callback)) { return; }\n\n                    callback(err, true);\n                });\n            });\n        }, this);\n    };\n\n    // Private: pushing changes to the server\n    AdobeLibraryComposite.prototype._pushWithParameters = function (overwrite, _callback) {\n        var that = this;\n\n        var doCallback = function (err, didPush) {\n            if (_callback) {\n                _callback(null, didPush);\n            }\n        };\n\n        // If we're not supposed to be syncing, don't do nowt!\n        if (!AdobeLibraryConfig.SYNCING_ENABLED) {\n            doCallback(null, false);\n            return;\n        }\n\n        // If we have a retry pending, we block any other syncs until then\n        if (this._collection._retryTimeoutId) {\n            doCallback(null, false);\n            return;\n        }\n\n        if (this._dcxBranch.isBound && this._dcxBranch.compositeState !== 'modified') {\n            // Nothing was modified, so don't need to push anything\n            doCallback(null, false);\n            return;\n        }\n\n        if (this._deletedFromServer) {\n            // Don't try to push if we were already deleted from the server\n            doCallback(null, false);\n            return;\n        }\n\n        if (!this.writable) {\n            // Don't ever push if we're not allowed to write to the library. In this mode, we shouldn't be able to make\n            // any changes in the first place, but just in case, we never try to push (since the push can never succeed).\n            doCallback(null, false);\n            return;\n        }\n\n        if (this._pushPending) {\n            // We're waiting to do a push, but we haven't yet started, so no need to queue up another!!\n            doCallback(null, false);\n            return;\n        }\n\n        // *** Obtain lock before going any further: can't be doing more than one push/pull at the same time!\n\n        var callback = function (err, didPush) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, doCallback)) { return; }\n\n            // Setting sync state and error needs to happen before the networkLock is released,\n            // because we may immediately start syncing again\n            that._pushFailedDueToQuota = false;\n            if (err) {\n                that._collection._reportSyncError(err);\n\n                // Set a flag on the library to indicate if\n                if (err.code === AdobeLibraryError.EXCEEDS_QUOTA) {\n                    that._pushFailedDueToQuota = true;\n                }\n            }\n            that._setSyncState();\n\n            that._networkLock.release();\n\n            doCallback(null, didPush);\n        };\n\n        this._pushPending = true;\n\n        this._networkLock.obtain(function (err) {\n            // Just return if aborted (couldn't obtain lock)\n            if (err) { doCallback(null, false); return; }\n\n            this._waitForCommit(function () {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, doCallback)) { return; }\n\n                that._pushPending = false;\n\n                // TEMPORARY: store the base branch in memory if we don't have a file system\n                // Have to make the copy before the push, because the current branch could change during the push\n                var dcxPushingBranch;\n                if (!AdobeLibraryServices.hasFileSystem()) {\n                    dcxPushingBranch = that._dcxBranch.copy();\n                }\n\n                that._setSyncState('uploading');\n                that._collection._syncManager.pushComposite(that._dcxComposite, that._collection, overwrite, function (err) {\n                    if (AdobeLibraryManifestUtils.checkDeletedState(that, doCallback)) { return; }\n\n                    if (that._isDeletedError(err)) {\n                        if (AdobeLibraryServices.hasFileSystem() && that._dcxBranch.compositeState === 'modified' && that.collaboration !== 'incoming') {\n                            // If the composite (that you own) was modified locally, we immediately re-upload it, so we don't lose local changes\n                            that._doRebindToServer(doCallback); // IMPORTANT: doCallback, not callback, because we're releasing the lock here\n                            that._networkLock.release();\n\n                        } else {\n                            // If the composite was deleted on the server, and we have no local changes, just mark it as deleted\n                            that._deletedFromServer = true;\n                            that._notifyChange();\n                            callback(null, true);\n                        }\n\n                        return;\n                    }\n\n                    if (err && err.code === AdobeLibraryError.TRANSFER_ABORTED) {\n                        // Don't accept the push if it was aborted\n                        callback(null, true);\n                        return;\n                    }\n\n                    if (err && err.code === AdobeDCXError.UPDATE_CONFLICT) {\n                        AdobeLibraryServices.log('Push failed due to conflict: ' + that.id);\n                        that._numUpdateConflicts++;\n\n                        // IMPORTANT: We're seeing a bug in the wild where we get into an infinite cycle of update conflicts\n                        // To prevent an infinite cycle, we'll allow at most 5 update conflicts, before we back-off with a transfer error\n\n                        if (that._numUpdateConflicts <= AdobeLibraryConfig.MAX_UPDATE_CONFLICTS) {\n                            // If there was an update conflict, need to retry syncing (push and pull)\n                            // Careful: we schedule a sync first, then release the network lock so it can proceed\n                            that._sync(false, doCallback); // IMPORTANT: doCallback, not callback, because we're releasing the lock here\n                            that._networkLock.release();\n                            return;\n                        }\n\n                        // Since we aborted, we should send some analytics\n                        AdobeLibraryAnalytics.reportUnexpectedState(that, 'updateConflict');\n                        AdobeLibraryServices.log('Reached maximum number of update-conflict retries: ' + that.id);\n                    }\n\n                    // At this point, either it wasn't an update conflict, or we're aborting with a TRANSFER_ERROR - in which case we reset\n                    // the count, so we can try again on the next sync\n                    that._numUpdateConflicts = 0;\n\n                    if (err && err.code === AdobeDCXError.COMPONENT_UPLOAD_ERROR) {\n                        AdobeLibraryServices.log('Push failed due to component upload failure: ' + that.id);\n\n                        // Remove any components that failed to push because they're missing from disk\n                        // This will trigger another push if any of the representations were removed.\n                        // Note that we still 'fail' the push with an error message, because something really did go wrong...\n                        // but since we'll try to recover in the background, the user impact should be minimal (plus we hope\n                        // this case will never happen in practice)\n                        AdobeLibraryManifestUtils.removeMissingLocalComponents(that, err.failedComponents);\n                    }\n\n                    if (err) {\n                        callback(AdobeLibraryErrorUtils.getSyncError(err, that.id));\n                        return;\n                    }\n\n                    // Accept the push - this updates the current branch with info from the push (e.g. new etags)\n                    AdobeLibraryServices.storageInterface.acceptPush(that, function (err) {\n                        if (AdobeLibraryManifestUtils.checkDeletedState(that, doCallback)) { return; }\n\n                        if (err) {\n                            callback(AdobeLibraryErrorUtils.getCommitError(err, that.id), true);\n                            return;\n                        }\n\n                        // TEMPORARY: store the base branch in memory if we don't have a file system\n                        if (!AdobeLibraryServices.hasFileSystem()) {\n                            that._dcxBaseBranch = dcxPushingBranch;\n                        }\n\n                        callback(null, true);\n                    });\n                });\n            });\n        }, this);\n    };\n\n    // Private: pushing changes to the server\n    AdobeLibraryComposite.prototype._push = function (callback) {\n        this._pushWithParameters(false, callback);\n    };\n\n    AdobeLibraryComposite.prototype._abortPushOrPull = function () {\n        // Abort any pending operations:\n        this._networkLock.abortPendingOperations(new AdobeLibraryError(AdobeLibraryError.TRANSFER_ABORTED));\n\n        // Abort any current operation:\n        this._collection._syncManager.abortPushOrPull(this.id);\n    };\n\n    // Private: delete library from the server\n    AdobeLibraryComposite.prototype._deleteFromServer = function (forceDelete, callback) {\n        var that = this;\n\n        if (!this._dcxComposite.href || !this._dcxBranch.isBound) {\n            // It was never pushed to the server, so nothing to do\n            callback(null);\n            return;\n        }\n\n        if (this._deletedFromServer) {\n            // Already deleted from server, so nothing to do\n            callback(null);\n            return;\n        }\n\n        // If we were in the middle of syncing (and it's not the delete that we're syncing), we abort it\n        if (!this._deletingFromServerInProgress) {\n            this._abortPushOrPull();\n        }\n        this._deletingFromServerInProgress = true;\n\n\n        // *** Obtain lock before going any further: can't be doing more than one push/pull at the same time!\n\n        var onFinished = function (err) {\n            that._deletingFromServerInProgress = false;\n            that._networkLock.release();\n            callback(err);\n        };\n\n        this._networkLock.obtain(function (err) {\n            // Just return if aborted (couldn't obtain lock)\n            if (err) { callback(null); return; }\n\n            if (this._deletedFromDisk) { onFinished(null); return; }\n\n            // We need to mark the DCX composite as a pending delete, then push it to the server\n            this._setSyncState('uploading');\n            this._dcxBranch.compositeState = 'pendingDelete';\n            this._commit(true, true); // This commits the library to disk, without changing the modification date, or pushing to the server\n            this._waitForCommit(function () {\n                if (that._deletedFromDisk) { onFinished(null); return; }\n\n                that._collection._syncManager.pushDeletedComposite(that._dcxComposite, that._collection, that.collaboration, forceDelete, function (err) {\n                    // Setting sync state and error needs to happen before the networkLock is released,\n                    // because we may immediately start syncing again\n                    if (err) {\n                        // Ignore deleted errors, because it means it's already deleted on the server\n                        if (that._isDeletedError(err)) {\n                            err = null;\n                        } else {\n                            // Something went wrong, so convert the error into a library error.\n                            // Unless it's an update conflict, in which case we return the error instead, expecting it to be handled\n                            if (forceDelete || err.code !== AdobeDCXError.UPDATE_CONFLICT) {\n                                err = AdobeLibraryErrorUtils.getSyncError(err, that.id);\n                                that._collection._reportSyncError(err);\n                            }\n                        }\n\n                    } else {\n                        that._deletedFromServer = true;\n                    }\n                    that._setSyncState();\n\n                    onFinished(err);\n                });\n            });\n        }, this);\n    };\n\n    // Private: the actual re-binding to the server\n    AdobeLibraryComposite.prototype._doRebindToServer = function (callback) {\n        var that = this;\n\n        this._deletedFromServer = false;\n\n        // If it's an incoming collaboration, we call resetIdentity - this is the same as resetBinding,\n        // except it also changes the id. Otherwise, the original owner could try to share with you again,\n        // leading to carnage and chaos.\n        var resetFunction = this.collaboration === 'incoming' ? 'resetIdentity' : 'resetBinding';\n        var oldId = this.id;\n\n        this._dcxComposite[resetFunction](function (err) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            if (err) { callback(err); return; }\n\n            // Prevent commits while we move the library\n            that._transactionCount++;\n\n            if (that.id !== oldId) {\n                // If the id changed, we need to update the data structures in the library collection\n                that._collection._libraryIdMap[that.id] = that;\n                delete that._collection._libraryIdMap[oldId];\n            }\n\n            // If the id changed, we need to move the folders\n            // Note: moveLibrary doesn't do anything if the old and new ids are the same\n            AdobeLibraryFileUtils.moveLibrary(that, oldId, function (err) {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                that._transactionCount--;\n\n                if (err) { callback(err); return; }\n\n                that._collection._syncManager.prepareCompositeForPush(that._dcxComposite);\n                that._setCollaboration(); // Clear the collaboration state, since it won't be shared after being re-uploaded\n                that._commit(false, true); // Don't change the modification timestamp\n\n                // Note: pushWithParameters waits for the commit before doing the push\n                that._pushWithParameters(true, callback);\n            });\n        });\n    };\n\n    // Sync (push/pull) a library\n    // Optimisation: if you know the library didn't change, call with pushOnly=true\n    AdobeLibraryComposite.prototype._sync = function (pushOnly, _callback) {\n        var that = this;\n\n        function callback(err, didPushOrPull) {\n            if (_callback) {\n                // Since we might be already syncing (and so we don't trigger another sync), we always\n                // make sure we wait for the sync to finish before making the actual callback. This means\n                // that anyone calling _sync can be sure that they won't be called back until the sync\n                // is completed - either the one they triggered, or the one that was already in progress\n                that._waitForSyncToFinish(function () {\n                    _callback(err, didPushOrPull);\n                });\n            }\n        }\n\n        // Disable syncing if we have shared local storage - that service will do the syncing for us\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE || !AdobeLibraryConfig.SYNCING_ENABLED) {\n            callback(null, false);\n            return;\n        }\n\n        // If we have a retry pending, we block any other syncs until then\n        if (this._collection._retryTimeoutId) {\n            callback(null, false);\n            return;\n        }\n\n        // Clear any error state before the sync\n        this._collection._clearSyncErrors(this.id);\n\n        function tryPush(err, didPull) {\n            if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n            if (err) {\n                // Don't even attempt a push if the pull failed (we could get into an infinite cycle)\n                callback(err, didPull);\n                return;\n            }\n\n            that._push(function (err, didPush) {\n                if (AdobeLibraryManifestUtils.checkDeletedState(that, callback)) { return; }\n\n                callback(err, didPull || didPush);\n            });\n        }\n\n        if (pushOnly) {\n            // Push only\n            tryPush(null, false);\n        } else {\n            // Pull then push\n            this._pull(tryPush);\n        }\n    };\n\n    // Private:\n    AdobeLibraryComposite.prototype._getCompositeDir = function () {\n        return this._collection._getCompositeDir(this.id);\n    };\n\n    // Private:\n    AdobeLibraryComposite.prototype._getRenditionCacheDir = function () {\n        return this._collection._getRenditionCacheDir(this.id);\n    };\n\n\n    /**\n        Public API\n    **/\n\n    // Getters/setters for properties\n    Object.defineProperties(AdobeLibraryComposite.prototype, {\n        /**\n         * The id of the library (this will never change, after the library is created).\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {String}\n         * @instance\n         */\n        id: {\n            get: function () {\n                return this._publicId || this._dcxComposite.id;\n            },\n            set: function (id) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the id of an existing library', this.id);\n            }\n        },\n        /**\n         * The library collection that the library belongs to.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {AdobeLibraryCollection}\n         * @instance\n         */\n        collection: {\n            get: function () {\n                return this._collection;\n            },\n            set: function (library) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'collection is a read-only property', this.id);\n            }\n        },\n        /**\n         * Whether or not write operations are permitted on the library. If `false`, you'll receive an {@AdobeLibraryError.NOT_ALLOWED} error\n         * if you try to modify the library.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Boolean}\n         * @instance\n         */\n        writable: {\n            get: function () {\n                return this._writable;\n            },\n            set: function (library) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'writable is a read-only property', this.id);\n            }\n        },\n        /**\n         * The name of the library. To modify the name, just set this to a new value, and it will automatically save and sync\n         * the change to the server.\n         *\n         * Changing the name of a deleted library will result in a {@link AdobeLibraryError.DELETED_LOCALLY} exception.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {String}\n         * @instance\n         */\n        name: {\n            get: function () {\n                return this._dcxComposite.name || '';\n            },\n            set: function (name) {\n                AdobeLibraryManifestUtils.checkDeletedState(this);\n\n                if (!this.writable) {\n                    throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n                }\n\n                this._dcxComposite.name = name;\n                this._commit();\n            }\n        },\n        /**\n         * A number representing the time that the library was last modified. This gets updated whenever a change is made to the library,\n         * or any of its elements.\n         *\n         * This follows the primitive value of a `Date` object (see [`Date.valueOf`](http://www.w3schools.com/jsref/jsref_valueof_date.asp))\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Number}\n         * @instance\n         */\n        modified: {\n            get: function () {\n                return this._dcxBranch.rootNode.getValue(AdobeLibraryConfig.MODIFIED_KEY);\n            },\n            set: function (modified) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the modified timestamp of a library directly', this.id);\n            }\n        },\n        /**\n         * A number representing the time that the library was created.\n         *\n         * This follows the primitive value of a `Date` object (see [`Date.valueOf`](http://www.w3schools.com/jsref/jsref_valueof_date.asp))\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Number}\n         * @instance\n         */\n        created: {\n            get: function () {\n                return this._dcxBranch.rootNode.getValue(AdobeLibraryConfig.CREATED_KEY);\n            },\n            set: function (created) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot change the created timestamp of a library directly', this.id);\n            }\n        },\n        /**\n         * **UNSUPPORTED** An array of all the categories belonging to the library.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Array.<AdobeLibraryCategory>}\n         * @instance\n         * @ignore\n         */\n        categories: {\n            get: function () {\n                return this._categories;\n            },\n            set: function (id) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot modify categories list directly', this.id);\n            }\n        },\n        /**\n         * An array of all the elements in the library.\n         *\n         * Read-only - to add or remove elements, see {@link AdobeLibraryComposite#createElement} and\n         * {@link AdobeLibraryComposite#removeElement} respectively.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Array.<AdobeLibraryElement>}\n         * @instance\n         */\n        elements: {\n            get: function () {\n                return this._elements;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot modify elements list directly', this.id);\n            }\n        },\n        /**\n         * This is `true`, if and only if the library is deleted on the server. This flag gets set during a sync, if the library\n         * was discovered to no longer exist on the server. We never automatically remove deleted libraries - it's up to you to do\n         * this, either by explictly removing the deleted library ({@link AdobeLibraryCollection#removeLibrary}), or by calling\n         * {@link AdobeLibraryCollection#removeDeletedLibraries}.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Boolean}\n         * @instance\n         */\n        deletedFromServer: {\n            get: function () {\n                return this._deletedFromServer;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'deletedFromServer is a read-only property', this.id);\n            }\n        },\n        /**\n         * This is `true`, if and only if the library is deleted locally. This is the case if the library has been removed\n         * from the library collection. You should stop referencing the\n         * library - any further operations will be met with an error.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Boolean}\n         * @instance\n         */\n        deletedLocally: {\n            get: function () {\n                return this._deletedLocally;\n            },\n            set: function (element) {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'deletedLocally is a read-only property', this.id);\n            }\n        },\n        /**\n         * This is `true`, if and only if the most recent push of this library failed due to the user having insufficient quota.\n         * Note: quota limits for Creative Cloud Libraries have not yet been put in place, so you should not expect to see this in\n         * practice right now.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Boolean}\n         * @instance\n         */\n        quotaExceeded: {\n            get: function () {\n                return this._pushFailedDueToQuota;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'quotaExceeded is a read-only property', this.id);\n            }\n        },\n        /**\n         * The collaboration state of the library: either `undefined` (not collaborated), `'outgoing'` (a library that the user\n         * owns, and has shared with others), or `'incoming'` (a library belonging to another user, that has been shared with this\n         * user).\n         *\n         * Currently, the only way to change the collaboration state of a library is to go to the Creative Cloud website (which calls\n         * the collaboration service to modify the list of collaborators).\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {String|undefined}\n         * @instance\n         */\n        collaboration: {\n            get: function () {\n                var dcxCollaboration = this._dcxComposite.collaborationType;\n                return AdobeLibraryManifestUtils.collaborationStateFromDCX(dcxCollaboration);\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'collaboration is a read-only property', this.id);\n            }\n        },\n        /**\n         * If the library is syncing, this will have a value of `'uploading'` or `'downloading'`, depending on what is\n         * happening at that moment. If the library is not syncing, the value will be `undefined`.\n         *\n         * Use {@link AdobeLibraryCollection#addSyncListener} to register for notifications when this value changes.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {String|undefined}\n         * @instance\n         */\n        syncState: {\n            get: function () {\n                return this._syncState;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncState is a read-only property');\n            }\n        },\n        /**\n         * If the library is syncing, this may have a value between 0 and 100, indicating the progress of this particular\n         * library. If the library isn't syncing, or we have no information about the progress, the value will be `undefined`.\n         *\n         * Use {@link AdobeLibraryCollection#addSyncListener} to register for notifications when this value changes.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryComposite\n         * @type {Number|undefined}\n         * @instance\n         */\n        syncProgress: {\n            get: function () {\n                var syncProgress = this._collection._syncProgressMap[this.id];\n                return syncProgress && syncProgress.progress;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncProgress is a read-only property');\n            }\n        }\n    });\n\n    // Custom toString method for debugging - don't show internal fields\n    AdobeLibraryComposite.prototype.toString = function () {\n        return JSON.stringify(this._toJSON());\n    };\n\n    /**\n        Change notifications\n    **/\n\n    /**\n     * Register a listener for changes in the library - this includes elements being added or removed, but also any changes\n     * to elements and their representations. The notification happens both for changes initiated through the library API, and\n     * for changes as a consequence of syncing with the server.\n     *\n     * Note that the change callback doesn't tell you what changed - it's intended to be used to trigger a redraw of the entire\n     * library. If you only want notifications when a specific element changes, see {@link AdobeLibraryElement#addChangeListener}.\n     *\n     * @param {Function} callback This gets called whenever the library changes.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY}\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.addChangeListener = function (callback) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        this._listenerManager.add('change', callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the library.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryComposite#addChangeListener}.\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.removeChangeListener = function (callback) {\n        this._listenerManager.remove('change', callback);\n    };\n\n    /**\n        Elements\n    **/\n\n    /**\n     * Create a new element, and add it to the library. This automatically saves the new element to disk, and syncs it to the server.\n     * See {@link AdobeLibraryComposite#beginOperation} if you want to make changes to the element (such\n     * as adding representations) before it's committed/pushed.\n     *\n     * @param {String} name The name of the new element.\n     * @param {String} type The type of the new element (see {@link AdobeLibraryElement#type}).\n     * @returns {AdobeLibraryElement} The new element.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER|AdobeLibraryError.EXCEEDS_MAX_LIBRARY_SIZE|AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.createElement = function (name, type, category, index) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        if (this._elements.length >= AdobeLibraryConfig.MAX_ELEMENTS) {\n            throw new AdobeLibraryError(AdobeLibraryError.EXCEEDS_MAX_LIBRARY_SIZE,\n                                        'Library cannot have more than ' + AdobeLibraryConfig.MAX_ELEMENTS + ' elements', this.id);\n        }\n\n        if (!category && this._categories.length > 0) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Must provide a category for a new element, if the library has categories', this.id);\n        }\n        if (category && this._categories.indexOf(category) === -1) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid category', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            var element = this._doCreateElement(name, type, category, index);\n            AdobeLibraryAnalytics.reportCreateElement(element);\n\n            return element;\n        }, this);\n    };\n\n    /**\n     * Remove an element from the library. This automatically saves the change to disk, and syncs it to the server.\n     *\n     * @param {AdobeLibraryElement} element The element to remove.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.removeElement = function (element) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            this._doRemoveElement(element, true);\n\n            AdobeLibraryAnalytics.reportDeleteElement(element);\n        }, this);\n    };\n\n    /**\n     * **UNSUPPORTED** Reorder an element - move it so it's immediately after another element.\n     *\n     * @param {AdobeLibraryElement} element The element to move.\n     * @param {AdobeLibraryElement} afterElement The element to move `element` after.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     * @ignore\n     */\n    AdobeLibraryComposite.prototype.moveElementAfter = function (element, afterElement) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            this._ensureOrder('_elements', afterElement, element);\n            this._ensureFilterOrderForElement(element);\n        }, this);\n    };\n\n    /**\n     * **UNSUPPORTED** Reorder an element - move it so it's immediately before another element.\n     *\n     * @param {AdobeLibraryElement} element The element to move.\n     * @param {AdobeLibraryElement} beforeElement The element to move `element` before.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     * @ignore\n     */\n    AdobeLibraryComposite.prototype.moveElementBefore = function (element, beforeElement) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            this._ensureOrder('_elements', element, beforeElement, true);\n            this._ensureFilterOrderForElement(element);\n        }, this);\n    };\n\n    /**\n     * Copy an element to another library. You're allowed to copy the element to the same library,\n     * in which case the element is duplicated.\n     *\n     * Calling this on a deleted library will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {AdobeLibraryElement} element The element to copy.\n     * @param {AdobeLibraryComposite} newLibrary The library to copy the element to.\n     * @param {Function} callback This gets called when the copy completes.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {AdobeLibraryElement} callback.element The new copied element.\n     *\n     * @memberof AdobeLibraryComposite\n     * @instance\n     */\n    AdobeLibraryComposite.prototype.copyElement = function (element, newLibrary, callback) {\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        if (!element) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'No element specified', this.id));\n            return;\n        }\n\n        if (!newLibrary) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'No destination library specified', this.id));\n            return;\n        }\n\n        if (!newLibrary.writable) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', newLibrary.id));\n            return;\n        }\n\n        return this._doCopyElement(element, newLibrary, false, function (err, newCopiedElement) {\n            if (err) { callback(err); return; }\n\n            AdobeLibraryAnalytics.reportCopyElement(newCopiedElement, element);\n            callback(null, newCopiedElement);\n        });\n    };\n\n    /**\n     * Move an element to another library. This must be a different library from the library the element\n     * belongs to. This operation is equivalent to copying the element, and then deleting the original.\n     *\n     * Calling this on a deleted library will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {AdobeLibraryElement} element The element to move.\n     * @param {AdobeLibraryComposite} newLibrary The library to move the element to.\n     * @param {Function} callback This gets called when the move completes.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {AdobeLibraryElement} callback.element The new moved element.\n     *\n     * @memberof AdobeLibraryComposite\n     * @instance\n     */\n    AdobeLibraryComposite.prototype.moveElement = function (element, newLibrary, callback) {\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        if (!this.writable) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id));\n            return;\n        }\n\n        if (!element) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'No element specified', this.id));\n            return;\n        }\n\n        if (!newLibrary) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'No destination library specified', this.id));\n            return;\n        }\n\n        if (this === newLibrary) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Move must have a different destination library', this.id));\n            return;\n        }\n\n        return this._doCopyElement(element, newLibrary, true, function (err, newCopiedElement) {\n            if (err) { callback(err); return; }\n\n            AdobeLibraryAnalytics.reportMoveElement(newCopiedElement, element);\n            callback(null, newCopiedElement);\n        });\n    };\n\n    /**\n        Categories\n    **/\n\n    /**\n     * **UNSUPPORTED** Create a new category.\n     *\n     * @param {String} name The name of the new category.\n     * @param {Number} [index] The index to insert the category at (by default, it gets appended to the end).\n     * @returns {AdobeLibraryCategory} The new category.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     * @ignore\n     */\n    AdobeLibraryComposite.prototype.createCategory = function (name, index) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n\n            // Create node and add to DCX document\n            var dcxNode = this._dcxBranch.addChild(name, undefined, index, this._dcxCategoriesNode);\n\n            // Create corresponding element in our structure\n            var category = new AdobeLibraryCategory(this, dcxNode);\n\n            if (index !== undefined && index >= 0 && index < this._categories.length) {\n                this._categories.splice(index, 0, category);\n            } else {\n                this._categories.push(category);\n            }\n\n            if (this._categories.length === 1) {\n                // If we add the first category, make sure all elements get assigned to this category\n                this._elements.forEach(function (element) {\n                    element.category = category;\n                });\n            }\n\n            return category;\n        }, this);\n    };\n\n    /**\n     * **UNSUPPORTED** Remove a category from the library.\n     *\n     * @param {AdobeLibraryCategory} category The category to remove.\n     * @param {Boolean} [shouldDeleteElements=false] If `true`, the elements belonging to the category will also be\n     * removed from the library.\n     * @param {AdobeLibraryCategory} [replacementCategory] If `!shouldDeleteElements`, specify the new category\n     * to move the elements belonging to the removed category into.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER|AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     * @ignore\n     */\n    AdobeLibraryComposite.prototype.removeCategory = function (category, shouldDeleteElements, replacementCategory) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            var that = this;\n            var index = this._categories.indexOf(category);\n\n            function doRemoveCategory() {\n                // Remove from DCX document\n                that._dcxBranch.removeChild(category._dcxNode);\n\n                // Remove from our data structure\n                that._categories.splice(index, 1);\n\n                // Unbind the category so we can't continue to use it\n                category._markDeletedLocally(true);\n            }\n\n            if (index !== -1) {\n\n                if (shouldDeleteElements) {\n                    // Delete the elements in the category we're deleting\n                    var elementsToDelete = [];\n                    this._elements.forEach(function (element) {\n                        if (element.category === category) {\n                            elementsToDelete.push(element);\n                        }\n                    });\n                    elementsToDelete.forEach(function (element) {\n                        that.removeElement(element);\n                    });\n\n                    // Actually remove the category\n                    doRemoveCategory();\n\n                } else {\n                    if (this._categories.length === 1) {\n                        // Must set category to undefined\n                        if (replacementCategory !== undefined) {\n                            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid replacement category', this.id);\n                        }\n\n                    } else {\n                        var categoryHasElements = false;\n                        this._elements.forEach(function (element) {\n                            if (element.category === category) {\n                                categoryHasElements = true;\n                            }\n                        });\n\n                        // If the category has elements, need to check that the replacement id is valid\n                        if (categoryHasElements) {\n                            var replacementValid = replacementCategory && this._categories.indexOf(replacementCategory) !== -1 && replacementCategory !== category;\n                            if (!replacementValid) {\n                                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Invalid replacement category', this.id);\n                            }\n                        }\n                    }\n\n                    // Remove the category first, so when setting the replacement category we don't trigger an error\n                    doRemoveCategory();\n\n                    // Move the elements to a different category after deleting it\n                    this._elements.forEach(function (element) {\n                        if (element.category === category) {\n                            element.category = replacementCategory;\n                        }\n                    });\n                }\n\n            } else {\n                throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Category not found', this.id);\n            }\n\n        }, this);\n    };\n\n    /**\n     * **UNSUPPORTED** Reorder a category - move it so it's immediately after another category.\n     *\n     * @param {AdobeLibraryCategory} category The category to move.\n     * @param {AdobeLibraryCategory} afterCategory The category to move `category` after.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     * @ignore\n     */\n    AdobeLibraryComposite.prototype.moveCategoryAfter = function (category, afterCategory) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            this._ensureOrder('_categories', afterCategory, category);\n        }, this);\n    };\n\n    /**\n     * **UNSUPPORTED** Reorder a category - move it so it's immediately before another category.\n     *\n     * @param {AdobeLibraryCategory} category The category to move.\n     * @param {AdobeLibraryCategory} beforeCategory The category to move `category` before.\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     * @ignore\n     */\n    AdobeLibraryComposite.prototype.moveCategoryBefore = function (category, beforeCategory) {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        return this._wrapOperation(function () {\n            this._ensureOrder('_categories', category, beforeCategory, true);\n        }, this);\n    };\n\n\n    /**\n        Transactions\n    **/\n\n    /**\n     * Start a transactional operation on the library. This allows you to make multiple updates to the\n     * library (or any of its elements), without committing each change to disk (and syncing to the server).\n     * A common example is adding an element - you need to add the element, then add a number of representations,\n     * but you don't want to commit the changes until after all the representations have been added.\n     * Transactions can be nested, and no changes will be committed to disk or pushed to the server until the\n     * outer-most transaction has ended.\n     *\n     * Important: you **must** remember to call {@link AdobeLibraryComposite#endOperation} when you've finished\n     * making your changes to the library. If you don't the library will remain inside a transaction forever, and\n     * no subsequent changes will ever be saved to disk, or pushed to the server.\n     *\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.beginOperation = function () {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        this._transactionCount++;\n    };\n\n    /**\n     * End a transactional operation on the library, started by {@link AdobeLibraryComposite#beginOperation}.\n     * This will cause a commit if it's the end of the last transaction (it's ok to have nested transactions).\n     *\n     * Note: be very careful when using asynchronous APIs, e.g. {@link AdobeLibraryRepresentation#updateContentFromPath}.\n     * You need to call `endOperation` in the callback of the asynchronous method, not immediately after calling it,\n     * otherwise you might commit and sync a library that is only partially updated.\n     *\n     * @throws {AdobeLibraryError.DELETED_LOCALLY|AdobeLibraryError.NOT_ALLOWED}\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.endOperation = function () {\n        AdobeLibraryManifestUtils.checkDeletedState(this);\n\n        if (!this.writable) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id);\n        }\n\n        this._transactionCount--;\n        this._commit();\n    };\n\n\n    /**\n        Searching and filtering\n    **/\n\n    /**\n     * Get a filtered array of elements from the library, matching the specified type. To use this, you must have\n     * specified the `ELEMENT_TYPE_FILTERS` option when calling {@link CCLibraries.configure}. You can only filter by\n     * the types you specify in the `ELEMENT_TYPE_FILTERS` array. You can also call this method with `'*'` as the\n     * type parameter, which will return all elements that don't match any of the types in the `ELEMENT_TYPE_FILTERS` array.\n     *\n     * Note that the array we return is modified in-place as the library is modified, so you don't need to\n     * call this function again to get a new filtered array, after modifying the library (e.g. adding a new element).\n     *\n     * @param {String} type The element type to filter by (or `'*'`).\n     * @returns {Array.<AdobeLibraryElement>} An array containing all elements in the library that have the given type.\n     * @throws {AdobeLibraryError.INVALID_PARAMETER}\n     *\n     * @memberof AdobeLibraryComposite\n     */\n    AdobeLibraryComposite.prototype.getFilteredElements = function (type, category) {\n        if (!type) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'must specify element type to filter', this.id);\n        }\n        if (type !== '*' && AdobeLibraryConfig.ELEMENT_TYPE_FILTERS.indexOf(type) === -1) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'must specify \\'*\\', or an element type in config.ELEMENT_TYPE_FILTERS', this.id);\n        }\n        var key = this._getFilterKey(type, category);\n        this._filterCache[key] = this._filterCache[key] || [];\n        return this._filterCache[key];\n    };\n\n\n    /**\n        Syncing\n    **/\n\n    /**\n     * Manually sync just this library with Creative Cloud. This both pulls down any changes from the server, and pushes\n     * local changes if the library is modified.\n     *\n     * Note: you don't need to call `sync` in order to push changes - the library is automatically pushed to the server whenever\n     * it's modified.\n     *\n     * Calling this on a deleted library will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Function} callback This gets called when the sync completes. Note that no parameters are passed back:\n     * you need to check the state of the library collection (e.g. {@link AdobeLibraryCollection#syncState} to see what happened.\n     *\n     * @memberof AdobeLibraryComposite\n     * @instance\n     * @see {@link AdobeLibraryCollection#sync}\n     */\n    AdobeLibraryComposite.prototype.sync = function (callback) {\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        this._sync(false, callback);\n    };\n\n    /**\n     * Re-upload the library if it was deleted from Creative Cloud. This only does anything if\n     * {@link AdobeLibraryComposite#deletedFromServer} is `true`. You need to have the library data stored locally (including all\n     * the components) to re-upload it.\n     *\n     * If the user owns the deleted library (i.e. it's an uncollaborated library, or an outgoing collaboration), then the\n     * library gets re-uploaded with the same id. If it's an incoming collaboration that we've been removed from (i.e. owned by\n     * another user), then the library gets re-uploaded with a different id, to avoid conflicts if the user tries to share that\n     * library again.\n     *\n     * This requires a filesystem (otherwise, you'll get a {@link AdobeLibraryError.REQUIRES_FILESYSTEM} error).\n     *\n     * Calling this on a deleted library will result in a {@link AdobeLibraryError.DELETED_LOCALLY} error.\n     *\n     * @param {Function} callback This gets called when the re-upload completes.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @memberof AdobeLibraryComposite\n     * @instance\n     * @see {@link AdobeLibraryCollection#sync}\n     */\n    AdobeLibraryComposite.prototype.rebindToServer = function (callback) {\n\n        // Re-uploading requires a file system\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'rebindToServer requires a filesystem', this.id));\n            return;\n        }\n\n        if (AdobeLibraryManifestUtils.checkDeletedState(this, callback)) { return; }\n\n        // NOTE: We're disabling re-uploads of read-only libraries here. Maybe this should be allowed, but it has more subtle\n        // issues we would need to address; e.g. if it's a public library, we'd have to move it out of the public collection and into\n        // a private collection.\n        if (!this.writable) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_ALLOWED, 'you do not have write access to this library', this.id));\n            return;\n        }\n\n        if (!this._deletedFromServer) {\n            // Already bound to server, so nothing to do\n            callback(null);\n            return;\n        }\n\n        this._doRebindToServer(callback);\n    };\n\n    /**\n     * Find an element by id, in the library.\n     *\n     * @param {Uuid} id An element id.\n     * @returns {AdobeLibraryElement} The element with the given id, or `undefined` if no such element exists.\n     *\n     * @memberof AdobeLibraryComposite\n     * @instance\n     */\n    AdobeLibraryComposite.prototype.getElementById = function (id) {\n        var foundElement;\n\n        this.elements.forEach(function (element) {\n            if (element.id === id) {\n                foundElement = element;\n            }\n        });\n\n        return foundElement;\n    };\n\n    return AdobeLibraryComposite;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, localStorage, GLOBAL, nodeRequire */\n\n/**\n * @class AdobeLibrarySyncManager\n * @classdesc\n * Managing pushing/pulling of composites, querying the sync group, and other server operations\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibrarySyncManager',['require','exports','module','./components/dcx-js/src/AdobeStorageSession','./components/dcx-js/src/AdobeDCXCompositeXfer','./components/dcx-js/src/AdobeDCXUtil','./components/dcx-js/src/AdobeDCXError','./AdobeLibraryConfig','./AdobeLibraryError','./AdobeLibraryServices','./utils/AdobeLibrarySyncUtils','./utils/AdobeLibraryErrorUtils','./utils/AdobeLibraryFileUtils','./utils/AdobeLibraryManifestUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeStorageSession = require('./components/dcx-js/src/AdobeStorageSession');\n    var AdobeDCXCompositeXfer = require('./components/dcx-js/src/AdobeDCXCompositeXfer');\n    var AdobeDCXUtil = require('./components/dcx-js/src/AdobeDCXUtil');\n    var AdobeDCXError = require('./components/dcx-js/src/AdobeDCXError');\n\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n\n    var AdobeLibrarySyncUtils = require('./utils/AdobeLibrarySyncUtils');\n    var AdobeLibraryErrorUtils = require('./utils/AdobeLibraryErrorUtils');\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n\n    // Constructor\n    // Note: this is for internal use by the design library\n    function AdobeLibrarySyncManager(collection, options) {\n\n        this._collection = collection;\n\n        // Configuration options (these can't be changed once started)\n        this._isPublic = options.IS_PUBLIC;\n        this._storageHost = options.STORAGE_HOSTNAME;\n        this._storageAssetsPath = this._isPublic ? AdobeLibraryConfig.PUBLIC_STORAGE_ASSETS_PATH : AdobeLibraryConfig.STORAGE_ASSETS_PATH;\n        this._apiKey = AdobeLibraryConfig.STORAGE_API_KEY;\n        this._syncGroup = this._isPublic ? AdobeLibraryConfig.PUBLIC_LIBRARY_SYNC_GROUP : AdobeLibraryConfig.LIBRARY_SYNC_GROUP;\n        this._XHR = options.XHR;\n\n        // Setup getAccessToken\n        this._getAccessToken = options.getAccessToken;\n\n        // Create storage sessions - we have a separate one for renditions, so they don't block while we're downloading libraries\n        this._httpServices = [];\n        this._storageService = this._createStorageSession();\n        this._renditionStorageService = this._createStorageSession();\n\n        // We keep a mapping from endpoint to temporary storage service, so we can reuse them\n        this._temporaryStorageServices = {};\n\n        // Internal state:\n        this._lastSyncGroupState = {};\n        this._hasSetAuthToken = false;\n        this._authToken = undefined;\n        this._inProgressSyncMap = {};\n\n        // We have to immediately get the auth token, because DCX doesn't call us any more, if it doesn't have an auth token, before the first call\n        if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE && !this._isPublic) {\n            this._updateAuthToken();\n        }\n    }\n\n    AdobeLibrarySyncManager.prototype._getNodeTunnelOptions = function () {\n        // Support a tunnel if there is one. This involves setting up additional node.js options\n        if (this.NODE_TUNNEL_OPTIONS === undefined) {\n            this.NODE_TUNNEL_OPTIONS = {};\n            var requireType = typeof nodeRequire; // Avoid JSLint warning\n            var processType = typeof process;\n            /* istanbul ignore if */ // Only for testing, so we don't need code coverage\n            if (requireType !== 'undefined' && processType !== 'undefined' && process.env) {\n                try {\n                    var tunnel = nodeRequire('tunnel');\n                    if (process.env.CCLIBRARIES_CHARLES_PORT) {\n                        this.NODE_TUNNEL_OPTIONS.agent = tunnel.httpsOverHttp({\n                            proxy: {\n                                host: 'localhost',\n                                port: process.env.CCLIBRARIES_CHARLES_PORT\n                            }\n                        });\n\n                        // In node.js 0.10.x and later, rejectUnauthorized is true by default (before that, it was false by default)\n                        // So.. we need to explicitly turn it off to support Charles\n                        this.NODE_TUNNEL_OPTIONS.rejectUnauthorized = false;\n\n                        AdobeLibraryServices.log('Tunneling through Charles proxy: http://localhost:' + process.env.CCLIBRARIES_CHARLES_PORT);\n                    } else if (process.env.CCLIBRARIES_HTTPS_PROXY) {\n                        this.NODE_TUNNEL_OPTIONS.agent = tunnel.httpsOverHttp({\n                            proxy: {\n                                host: process.env.CCLIBRARIES_HTTPS_PROXY,\n                                port: process.env.CCLIBRARIES_HTTPS_PROXY_PORT,\n                                proxyAuth: AdobeLibraryConfig.PROXY_AUTH\n                            }\n                        });\n\n                        AdobeLibraryServices.log('Tunneling through system proxy: ' + process.env.CCLIBRARIES_HTTPS_PROXY + ':' + process.env.CCLIBRARIES_HTTPS_PROXY_PORT);\n                    }\n                } catch (e) {\n                    AdobeLibraryServices.log('Unable to load tunnel module.');\n                }\n            }\n        }\n\n        return this.NODE_TUNNEL_OPTIONS;\n    };\n\n    // Return common headers to send on every request (e.g. for User-Agent)\n    AdobeLibrarySyncManager.prototype._getCommonRequestHeaders = function () {\n        var headers = {};\n\n        if (AdobeLibraryConfig.USER_AGENT_HEADER) {\n            headers['User-Agent'] = AdobeLibraryConfig.USER_AGENT_HEADER;\n        }\n\n        return headers;\n    };\n\n    AdobeLibrarySyncManager.prototype._setAuthToken = function (token) {\n        this._hasSetAuthToken = true;\n        this._authToken = token;\n        this._httpServices.forEach(function (httpService) {\n            if (token) {\n                httpService.isActive = true;\n                httpService.setAuthToken(token);\n            } else {\n                httpService.isActive = false;\n            }\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype._updateAuthToken = function (callback) {\n        var that = this;\n\n        this._getAccessToken(function (err, accessToken) {\n            if (!err && accessToken) {\n                that._setAuthToken(accessToken);\n            } else {\n                if (err && err.code === AdobeLibraryError.ACCESS_DENIED) {\n                    that._collection._reportSyncError(err);\n                    that._collection._updateSyncState();\n                }\n\n                // Not logged in\n                that._setAuthToken();\n            }\n\n            if (callback) {\n                callback(null, accessToken);\n            }\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype._getAuthToken = function (callback) {\n        if (this._isPublic) {\n            callback(null, undefined);\n        } else if (this._hasSetAuthToken) {\n            callback(null, this._authToken);\n        } else {\n            this._updateAuthToken(callback);\n        }\n    };\n\n    // Auth handler for getting access token\n    AdobeLibrarySyncManager.prototype._authHandler = function () { //httpSession) {\n        this._updateAuthToken();\n    };\n\n    AdobeLibrarySyncManager.prototype._createStorageSession = function () {\n\n        // Create the HTTP service\n        var httpService;\n        if (this._isPublic) {\n            httpService = AdobeLibraryServices.dcx.createHTTPService();\n        } else {\n            httpService = AdobeLibraryServices.dcx.createHTTPService(this._authHandler.bind(this));\n            this._httpServices.push(httpService);\n        }\n        httpService.setApiKey(this._apiKey);\n        httpService.setTimeout(AdobeLibraryConfig.NETWORK_TIMEOUT);\n        httpService.setAdditionalNodeOptions(this._getNodeTunnelOptions());\n        httpService.setAdditionalHeaders(this._getCommonRequestHeaders());\n\n        // Options for testing/debugging:\n        if (this._XHR) {\n            httpService._forceXhr(this._XHR);\n        }\n\n        return AdobeLibraryServices.dcx.createStorageSession(httpService, this._getStorageHost());\n    };\n\n    // Create a temporary storage session\n    // This is ugly, due to DCX changes that prevent us from using the same storage session to talk to different hosts\n    AdobeLibrarySyncManager.prototype._createTemporaryStorageSession = function (endPoint, isAdobeDomain) {\n\n        var httpService;\n        if (!isAdobeDomain) {\n            httpService = AdobeLibraryServices.dcx.createHTTPService();\n        } else {\n            // Only send the access token and Adobe-specific headers if it's an Adobe domain\n            httpService = AdobeLibraryServices.dcx.createHTTPService(this._authHandler.bind(this));\n            httpService.setApiKey(this._apiKey);\n            httpService.setAdditionalHeaders(this._getCommonRequestHeaders());\n            httpService.setAuthToken(this._authToken);\n\n            this._httpServices.push(httpService);\n        }\n        httpService.setTimeout(AdobeLibraryConfig.NETWORK_TIMEOUT);\n        httpService.setAdditionalNodeOptions(this._getNodeTunnelOptions());\n\n        return AdobeLibraryServices.dcx.createStorageSession(httpService, endPoint);\n    };\n\n    AdobeLibrarySyncManager.prototype._getTemporaryStorageSession = function (url) {\n        var urlItems = AdobeDCXUtil.parseURI(url);\n        var endPoint = urlItems.scheme + '://' + urlItems.authority;\n        var isAdobeDomain = AdobeLibrarySyncUtils.isAdobeDomain(urlItems.authority);\n\n        if (!this._temporaryStorageServices[endPoint]) {\n            this._temporaryStorageServices[endPoint] = this._createTemporaryStorageSession(endPoint, isAdobeDomain);\n        }\n\n        return this._temporaryStorageServices[endPoint];\n    };\n\n    /**\n        Public APIs\n    **/\n\n    AdobeLibrarySyncManager.prototype.getServerComposites = function (callback) {\n        var that = this;\n        var lastEtag = this._lastSyncGroupState.etag;\n\n        this._storageService.getCollection(this.getSyncGroupPath(), lastEtag, function (err, syncGroup, etag, headers) {\n            if (err) {\n                if (err.response && err.response.statusCode === 404) {\n                    // If the sync group doesn't exist, we just return ok - because you don't have any libraries, and we'll create the sync group\n                    // when you create a new library\n                    callback(null, []);\n                } else {\n                    callback(err);\n                }\n                return;\n            }\n\n            if (!syncGroup) {\n                // Nothing changed on the server\n\n                // Check to see if we were given a retry-after header: we need to respect this\n                // If we don't have a retry-after, set MAX_SYNC_INTERVAL to the default throttling\n                var retryAfter = Math.max(AdobeLibraryConfig.DEFAULT_MAX_SYNC_INTERVAL, AdobeLibrarySyncUtils.getRetryAfterHeader(headers) * 1000);\n                AdobeLibraryConfig.MAX_SYNC_INTERVAL = retryAfter;\n\n                callback(null, []);\n                return;\n            }\n\n            // If something did change, reset the MAX_SYNC_INTERVAL too - no need to throttle\n            AdobeLibraryConfig.MAX_SYNC_INTERVAL = AdobeLibraryConfig.DEFAULT_MAX_SYNC_INTERVAL;\n\n            // Etag state - remembered between calls to the sync group\n            var oldCompositeEtags = that._lastSyncGroupState.compositeEtags || {};\n            var newCompositeEtags = {};\n\n            // Construct a map from library id to information about the library\n            var composites = [];\n            var compositeInfo = {};\n\n            // Iterate over composite information from the server\n            var serverComposites = syncGroup.children || [];\n            serverComposites.forEach(function (composite) {\n\n                // We filter out any composites that don't have valid ids - the name of the composite is the id, and this must be a guid.\n                if (!composite || !AdobeLibraryManifestUtils.validateLibraryId(composite.name, false)) {\n                    return;\n                }\n\n                // If the etag didn't change, we know the composite wasn't modified\n                var isUnmodified = composite.etag && oldCompositeEtags[composite.name] === composite.etag;\n\n                composites.push(composite);\n                compositeInfo[composite.name] = {\n                    isUnmodified: isUnmodified,\n                    collaboration: composite.collaboration\n                };\n\n                // Remember the current etag for next time\n                newCompositeEtags[composite.name] = composite.etag;\n            });\n\n            // Store the etag and composites data so next time we pull, we can poll quickly\n            that._lastSyncGroupState = {\n                etag: etag,\n                compositeEtags: newCompositeEtags\n            };\n\n            callback(null, composites, compositeInfo);\n        });\n    };\n\n    // Clear the cache of the last sync group fetch - this forces a new fetch on the next sync\n    AdobeLibrarySyncManager.prototype.clearSyncGroupCache = function () {\n        this._lastSyncGroupState = {};\n    };\n\n    // Do a head on the manifest\n    AdobeLibrarySyncManager.prototype.doHeadRequest = function (composite, callback) {\n        var manifestHref = this._storageService.getCompositeManifestHref(composite);\n        this._storageService.headRequest(manifestHref, callback);\n    };\n\n    AdobeLibrarySyncManager.prototype.hasCompositeChangedOnServer = function (composite, callback) {\n        this.doHeadRequest(composite, function (err, response) {\n            if (err) { callback(true); return; }\n\n            // Compare the etag of the manifest on the server to the local etag\n            var etag = response && response.headers && response.headers.etag;\n            var localEtag = composite.current && composite.current.manifestEtag;\n\n            callback(etag !== localEtag);\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype.downloadRepresentation = function (representation, callback) {\n        // Assumes the representation you pass in is a component\n        var component = representation._dcxComponent;\n        var branch = representation.element.library._dcxBranch;\n        AdobeDCXCompositeXfer.downloadComponents([component], branch, this._storageService, callback);\n    };\n\n\n    /**\n        Pushing and pulling composites\n    **/\n\n    AdobeLibrarySyncManager.prototype.abortPushOrPull = function (id) {\n        if (this._inProgressSyncMap[id]) {\n            // Note: We have to pass an error to the abort call, or else the callback for the push/pull won't get called\n            this._inProgressSyncMap[id].abort(new AdobeLibraryError(AdobeLibraryError.TRANSFER_ABORTED, 'abort push or pull operation'));\n            delete this._inProgressSyncMap[id];\n        }\n    };\n\n    AdobeLibrarySyncManager.prototype.pullComposite = function (composite, collection, callback) {\n        var that = this;\n\n        // For new composites, they don't have an id yet - have to glean it from the href (ugly!)\n        var id = composite.id;\n        if (!id && composite.href) {\n            var parts = composite.href.split('/');\n            id = parts && parts[parts.length - 1];\n        }\n\n        // Note: if you don't have a file system, we do manifest-only by default, since there's nowhere to store the components\n        var manifestOnly = AdobeLibraryConfig.SYNC_POLICY === 'manifestOnly' || !AdobeLibraryServices.hasFileSystem();\n        var pullFunction = manifestOnly ? 'pullCompositeManifestOnly' : 'pullComposite';\n\n        AdobeLibraryServices.log('Started pulling: ' + id + (manifestOnly ? ' (manifest only)' : ''));\n        var startTime = new Date().valueOf();\n        collection._updateProgress(id);\n        this._inProgressSyncMap[id] = AdobeDCXCompositeXfer[pullFunction](composite, this._storageService, function (err, branch) {\n            var duration = new Date().valueOf() - startTime;\n            AdobeLibraryServices.log('Finished pulling: ' + id + (err ? ' [' + err.code + ']' : '') + ' duration=' + duration);\n            delete that._inProgressSyncMap[id];\n            collection._updateProgress(id);\n\n            if (err && err.code === AdobeDCXError.COMPONENT_DOWNLOAD_ERROR) {\n                // Handle incomplete pull - we should remove any failed components\n\n                // But first, we check to make sure the library still exists on the server\n                that.doHeadRequest(composite, function (headErr, headResponse) {\n                    var libraryStillOnServer = !headErr && headResponse && headResponse.statusCode === 200;\n\n                    // Only remove the missing components if we're certain the composite still exists\n                    // Otherwise, we could bring it back from the dead, and necromancy ain't no joking matter!\n                    if (libraryStillOnServer) {\n                        var fixedBranch = AdobeLibraryManifestUtils.removeMissingComponents(err.pulledBranch, err.failedComponents);\n                        if (fixedBranch) {\n                            // Don't treat it as an error, so we can continue\n                            callback(null, fixedBranch);\n                            return;\n                        }\n                    }\n\n                    // Treat it as an error - this means we'll retry the pull again later (if the library was deleted, we'll discover it then!)\n                    callback(err, branch);\n                });\n\n                return;\n            }\n\n            if (err && err.code === AdobeLibraryError.TRANSFER_ABORTED) {\n                callback(null, undefined);\n                return;\n            }\n\n            callback(err, branch);\n        });\n\n        var pullContext = this._inProgressSyncMap[id];\n        pullContext.onProgress = function (bytesLoaded, bytesTotal) {\n            if (bytesTotal !== 0) {\n                // Only update progress if we have some meaningful numbers\n                collection._updateProgress(id, bytesLoaded, bytesTotal);\n            }\n        };\n    };\n\n    // Pass in overwriteExisting = true, if you want to delete a composite (since it may not be bound)\n    AdobeLibrarySyncManager.prototype.pushComposite = function (composite, collection, overwriteExisting, callback) {\n        var that = this;\n        var id = composite.id;\n\n        AdobeLibraryServices.log('Started pushing: ' + id);\n        var startTime = new Date().valueOf();\n        collection._updateProgress(id);\n        this._inProgressSyncMap[id] = AdobeDCXCompositeXfer.pushComposite(composite, overwriteExisting, this._storageService, function (err) {\n            var duration = new Date().valueOf() - startTime;\n            AdobeLibraryServices.log('Finished pushing: ' + id + (err ? ' [' + err.code + ']' : '') + ' duration=' + duration);\n            delete that._inProgressSyncMap[id];\n            collection._updateProgress(id);\n            callback(err);\n        });\n\n        var pushContext = this._inProgressSyncMap[id];\n        pushContext.onProgress = function (bytesLoaded, bytesTotal) {\n            if (bytesTotal !== 0) {\n                // Only update progress if we have some meaningful numbers\n                collection._updateProgress(id, bytesLoaded, bytesTotal);\n            }\n        };\n    };\n\n    AdobeLibrarySyncManager.prototype.pushDeletedComposite = function (composite, collection, collaboration, forceDelete, callback) {\n        var that = this;\n\n        if (collaboration === 'incoming') {\n            // For incoming collaborations, we need to bypass the push, and just delete the collection from the server\n            AdobeLibraryServices.log('Deleting incoming collaboration without pushing: ' + composite.id);\n            this._storageService.deleteCompositeDirectory(composite, callback);\n\n        } else {\n            AdobeLibraryServices.log('Pushing deleted composite: ' + composite.id);\n            this.pushComposite(composite, collection, forceDelete, function (err) {\n                if (err) {\n                    // Here, we handle a couple of cases:\n                    // 1) The delete failed initially, but somebody else deleted before we got chance to retry.\n                    // 2) The app shut down or crashed in between the delete being called, and succeeding. So, next time we retry, the composite is already deleted.\n\n                    // If the put fails because the manifest was deleted, just continue with the delete directory call\n                    if (err.code === AdobeDCXError.UNEXPECTED_RESPONSE && err.response && err.response.statusCode === 404) {\n                        that._storageService.deleteCompositeDirectory(composite, callback);\n                        return;\n                    }\n\n                    // Check for an update conflict, since this can also indicate it was deleted already\n                    if (err.code === AdobeDCXError.UPDATE_CONFLICT) {\n                        // Need to do a pull to determine it really was deleted\n                        var updateConflictError = err;\n                        that.pullComposite(composite, collection, function (err) {\n                            if (err && err.code === AdobeDCXError.NO_COMPOSITE) {\n                                // Manifest was really deleted, so continue the job and make sure the directory is deleted\n                                that._storageService.deleteCompositeDirectory(composite, callback);\n                                return;\n                            }\n\n                            if (err && err.code === AdobeDCXError.DELETED_COMPOSITE) {\n                                // pullComposite already ensures that the directory was deleted in this case, so we can just return a success\n                                callback(null);\n                                return;\n                            }\n\n                            // If a genuine error, return it\n                            if (err) {\n                                callback(err);\n                                return;\n                            }\n\n                            // Otherwise, there really was a conflict\n                            callback(updateConflictError);\n                        });\n                        return;\n                    }\n                }\n\n                // Either no error, or a genuine error (so we need to retry the delete again, later)\n                callback(err);\n            });\n        }\n    };\n\n    AdobeLibrarySyncManager.prototype._getStorageHost = function () {\n        return 'https://' + this._storageHost;\n    };\n\n    AdobeLibrarySyncManager.prototype._getStorageRoot = function () {\n        return this._getStorageHost() + this._storageAssetsPath;\n    };\n\n    AdobeLibrarySyncManager.prototype.getSyncGroupPath = function () {\n        return AdobeDCXUtil.appendPathElements(this._getStorageRoot(), this._syncGroup);\n    };\n\n    AdobeLibrarySyncManager.prototype.getCompositePath = function (compositeId) {\n        return AdobeDCXUtil.appendPathElements(this._getStorageRoot(), this._syncGroup, compositeId);\n    };\n\n    AdobeLibrarySyncManager.prototype.getComponentPath = function (compositeId, componentId) {\n        return AdobeDCXUtil.appendPathElements(this._getStorageRoot(), this._syncGroup, compositeId, componentId);\n    };\n\n\n    // For generating renditions using the storage service\n    // See: https://sdk.ccstorage.adobe.io/sdks/ccstorage/v1/assets/render_assets_file\n    AdobeLibrarySyncManager.prototype._getSharedCloudRenditionUrl = function (representation, size, includeQueryParameters, callback) {\n\n        if (!representation._dcxComponent) {\n            callback('representation must be a component to generate a rendition');\n            return;\n        }\n\n        var url = this.getComponentPath(representation._element._library.id, representation.id) + '/:rendition';\n        url += ';size=' + (size || 'full');\n        if (representation._dcxComponent.version !== undefined) {\n            url += ';version=' + representation._dcxComponent.version;\n        }\n\n        if (includeQueryParameters) {\n            var apiKey = this._apiKey;\n            this._getAuthToken(function (err, token) {\n                url += '?accept=image/png&api_key=' + apiKey + (token ? '&user_token=' + token : '');\n                callback(null, url);\n            });\n            return;\n        }\n\n        callback(null, url);\n    };\n\n    // Fetches the rendition from the storage service, but with retry logic\n    AdobeLibrarySyncManager.prototype._getAssetAsType = function (representation, url, tempDir, headers, callback, numRetries) {\n        var that = this;\n        numRetries = numRetries || 0;\n\n        var retry = function () {\n            that._getAssetAsType(representation, url, tempDir, headers, callback, numRetries);\n        };\n\n        if (numRetries > 0 && representation.element.library.syncState === 'uploading') {\n            // We're still syncing, so wait before trying again.\n            // Don't increment number of retries\n            setTimeout(retry, AdobeLibraryConfig.RENDITION_RETRY_INTERVAL);\n            return;\n        }\n\n        // Generate a fresh tempFilePath for every retry\n        var tempFilePath = tempDir + AdobeLibraryServices.getPathSeparator() + AdobeLibraryServices.uuid() + '.png';\n        var responseType = new AdobeStorageSession.FileContent(tempFilePath);\n        this._renditionStorageService.getAssetAsType(url, responseType, headers, function (err) {\n\n            // Check to see if we were given a retry-after header: we need to respect this\n            // If we don't have a retry-after, set MAX_SYNC_INTERVAL to the default throttling\n            var responseHeaders = err && err.response && err.response.headers;\n            var retryAfter = AdobeLibrarySyncUtils.getRetryAfterHeader(responseHeaders) * 1000;\n            AdobeLibraryConfig.RENDITION_RETRY_INTERVAL = Math.max(AdobeLibraryConfig.DEFAULT_RENDITION_RETRY_INTERVAL, retryAfter);\n            AdobeLibraryConfig.RENDITION_404_BACKOFF = Math.max(AdobeLibraryConfig.DEFAULT_RENDITION_404_BACKOFF, retryAfter);\n\n            if (AdobeLibraryErrorUtils.getErrorStatusCode(err) === 404) {\n\n                // Retry if we're within the retry limit\n                if (numRetries < AdobeLibraryConfig.RENDITION_MAX_RETRIES) {\n                    AdobeLibraryServices.log('404 fetching rendition: retrying');\n\n                    numRetries++;\n                    setTimeout(retry, AdobeLibraryConfig.RENDITION_RETRY_INTERVAL);\n                    return;\n                }\n\n                // Otherwise, we let the error fall through\n                AdobeLibraryServices.log('404 fetching rendition: reached maximum retries');\n                AdobeLibraryServices.log('Backing off rendition fetch of ' + representation.id + ' for ' + AdobeLibraryConfig.RENDITION_404_BACKOFF + 'ms');\n\n                // Mark the representation so we know not to retry\n                representation._lastRendition404 = new Date().valueOf();\n            }\n\n            callback(err, tempFilePath);\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype.getSharedCloudRenditionUrl = function (representation, size, callback) {\n        var includeQueryParameters = AdobeLibraryConfig.SHARED_LOCAL_STORAGE ? false : true;\n        this._getSharedCloudRenditionUrl(representation, size, includeQueryParameters, callback);\n    };\n\n    AdobeLibrarySyncManager.prototype.getSharedCloudRendition = function (representation, size, callback) {\n        var that = this;\n\n        // If the library was deleted from the server, don't try to fetch the rendition at all!\n        if (representation.element.library.deletedFromServer) {\n            AdobeLibraryServices.log('Error: Trying to fetch rendition from deleted library.');\n            callback('Error: library deleted');\n            return;\n        }\n\n        // If the last time we fetched the rendition, it was a 404, we don't keep on trying to re-fetch\n        var currentTime = new Date().valueOf();\n        var timeSinceLast404 = currentTime - (representation._lastRendition404 || 0);\n        if (timeSinceLast404 < AdobeLibraryConfig.RENDITION_404_BACKOFF) {\n            callback('Error: got 404 on last rendition attempt - backing off');\n            return;\n        }\n\n        this._getSharedCloudRenditionUrl(representation, size, false, function (err, url) {\n            if (err) { callback(err); return; }\n\n            var headers = {\n                'Accept': 'image/png'\n            };\n\n            var tempDir = representation.element.library.collection._getTempDir();\n            AdobeLibraryFileUtils.ensurePathExists(tempDir, function (err) {\n                if (err) { callback(err); return; }\n\n                // This downloads the file to the specified directory, and returns the tempFilePath in the callback\n                that._getAssetAsType(representation, url, tempDir, headers, callback);\n            });\n\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype.getSharedCloudContentURL = function (representation) {\n        return this._storageService.getComponentHref(representation._dcxComponent, representation._dcxComponent.version);\n    };\n\n    AdobeLibrarySyncManager.prototype.appendAccessTokenToURL = function (url, callback) {\n        if (!url) {\n            callback(null, undefined);\n            return;\n        }\n\n        var apiKey = this._apiKey;\n        this._getAuthToken(function (err, token) {\n            url += '?api_key=' + apiKey + (token ? '&user_token=' + token : '');\n            callback(null, url);\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype.getSharedCloudContent = function (representation, encoding, callback) {\n        var url = this._storageService.getComponentHref(representation._dcxComponent, representation._dcxComponent.version);\n        var headers = {};\n\n        this._storageService.getAssetAsType(url, encoding, headers, function (err, content) {\n            if (err) { callback(err); return; }\n\n            callback(null, content);\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype.getAssetFromURL = function (url, headers, tempDir, callback, numRetries) {\n        var that = this;\n\n        AdobeLibraryServices.log('getAssetFromURL: ' + url);\n\n        // Due to DCX changes, we need to create a new storage service for the download\n        var storageService = this._getTemporaryStorageSession(url);\n\n        // Write the download to a temp file\n        var tempFilePath = tempDir + AdobeLibraryServices.getPathSeparator() + AdobeLibraryServices.uuid();\n        var responseType = new AdobeStorageSession.FileContent(tempFilePath);\n\n        numRetries = numRetries || 0;\n        headers = headers || {};\n\n        AdobeLibraryFileUtils.ensurePathExists(tempDir, function (err) {\n            if (err) { callback(err); return; }\n\n            storageService.getAssetAsType(url, responseType, headers, function (err, buffer, etag, response) {\n\n                // Test for a retry header\n                if (err && err.code === AdobeDCXError.UNEXPECTED_RESPONSE) {\n                    var errorStatus = err.response && err.response.statusCode;\n                    if (errorStatus === 301 || errorStatus === 302 || errorStatus === 303 || errorStatus === 307) {\n                        var newURL = AdobeLibrarySyncUtils.getLocationHeader(err.response.headers);\n                        // Note: we preserve custom headers on the redirect, but Authorization headers are only sent based on the domain.\n\n                        if (newURL && numRetries < 5) {\n                            that.getAssetFromURL(newURL, headers, tempDir, callback, numRetries + 1);\n                            return;\n                        }\n                    }\n                }\n\n                callback(err, tempFilePath, etag, response);\n            });\n        });\n    };\n\n    AdobeLibrarySyncManager.prototype.doHeadRequestOfURL = function (url, callback) {\n        var storageService = this._getTemporaryStorageSession(url);\n        storageService.headRequest(url, callback);\n    };\n\n    // Update a new composite so it's ready to be pushed\n    AdobeLibrarySyncManager.prototype.prepareCompositeForPush = function (composite) {\n        composite.href = this.getCompositePath(composite.id);\n    };\n\n    // Call this if we were logged out (and so cancelled requests), and subsequently were logged in again\n    AdobeLibrarySyncManager.prototype.updateAccessToken = function (accessToken) {\n        this._setAuthToken(accessToken);\n    };\n\n    // Determine if we're logged in at the DCX layer (i.e. we haven't passed in an access token of undefined)\n    AdobeLibrarySyncManager.prototype.isLoggedIn = function () {\n        return this._isPublic || this._httpServices[0].isActive;\n    };\n\n    AdobeLibrarySyncManager.prototype.uploadNewComponent = function (data, fileName, representation, callback) {\n        var composite = representation._element._library._dcxComposite;\n\n        AdobeDCXCompositeXfer.uploadNewComponent(data, representation.type, composite, representation.id, this._storageService, function (err, uploadResults) {\n            if (err) { callback(err); return; }\n\n            var dotIndex = fileName ? fileName.lastIndexOf('.') : -1;\n            var extension = dotIndex !== -1 && fileName.substr(dotIndex + 1).toLowerCase();\n            var dcxPath = representation.id + '.' + extension;\n\n            var component = composite.current.addComponentWithUploadResults(fileName, representation.relationship, dcxPath, representation._element._dcxNode, uploadResults);\n            callback(null, component);\n        });\n    };\n\n    return AdobeLibrarySyncManager;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define */\n\n/**\n * @class AdobeLibraryCollection\n * @classdesc\n * A collection of Creative Cloud Libraries. Manages the following:\n *\n * * Loading libraries from disk (if the API has access to a filesystem).\n * * Syncing libraries to/from Creative Cloud, including polling if enabled in the {@link CCLibraries.configure} options.\n * * Creating and deleting libraries.\n *\n * @description\n * This class has a private constructor. The only way to obtain an instance of AdobeLibraryCollection\n * is by calling {@link CCLibraries.loadLibraryCollection}.\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryCollection',['require','exports','module','./components/dcx-js/src/AdobeDCXError','./AdobeLibraryComposite','./AdobeLibraryServices','./AdobeLibraryConfig','./AdobeLibrarySyncManager','./AdobeLibraryAnalytics','./AdobeLibraryError','./utils/AdobeLibraryAsyncJoin','./utils/AdobeLibraryFileUtils','./utils/AdobeLibraryManifestUtils','./utils/AdobeLibraryErrorUtils','./utils/AdobeLibrarySyncUtils','./utils/AdobeLibraryRenditionUtils','./utils/AdobeLibraryListenerManager'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeDCXError = require('./components/dcx-js/src/AdobeDCXError');\n\n    var AdobeLibraryComposite = require('./AdobeLibraryComposite');\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibrarySyncManager = require('./AdobeLibrarySyncManager');\n    var AdobeLibraryAnalytics = require('./AdobeLibraryAnalytics');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n\n    var AdobeLibraryAsyncJoin = require('./utils/AdobeLibraryAsyncJoin');\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n    var AdobeLibraryErrorUtils = require('./utils/AdobeLibraryErrorUtils');\n    var AdobeLibrarySyncUtils = require('./utils/AdobeLibrarySyncUtils');\n    var AdobeLibraryRenditionUtils = require('./utils/AdobeLibraryRenditionUtils');\n    var AdobeLibraryListenerManager = require('./utils/AdobeLibraryListenerManager');\n\n    // Private constructor\n    function AdobeLibraryCollection(options) {\n        // Configuration: these can't be changed once started\n        this._rootDir = AdobeLibraryConfig.ROOT_DIR;\n        this._userId = options.USER_ID;\n        this._cloudId = options.CLOUD_ID;\n        this._cloudInfo = options.CLOUD_INFO || {};\n\n        this._syncManager = new AdobeLibrarySyncManager(this, options);\n\n        this._libraries = [];\n        this._syncState = 'syncing'; // This is a computed value, based on the top level state and that of all the libraries\n        this._syncProgressMap = {};\n        this._initialSyncInProgress = false;\n        this._syncErrors = [];\n        this._listenerManager = new AdobeLibraryListenerManager(['change', 'deepchange', 'sync', 'commitError']);\n\n        // Internal data:\n        this._libraryIdMap = {};\n        this._pendingDeletes = [];\n        this._loaded = false;\n        this._syncing = false;\n        this._lastSyncTime = 0;\n        this._pendingSyncs = []; // Only used if we don't have a poll timer running\n        this._backoffTicks = 0;\n        this._numBackoffs = 0;\n        this._numRetries = 0;\n    }\n\n    // Private: remove all change listeners\n    AdobeLibraryCollection.prototype._removeAllListeners = function () {\n        this._listenerManager.removeAll();\n        this._libraries.forEach(function (library) {\n            library._removeAllListeners();\n        });\n    };\n\n    // Private: notify change listeners\n    AdobeLibraryCollection.prototype._notifyChange = function (collectionOnly) {\n        this._listenerManager.notify('deepchange');\n        if (collectionOnly) {\n            this._listenerManager.notify('change');\n        }\n    };\n\n    // Private Load existing libraries from disk\n    AdobeLibraryCollection.prototype._load = function (callback) {\n\n        if (this._loaded) {\n            // Don't allow you to load more than once\n            callback(null);\n            return;\n        }\n\n        this._loaded = true;\n        var that = this;\n\n        AdobeLibraryFileUtils.readLibraryDirectory(this, function (err, libraries) {\n            // Note: if there's an error because the root directory doesn't exist, we ignore it\n            if (err || !libraries) { callback(null); return; }\n\n            function loadLibrary(libraryId, finishedLoadingLibrary) {\n                // Check it's a valid id. (unless it's a public library, because the storage service generates ids in some other form,\n                // for a reason known only to the Norse god of chaos).\n                if (AdobeLibraryManifestUtils.validateLibraryId(libraryId, that.isPublic)) {\n                    var path = that._getCompositeDir(libraryId);\n\n                    AdobeLibraryServices.dcx.newCompositeFromLocalStorage(path, function (err, dcxComposite) {\n                        if (err) {\n                            AdobeLibraryServices.log('Load error: DCX error loading composite for ' + libraryId);\n                            finishedLoadingLibrary(AdobeLibraryErrorUtils.getCommitError(err, libraryId));\n                            return;\n                        }\n\n                        if (!dcxComposite || !dcxComposite.current) {\n                            // Don't treat this as an error - it's a folder without a manifest in it, so just skip over it\n                            // However, we need to delete it from disk so it doesn't bother us again (e.g. it could be a\n                            // partially synced library that was deleted from the server).\n                            AdobeLibraryServices.log('Load error: composite/branch not loaded for ' + libraryId);\n                            AdobeLibraryFileUtils.deleteLibraryFromDisk(that, libraryId);\n                            finishedLoadingLibrary(null);\n                            return;\n                        }\n\n                        // TOFIX: what if a newer version of the library? Should probably have a special error code\n                        if (!AdobeLibraryManifestUtils.validateLibrary(dcxComposite)) {\n                            // Don't treat this as an error - it's a library we don't understand, so just skip over it\n                            AdobeLibraryServices.log('Load error: failed validation for ' + libraryId);\n                            finishedLoadingLibrary(null);\n                            return;\n                        }\n\n                        // Check that the library id matches the folder on disk - remove it if it doesn't\n                        if (!that.isPublic && dcxComposite.id !== libraryId) {\n                            // It's an invalid library, so don't try to load it\n                            AdobeLibraryServices.log('Load error: library id ' + dcxComposite.id + 'doesn\\'t match folder on disk ' + libraryId);\n                            finishedLoadingLibrary(null);\n                            return;\n                        }\n\n                        var library = new AdobeLibraryComposite(that, dcxComposite);\n\n                        if (that.isPublic) {\n                            // Fake out the library id to be the public id;\n                            library._publicId = libraryId;\n                            library._writable = false;\n                        }\n\n                        if (dcxComposite.current.compositeState === 'pendingDelete') {\n                            that._pendingDeletes.push(library);\n                            finishedLoadingLibrary(null);\n\n                        } else {\n                            that._libraries.push(library);\n                            that._libraryIdMap[library.id] = library;\n\n                            library._loadRenditionCache(finishedLoadingLibrary);\n                        }\n                    });\n\n                } else {\n                    // Don't treat this as an error - just skip over any additional files that aren't libraries (e.g. .DS_Store, etc)\n                    finishedLoadingLibrary(null);\n                }\n            }\n\n            var asyncJoin = new AdobeLibraryAsyncJoin();\n            libraries.forEach(function (libraryId) {\n                asyncJoin.addOperation(loadLibrary, [libraryId]);\n            });\n\n            asyncJoin.run(function (err) {\n                // Don't pass on the error, since it's handled by the error callback\n                AdobeLibraryServices.log('Loaded ' + that._libraries.length + ' libraries and ' + that._pendingDeletes.length + ' pending deletes');\n                callback(null);\n\n            }, function (err) {\n                that._reportCommitError(err);\n            });\n        });\n\n    };\n\n    AdobeLibraryCollection.prototype._removeFromPendingDeletes = function (library) {\n        var index = this._pendingDeletes.indexOf(library);\n        if (index !== -1) {\n            this._pendingDeletes.splice(index, 1);\n        }\n    };\n\n    // Deal with any pending deletes\n    AdobeLibraryCollection.prototype._handlePendingDeletes = function (callback) {\n        var that = this;\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n\n        this._pendingDeletes.forEach(function (library) {\n\n            // Schedule an operation for deleting the library\n            asyncJoin.addOperation(function (finishOperation) {\n                // Try again to delete from server, and from disk\n                library._deleteFromServer(false, function (err) {\n                    if (err && err.code === AdobeDCXError.UPDATE_CONFLICT) {\n                        // If we failed to push, due to a conflict, we need to restore the library\n                        // Remove from the pending deletes, and add back to the libraries array\n                        that._removeFromPendingDeletes(library);\n                        that._libraries.push(library);\n                        that._libraryIdMap[library.id] = library;\n                        library._markDeletedLocally(false);\n\n                        that._updateSyncState();\n                        that._notifyChange(true);\n\n                        finishOperation(null, true);\n                        return;\n                    }\n\n                    // Genuine error - we need to retry again later\n                    if (err) {\n                        finishOperation(err);\n                        return;\n                    }\n\n                    // Since the library was successfully deleted, we can remove it from the list of pending deletes\n                    that._removeFromPendingDeletes(library);\n\n                    // Successfully deleted from server - delete from disk\n                    library._deletedFromDisk = true;\n                    AdobeLibraryFileUtils.deleteLibraryFromDisk(that, library.id, function (err) {\n                        finishOperation(err, true);\n                    });\n                });\n            });\n        });\n\n        // Run all the operations in parallel (collapse results into a single boolean value)\n        asyncJoin.run(callback);\n    };\n\n    // Returns true if the given id is already a library in the collection, or if it's marked as a pending delete\n    AdobeLibraryCollection.prototype._doesLibraryExist = function (id) {\n        if (this._libraryIdMap[id]) {\n            return true;\n        }\n\n        var i;\n        for (i = 0; i < this._pendingDeletes.length; i++) {\n            if (this._pendingDeletes[i].id === id) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    // Add an individual new library, based on the given id and collaboration state\n    AdobeLibraryCollection.prototype._syncNewLibrary = function (id, collaboration, callback) {\n        var that = this;\n\n        // 1) Create a new composite (don't add it to the library collection yet)\n        var href = this._syncManager.getCompositePath(id);\n        var path = AdobeLibraryServices.hasFileSystem() && this._getCompositeDir(id);\n        var dcxComposite = AdobeLibraryServices.dcx.newCompositeWithHref(href, path);\n        that._libraryIdMap[id] = 'pending';\n        that._updateSyncState();\n\n        // 2) Sync the composite, so we have all the data from the server\n        that._syncManager.pullComposite(dcxComposite, that, function (err, pulledBranch) {\n            if (err || !pulledBranch) {\n                delete that._libraryIdMap[id];\n                that._updateSyncState();\n\n                if (!err) {\n                    // Something went wrong pulling the branch - treat it as a generic network error\n                    err = new AdobeLibraryError(AdobeLibraryError.NETWORK_ERROR, 'No pulled branch');\n\n                } else if (err.code === AdobeDCXError.NO_COMPOSITE || err.code === AdobeDCXError.DELETED_COMPOSITE) {\n                    // The library may have been deleted from the server in-between calling the sync group and doing the poll.\n                    // Don't need to report an error in this case - just don't show the library\n                    err = null;\n\n                } else {\n                    err = AdobeLibraryErrorUtils.getSyncError(err, id);\n                }\n\n                callback(err, true);\n                return;\n            }\n\n            // 3) Accept the branch, since it's the only one\n            dcxComposite.resolvePullWithBranch(pulledBranch, function (err) {\n                // Handle error, or invalid library (composite id doesn't match folder on disk)\n                if (err || (!that.isPublic && dcxComposite.id !== id)) {\n                    delete that._libraryIdMap[id];\n                    that._updateSyncState();\n                    err = err ? AdobeLibraryErrorUtils.getCommitError(err, id)\n                              : new AdobeLibraryError(AdobeLibraryError.CORRUPTED_LIBRARY, 'Library id does not match sync group id');\n                    callback(err, true);\n                    return;\n                }\n\n                // 4) Actually add it as a library, so it'll show up in the collection\n                var library = new AdobeLibraryComposite(that, dcxComposite);\n                if (that.isPublic) {\n                    // Override the id, and make the library read-only, if it's in a public collection\n                    library._publicId = id;\n                    library._writable = false;\n                }\n                that._libraries.push(library);\n                that._libraryIdMap[library.id] = library;\n                that._updateSyncState();\n\n                // 5) Set the collaboration state of the library (uncollaborated vs incoming vs outgoing), based on the sync group information\n                // Note: this gets saved to disk locally (we sneakily stash it in the rendition cache), so we know this even if offline\n                library._setCollaboration(collaboration && collaboration.toLowerCase());\n\n                // 6) Generate thumbnails for the elements, if this was requested\n                AdobeLibraryRenditionUtils.prefetchRenditions(library);\n\n                // 7) Notify any change listeners, since we added a new library\n                that._notifyChange(true);\n\n                callback(null, true);\n            });\n        });\n    };\n\n    // Add any new libraries, based on the sync group information\n    AdobeLibraryCollection.prototype._syncNewLibraries = function (composites, callback) {\n        var that = this;\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n\n        // If we have a loading hint, we re-order the composites so the prioritised libraries get synced first\n        if (this._loadingHint) {\n            var newCompositeList = [];\n\n            // First add the prioritised libraries to the new list\n            composites.forEach(function (composite) {\n                if (that._loadingHint.indexOf(composite.name) !== -1) {\n                    newCompositeList.push(composite);\n                }\n            });\n            // Then add all the other libraries\n            composites.forEach(function (composite) {\n                if (that._loadingHint.indexOf(composite.name) === -1) {\n                    newCompositeList.push(composite);\n                }\n            });\n\n            composites = newCompositeList;\n        }\n\n\n        composites.forEach(function (composite) {\n            var id = composite.name;\n            var collaboration = composite.collaboration;\n\n            // Skip over any libraries that already exist (or are pending deletes)\n            if (that._doesLibraryExist(composite.name)) {\n                return;\n            }\n\n            // Now it must be a new library: schedule an operation to add it\n            asyncJoin.addOperation(that._syncNewLibrary, [id, collaboration], that);\n        });\n\n        // Run all the operations in parallel (collapse results into a single boolean value)\n        asyncJoin.run(callback);\n    };\n\n\n    AdobeLibraryCollection.prototype._syncExistingLibraries = function (compositeInfo, callback) {\n        var that = this;\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n\n        this._libraries.forEach(function (library) {\n            var info = compositeInfo && compositeInfo[library.id];\n\n            if (info) {\n                // Set the collaboration state of the library (uncollaborated vs incoming vs outgoing), based on the sync group information\n                // Note: this gets saved to disk locally (we sneakily stash it in the rendition cache), so we know this even if offline\n                // Note 2: only do this if the composite exists on the server; don't want to wipe collaboration state for deleted libraries\n                library._setCollaboration(info.collaboration && info.collaboration.toLowerCase());\n\n                // Since it's in the sync group, it's not deleted from the server. Make sure we clear the flag if it's set\n                library._deletedFromServer = false;\n            }\n\n            var isUnmodifiedOnServer = !compositeInfo || (info && info.isUnmodified);\n\n            if (library.collaboration === undefined) {\n                // For libraries that aren't collaborated:\n                // If the library was modified on the server (or there's a possibility it no longer exists), pull before pushing.\n                // Flipping this around, if we know for sure it wasn't modified on the server, we bypass the pull\n                asyncJoin.addOperation(library._sync, [isUnmodifiedOnServer], library);\n\n            } else if (!isUnmodifiedOnServer) {\n                // It's a collaborated library, but the sync group is telling us it was modified... so we better pull!\n                asyncJoin.addOperation(library._sync, [false], library);\n\n            } else {\n                // If it's a collaborated library, that the sync group says is unmodified, but we can't trust the sync group, dangnammit!\n                // (a) Incoming collaborations belong to another user, so etag propagation to our sync group doesn't work\n                // (b) Outgoing collaborations could have been modified by a different user, in which case the etag for the owner won't be updated\n\n                // So... we need to explicitly check to see if the manifest was not modified (we do a HEAD on the manifest)\n                asyncJoin.addOperation(function (finishedSync) {\n                    that._syncManager.hasCompositeChangedOnServer(library._dcxComposite, function (hasChanged) {\n                        // We'll do a pull if we discover the library had changed on the server\n                        library._sync(!hasChanged, finishedSync);\n                    });\n                });\n            }\n        });\n\n        // Run all the operations in parallel (collapse results into a single boolean value)\n        asyncJoin.run(callback);\n    };\n\n\n\n    AdobeLibraryCollection.prototype._dosync = function (callback) {\n        var that = this;\n\n        // Clear any error state before the sync\n        this._clearSyncErrors();\n\n        // First, poll the storage service to see if there are any changes.\n        this._syncManager.getServerComposites(function (err, composites, compositeInfo) {\n            if (err) {\n                err = AdobeLibraryErrorUtils.getSyncError(err);\n                that._reportSyncError(err);\n                callback(null, false);\n                return;\n            }\n\n            var asyncJoin = new AdobeLibraryAsyncJoin();\n\n            // Phase 1: get any new composites\n            asyncJoin.addOperation(that._syncNewLibraries, [composites], that);\n\n            // Phase 2: sync any existing composites: this is a pull, followed by a push\n            // (note: we only pull if the etag changed, and we only push if the library was modified)\n            asyncJoin.addOperation(that._syncExistingLibraries, [compositeInfo], that);\n\n            // Phase 3: take care of any pending deletes (libraries we tried to delete while we were offline)\n            asyncJoin.addOperation(that._handlePendingDeletes, [], that);\n\n            // Run the above phases in parallel\n            asyncJoin.run(function (err, didSomething) {\n                // Don't pass on the error, because we're specifying a report error callback\n                callback(null, didSomething);\n\n            }, function (err) {\n                that._reportSyncError(err);\n            });\n\n        });\n    };\n\n    // Private: report an error during a sync operation\n    AdobeLibraryCollection.prototype._reportSyncError = function (err) {\n        if (err) {\n            AdobeLibraryServices.log('Sync error: ' + AdobeLibraryErrorUtils.errorToString(err));\n            this._syncErrors.push(err);\n        }\n    };\n\n    // Private: report an error during a sync operation\n    AdobeLibraryCollection.prototype._clearSyncErrors = function (libraryId) {\n        if (libraryId) {\n            var newErrors = [];\n            this._syncErrors.forEach(function (err) {\n                if (err.libraryId !== libraryId) {\n                    newErrors.push(err);\n                }\n            });\n            this._syncErrors = newErrors;\n        } else {\n            this._syncErrors = [];\n        }\n    };\n\n    // Private: Error handling: notify all error listeners of the given error - from a commit operation\n    AdobeLibraryCollection.prototype._reportCommitError = function (err) {\n        this._lastCommitError = err;\n\n        if (err) {\n            AdobeLibraryServices.log('Commit error: ' + AdobeLibraryErrorUtils.errorToString(err));\n            this._listenerManager.notify('commitError', [err]);\n        }\n    };\n\n    // Private: set retry state\n    AdobeLibraryCollection.prototype._updateRetryState = function () {\n\n        // If we're already retrying, don't do anything (this shouldn't happen - just a safety guard)\n        if (this._retryTimeoutId) {\n            return;\n        }\n\n        // Don't update the retry state if we're still syncing\n        if (this._syncState === 'syncing') {\n            return;\n        }\n\n        if (this._syncState === 'error') {\n            var error = this.getPrimarySyncError();\n\n            if (error && error.code === AdobeLibraryError.RETRYABLE_SERVER_ERROR) {\n                // We can retry\n                this._numRetries++;\n\n                if (this._numRetries > AdobeLibraryConfig.ERROR_RETRY_INTERVALS.length) {\n                    // We reached the maximum number of retries, so stop retrying!\n                    this._retryTime = 'never';\n                    AdobeLibraryServices.log('Retry Failed');\n\n                    // Also, we throttle syncing to only every minute\n                    // Note: this will be reset by getLibraryComposites() on success, when we do the next sync\n                    AdobeLibraryConfig.MAX_SYNC_INTERVAL = AdobeLibraryConfig.RETRY_FAIL_MAX_SYNC_INTERVAL;\n\n                    return;\n                }\n\n                AdobeLibraryServices.log('Retry ' + this._numRetries);\n\n                // See if we were given a time to retry after\n                var headers = error.underlyingError && error.underlyingError.response && error.underlyingError.response.headers;\n                var retryAfter = AdobeLibrarySyncUtils.getRetryAfterHeader(headers) * 1000; // convert to milliseconds\n\n                if (retryAfter > 0) {\n                    // Note: We only retry once on a retry-after: adjust numRetries so the next retry doesn't try again\n                    this._numRetries = AdobeLibraryConfig.ERROR_RETRY_INTERVALS.length;\n                    AdobeLibraryServices.log('Got Retry-After header');\n\n                } else {\n                    // Set the retry based on our default backoff policy\n                    // At this point, this._numRetries is in the interval [1, AdobeLibraryConfig.ERROR_RETRY_INTERVALS.length]\n                    retryAfter = AdobeLibraryConfig.ERROR_RETRY_INTERVALS[this._numRetries - 1] * 1000;\n                }\n\n                AdobeLibraryServices.log('Retrying after ' + retryAfter + 'ms');\n\n                // Store the time when we're going to retry as a property, so other people can look it up\n                this._retryTime = new Date().valueOf() + retryAfter;\n\n                // Schedule the actual retry timeout\n                var that = this;\n                this._retryTimeoutId = setTimeout(function () {\n                    that._retryTimeoutId = undefined;\n                    that._retryTime = undefined;\n\n                    AdobeLibraryServices.log('Starting retry');\n                    that._syncWithParameters(false);\n                }, retryAfter);\n\n                return;\n\n            }\n\n            if (error && error.code === AdobeLibraryError.EXCEEDS_QUOTA) {\n\n                // Throttle syncing to only every minute, to give the user a chance to try to do something about the quota\n                // Although we'll still retry the upload, this at least slows us down a bit\n                // Note: this will be reset by getLibraryComposites() on success, when we do the next sync\n                AdobeLibraryConfig.MAX_SYNC_INTERVAL = AdobeLibraryConfig.RETRY_FAIL_MAX_SYNC_INTERVAL;\n\n                // Set retry to never, as though we retried and failed - because it's a non-recoverable error.\n                // Only way to recover is if the user does something - they'll have to click in the panel to try again\n                this._numRetries = AdobeLibraryConfig.ERROR_RETRY_INTERVALS.length + 1;\n                this._retryTime = 'never';\n\n                return;\n            }\n        }\n\n        // If we're ok, or it's an error that we can't retry, just reset the retry state\n        this._numRetries = 0;\n        this._retryTime = undefined;\n    };\n\n    // Private: gets called by composites to update the overall network state\n    AdobeLibraryCollection.prototype._updateSyncState = function () {\n\n        // Compute the overall sync state - if any library is syncing, it's 'syncing',\n        // otherwise if there are any errors, it's 'error', otherwise, 'ok'.\n\n        // Are we syncing?\n        var that = this;\n        var isSyncing = this._initialSyncInProgress;\n        Object.keys(this._libraryIdMap).forEach(function (id) {\n            var library = that._libraryIdMap[id];\n            var isLibrarySyncing = library === 'pending' || library._isSyncing();\n            isSyncing = isSyncing || isLibrarySyncing;\n        });\n\n        var newState;\n        if (isSyncing) {\n            newState = 'syncing';\n        } else {\n            if (this._syncErrors.length > 0) {\n                newState = 'error';\n\n                // Clear the cache of the last sync group - if there was an error, it means we may not have updated\n                // all the libraries, so we'd better pull down the sync group again when we try to re-sync.\n                that._syncManager.clearSyncGroupCache();\n\n                AdobeLibraryAnalytics.reportError(this.getPrimarySyncError());\n            } else {\n                newState = 'ok';\n            }\n\n            // Since we're not syncing, we'd better clear the progress state\n            this._syncProgressMap = {};\n            this._syncProgress = undefined;\n        }\n\n        // Update the state, and check if we need to retry\n        var oldSyncState = this._syncState;\n        this._syncState = newState;\n        this._updateRetryState();\n\n        // Notify people, only if the state changed, or we're in an error state (since the type of error could have changed)\n        if (oldSyncState !== newState || this._syncState === 'error') {\n            this._listenerManager.notify('sync');\n        }\n\n        // After syncing, always check to see if we need to create a default library!\n        // NOTE: This only ever creates the default library if the sync state is 'ok'\n        that._ensureDefaultLibrary();\n    };\n\n    // Private: called by the SyncManager to update progress while pushing/pulling\n    // Note: sync progress is approximate, since we don't have complete information about the size of libraries until\n    //       after they've started loading. Computation is as follows:\n    // 1) We compute the ratio loadedBytes/totalBytes over all the libraries we're syncing\n    // 2) If a library hasn't yet reported totalBytes, we reserve 1/(numLibraries) of space in the progress for that library\n    // 3) The progress is monotonic - i.e. it never goes backwards, even if we discover we had more work to do than we thought\n    // 4) ...except, we allow it to go backwards if we get to 100% and discover there was still more work to do, so we\n    //    don't block at 100% for ages.\n    AdobeLibraryCollection.prototype._updateProgress = function (id, bytesLoaded, bytesTotal) {\n        if (bytesTotal) {\n            this._syncProgressMap[id] = {\n                bytesLoaded: bytesLoaded || 0,\n                bytesTotal: bytesTotal\n            };\n\n        } else {\n            if (this._syncProgressMap[id]) {\n                // Indicates we've finished\n                if (this._syncProgressMap[id].bytesTotal === 0) {\n                    // Set a reasonable value, if we don't know what the total bytes was\n                    this._syncProgressMap[id].bytesTotal = 10000;\n                }\n                this._syncProgressMap[id].bytesLoaded = this._syncProgressMap[id].bytesTotal;\n            } else {\n                // Indicates we've just started\n                this._syncProgressMap[id] = {\n                    bytesLoaded: 0,\n                    bytesTotal: 0\n                };\n            }\n        }\n\n        // Update the percentage for the individual library\n        var libraryProgressChanged = false;\n        var libraryLoaded = bytesLoaded || 0;\n        var libraryTotal = bytesTotal || 0;\n        var newLibraryProgress = libraryTotal > 0 ? Math.max(0, Math.min(100, Math.round((libraryLoaded / bytesTotal) * 100))) : undefined;\n        if (this._syncProgressMap[id].progress !== newLibraryProgress) {\n            this._syncProgressMap[id].progress = newLibraryProgress;\n            libraryProgressChanged = true;\n        }\n\n        var totalSyncing = 0;\n        var totalKnown = 0;\n        var loaded = 0;\n        var total = 0;\n\n        var progressMap = this._syncProgressMap;\n        Object.keys(progressMap).forEach(function (key) {\n            totalSyncing++;\n            if (progressMap[key].bytesTotal > 0) {\n                totalKnown++;\n            }\n\n            loaded += progressMap[key].bytesLoaded;\n            total += progressMap[key].bytesTotal;\n        });\n\n        var progressRatio = total > 0 ? (loaded * totalKnown) / (total * totalSyncing) : 0;\n\n        var newProgress = Math.max(0, Math.min(100, Math.round(progressRatio * 100)));\n        if (!this._syncProgress || this._syncProgress < newProgress || (this._syncProgress === 100 && newProgress < 100)) {\n            this._syncProgress = newProgress;\n            libraryProgressChanged = true;\n        }\n        if (libraryProgressChanged) {\n            this._listenerManager.notify('sync');\n        }\n    };\n\n    // Private:\n    AdobeLibraryCollection.prototype._setInitialSyncState = function (initialSync, loadingHint) {\n        this._initialSyncInProgress = initialSync;\n        this._loadingHint = loadingHint;\n        this._updateSyncState();\n    };\n\n    // Private:\n    AdobeLibraryCollection.prototype._resetPollBackoff = function () {\n        this._backoffTicks = 0;\n        this._numBackoffs = 0;\n    };\n\n    // Private:\n    AdobeLibraryCollection.prototype._getBaseDir = function () {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var sanitisedUserId = this._userId.replace(/@/g, '_');\n        return this._rootDir + pathSep + sanitisedUserId + pathSep + this._cloudId;\n    };\n\n    // Private:\n    AdobeLibraryCollection.prototype._getCompositeDir = function (libraryId) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var compositeDir = this._getBaseDir() + pathSep + 'dcx';\n        if (libraryId) {\n            compositeDir += pathSep + libraryId;\n        }\n        return compositeDir;\n    };\n\n    // Private:\n    AdobeLibraryCollection.prototype._getTempDir = function () {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        return this._getBaseDir() + pathSep + '.tmp';\n    };\n\n    // Private:\n    AdobeLibraryCollection.prototype._getRenditionCacheDir = function (libraryId) {\n        var pathSep = AdobeLibraryServices.getPathSeparator();\n        var renditionCacheDir = this._getBaseDir() + pathSep + 'renditions';\n        if (libraryId) {\n            renditionCacheDir += pathSep + libraryId;\n        }\n        return renditionCacheDir;\n    };\n\n    // Private: ensure there's a default library: only if we're not in the middle of the initial sync, and there aren't any libraries.\n    // If it returns true, you should never call this again on this collection - otherwise it's ok to try again later (e.g. when\n    // you have a name for the default library).\n    AdobeLibraryCollection.prototype._ensureDefaultLibrary = function () {\n        var finishedSyncing = this.syncState === 'ok' && !this.initialSyncInProgress && AdobeLibraryConfig.SYNCING_ENABLED;\n\n        // We look at the number of libraries that really exist - i.e. they're not deleted locally, and they're not\n        // deleted on the server. Otherwise, you could have no libraries on the server (because they were deleted), but\n        // you don't get a new default library being created!!!!\n        var numMaterialLibraries = 0;\n        this.libraries.forEach(function (library) {\n            if (!library.deletedLocally && !library.deletedFromServer) {\n                numMaterialLibraries++;\n            }\n        });\n\n        if (!this.isPublic && AdobeLibraryConfig.DEFAULT_LIBRARY_NAME && finishedSyncing && numMaterialLibraries === 0) {\n            AdobeLibraryServices.log('Creating default library: ' + AdobeLibraryConfig.DEFAULT_LIBRARY_NAME);\n            this.createLibrary(AdobeLibraryConfig.DEFAULT_LIBRARY_NAME);\n        }\n    };\n\n    // Private: the actual removal of a library.\n    // You should normally call removeLibrary(), but this is used by the storage interface, so that we can bypass\n    // the analytics reporting (i.e. if a client causes the library delete to happen).\n    AdobeLibraryCollection.prototype._doRemoveLibrary = function (library, callback) {\n        var that = this;\n\n        var _callback = function (err) {\n            if (callback) {\n                callback(err);\n            }\n        };\n\n        var index = this._libraries.indexOf(library);\n        if (index !== -1) {\n            this._libraries.splice(index, 1);\n            delete this._libraryIdMap[library.id];\n        }\n\n        // Remove any listeners from the library, so we don't notify of any changes after it's been deleted!\n        library._removeAllListeners();\n\n        // Disable syncing if we have shared local storage - that service will do the syncing for us\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            library._dcxBranch.compositeState = 'pendingDelete';\n            library._commit(false, true);\n            library._markDeletedLocally(true);\n\n            _callback(null);\n\n        } else {\n\n            // Add the library to the list of pending deletes first.\n            // This ensures that if changes are being pulled before we delete the library, it won't be treated as a new library!\n            that._pendingDeletes.push(library);\n\n            if (!AdobeLibraryConfig.SYNCING_ENABLED) {\n                // We can't delete the library because we've turned off syncing\n                // Instead, we treat it like a failed delete, so we'll try to delete it again next time\n                library._dcxBranch.compositeState = 'pendingDelete';\n                library._commit(true, true); // Save deleted state: don't push, and don't update modified time\n                library._markDeletedLocally(true);\n                _callback(null);\n\n            } else {\n                // Delete from server, and from disk\n                library._deleteFromServer(true, function (err) {\n                    // Unbind the library so we can't continue to use it\n                    library._markDeletedLocally(true);\n\n                    if (err) {\n                        // Delete failed - that's ok, because it's in the pending deletes list, so we'll retry when we next sync\n                        _callback(null);\n                        return;\n                    }\n\n                    // Since the library was successfully deleted, we can remove it from the list of pending deletes\n                    that._removeFromPendingDeletes(library);\n\n                    // Delete from disk\n                    library._deletedFromDisk = true;\n                    AdobeLibraryFileUtils.deleteLibraryFromDisk(that, library.id, _callback);\n                });\n            }\n        }\n\n        this._notifyChange(true);\n    };\n\n    /**\n        Public API\n    **/\n\n    // Getters/setters for properties\n    Object.defineProperties(AdobeLibraryCollection.prototype, {\n        /**\n         * An array of all the libraries belonging to the collection.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Array.<AdobeLibraryComposite>}\n         * @instance\n         */\n        libraries: {\n            get: function () {\n                return this._libraries;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot modify libraries list directly');\n            }\n        },\n        /**\n         * The most recent commit error, if any - this is an error that occured while writing the library data to disk, and is most\n         * likely due to a filesystem error, or corrupt library data.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {AdobeLibraryError|undefined}\n         * @instance\n         */\n        commitError: {\n            get: function () {\n                return this._lastCommitError;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'commitError is a read-only property');\n            }\n        },\n        /**\n         * The state of syncing to/from Creative Cloud - either `'ok'`, `'syncing'`, or `'error'`. In the case of `'error'`, you can call\n         * look at the {@link AdobeLibraryCollection#getPrimarySyncError} to get the primary reason for failing to sync. There may be multiple\n         * reasons, in which case you can look at {@link AdobeLibraryCollection#syncErrors} to get the entire list.\n         *\n         * Use {@link AdobeLibraryCollection#addSyncListener} to register for notifications when this value changes.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {String}\n         * @instance\n         */\n        syncState: {\n            get: function () {\n                return this._syncState;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncState is a read-only property');\n            }\n        },\n        /**\n         * If {@link AdobeLibraryCollection#syncState} has a value of `'error'`, this array contains all the errors that happened during\n         * the latest attempt to sync. This is reset every time we sync, so it only shows you the most recent failures.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Array.<AdobeLibraryError>}\n         * @instance\n         */\n        syncErrors: {\n            get: function () {\n                return this._syncErrors;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncErrors is a read-only property');\n            }\n        },\n        /**\n         * If {@link AdobeLibraryCollection#syncState} has a value of `'syncing'`, this is an integer in the interval [0, 100],\n         * indicating the overall sync progress as a percentage. Note that this is an approximation, since information about the\n         * sizes of individual libraries come in at different times. However, it's guaranteed to monotonically increase during\n         * the course of a sync.\n         *\n         * Use {@link AdobeLibraryCollection#addSyncListener} to register for notifications when this value changes.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Number|undefined}\n         * @instance\n         */\n        syncProgress: {\n            get: function () {\n                return this._syncProgress;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncProgress is a read-only property');\n            }\n        },\n        /**\n         * This is set to `true` if and only if the following conditions hold:\n         *\n         * 1. We're doing the first sync as a consequence of calling {@link CCLibraries.loadLibraryCollection}. This means that\n         * {@link AdobeLibraryCollection#syncState} must have a value of `'syncing'`.\n         * 2. The logged-in user doesn't have any libraries synced to the local filesystem, or we're in a browser environment\n         * where there is no filesystem.\n         *\n         * This flag is used by clients that need to behave differently on the initial sync, e.g. in Photoshop and Illustrator,\n         * which show a progress indication on the initial sync, but immediately switch to the most recently used library after\n         * initialising, if there are already libraries locally synced to the machine.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Boolean}\n         * @instance\n         */\n        initialSyncInProgress: {\n            get: function () {\n                return this._initialSyncInProgress;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'initialSyncInProgress is a read-only property');\n            }\n        },\n        /**\n         * This is set to `true` if and only if polling is enabled. Use {@link AdobeLibraryCollection#startPolling}, and\n         * {@link AdobeLibraryCollection#stopPolling} to control whether polling is enabled.\n         *\n         * Note that if polling is disabled, it's the responsibility of the client to manually call {@link AdobeLibraryCollection#sync} -\n         * for example, in response to a notification of a change on the server.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Boolean}\n         * @instance\n         */\n        isPolling: {\n            get: function () {\n                return this._pollTimerId !== undefined;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'isPolling is a read-only property');\n            }\n        },\n        /**\n         * A number representing the time that the next sync attempt will occur, in response to a temporary server error\n         * ({AdobeLibraryError.RETRYABLE_SERVER_ERROR}), or `undefined` if no retry is scheduled.\n         *\n         * This follows the primitive value of a `Date` object (see [`Date.valueOf`](http://www.w3schools.com/jsref/jsref_valueof_date.asp))\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Number|undefined}\n         * @instance\n         */\n        retryTime: {\n            get: function () {\n                if (this._retryTime !== 'never') {\n                    return this._retryTime;\n                }\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'retryTime is a read-only property');\n            }\n        },\n        /**\n         * A string describing the user that owns the collection. This is the value passed in as the `USER_ID` option to\n         * {@link CCLibraries.loadLibraryCollection}. It's used when saving state to disk, so we store data for different\n         * users in different directories. Not required when in-browser.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {String}\n         * @instance\n         */\n        userId: {\n            get: function () {\n                return this._userId;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'userId is a read-only property');\n            }\n        },\n        /**\n         * The ID of the cloud that the collection belongs to. This is the value passed in as the `CLOUD_ID` option to\n         * {@link CCLibraries.loadLibraryCollection}. The default is `'creative_cloud'`. It's used when saving state\n         * to disk, so we store data for different clouds in different directories. Not required when in-browser, since\n         * we don't write anything to disk.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {String}\n         * @instance\n         */\n        cloudId: {\n            get: function () {\n                return this._cloudId;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'cloudId is a read-only property');\n            }\n        },\n        /**\n         * Information about the cloud that the collection belongs to, including the name, any endpoint information, whether it is a\n         * private cloud, etc. This is the object passed in as the `CLOUD_INFO` option to {@link CCLibraries.loadLibraryCollection}.\n         * If the `CLOUD_INFO` option was not specified, this will return `{}`.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Object}\n         * @instance\n         */\n        cloudInfo: {\n            get: function () {\n                return this._cloudInfo;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'cloudInfo is a read-only property');\n            }\n        },\n        /**\n         * A flag to indicate that the collection is a private collection (i.e. an instance of {@link AdobeLibraryCollection},\n         * rather than {@link AdobeLibraryPublicCollection}). Always returns `false`.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Boolean}\n         * @instance\n         */\n        isPublic: {\n            get: function () {\n                return false;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'isPublic is a read-only property');\n            }\n        }\n    });\n\n    /**\n        Change notifications\n    **/\n\n    /**\n     * Register a listener for changes in the library collection - i.e. libraries being added or removed. Note that\n     * this doesn't get called if an individual library changes. If you want to also be notified of changes to libraries\n     * in the collection, use {@link AdobeLibraryCollection#addDeepChangeListener}.\n     *\n     * For change notifications of a specific library, see {@link AdobeLibraryComposite#addChangeListener}.\n     *\n     * @param {Function} callback This gets called whenever the library collection changes.\n     * @memberof AdobeLibraryCollection\n     */\n    AdobeLibraryCollection.prototype.addChangeListener = function (callback) {\n        this._listenerManager.add('change', callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the library collection.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryCollection#addChangeListener}.\n     * @memberof AdobeLibraryCollection\n     */\n    AdobeLibraryCollection.prototype.removeChangeListener = function (callback) {\n        this._listenerManager.remove('change', callback);\n    };\n\n    /**\n     * Register a listener for changes to the library collection, or to any library in the collection.\n     *\n     * If you only want a shallow listener on the collection (i.e. just when libraries are added or removed),\n     * use {@link AdobeLibraryCollection#addChangeListener}.\n     *\n     * @param {Function} callback This gets called whenever the library collection, or any library in the collection changes.\n     * @memberof AdobeLibraryCollection\n     */\n    AdobeLibraryCollection.prototype.addDeepChangeListener = function (callback) {\n        this._listenerManager.add('deepchange', callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the library collection, or to any library in the collection.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryCollection#addDeepChangeListener}.\n     * @memberof AdobeLibraryCollection\n     */\n    AdobeLibraryCollection.prototype.removeDeepChangeListener = function (callback) {\n        this._listenerManager.remove('deepchange', callback);\n    };\n\n\n    /**\n        Library operations\n    **/\n\n    /**\n     * Creates a new library, with the given name, and pushes it to the server.\n     *\n     * If the push to the server fails, it will be retried on the next sync. If there's a local filesystem,\n     * the library gets written to disk, so the data won't be lost, even if syncing fails.\n     *\n     * @param {String} name The name of the new library.\n     * @param {Boolean} [beginOperation=false] If `true`, this will prevent us from committing the library to disk and\n     * immediately pushing it to the server, and instead will call {@link AdobeLibraryComposite#beginOperation}.\n     * Use this flag if you want to prevent the authomatic saving and pushing of an empty library before any elements\n     * have been added to it. You must remember to call {@link AdobeLibraryComposite#endOperation} after you have finished\n     * adding the initial elements, otherwise the library will never be pushed to the server.\n     * @returns {AdobeLibraryComposite} The new library.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.createLibrary = function (name, beginOperation) {\n        var id = AdobeLibraryServices.uuid();\n        var type = AdobeLibraryConfig.COMPOSITE_TYPE;\n        var path = this._getCompositeDir(id);\n\n        // Create the DCX composite\n        var dcxComposite = AdobeLibraryServices.dcx.newEmptyComposite(name, type, path, id);\n        dcxComposite.current.rootNode.setValue(AdobeLibraryConfig.VERSION_KEY, AdobeLibraryConfig.VERSION);\n        this._syncManager.prepareCompositeForPush(dcxComposite);\n\n        // Create the library\n        var library = new AdobeLibraryComposite(this, dcxComposite);\n        library._updateCreatedTime();\n\n        // Update the collection\n        this._libraries.push(library);\n        this._libraryIdMap[library.id] = library;\n\n        // Save to disk, and push to server\n        this._notifyChange(true);\n        if (beginOperation) {\n            library.beginOperation();\n        } else {\n            library._commit(false, true); // This commits and pushes the library, without changing the modification date\n        }\n\n        AdobeLibraryAnalytics.reportCreateLibrary(library);\n\n        return library;\n    };\n\n    /**\n     * Removes the given library from the collection, and deletes it from the server.\n     *\n     * If the server delete is successful, it gets deleted from disk afterwards (if there's a local filesystem).\n     * Otherwise, the library will be placed in a queue of pending deletes, and the delete will be retried on the\n     * next sync.\n     *\n     * @param {AdobeLibraryComposite} library The library to remove.\n     * @param {Function} callback This gets called when the library removal is complete.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.removeLibrary = function (library, callback) {\n        this._doRemoveLibrary(library, callback);\n\n        AdobeLibraryAnalytics.reportDeleteLibrary(library);\n    };\n\n    /**\n     * Utility to remove all libraries that are marked as deleted from the server.\n     *\n     * @param {Object} [options] Options to configure the call.\n     * @param {Array.<String>} [options.exclude] An array of library IDs to ignore, even if they are deleted. For example, if you\n     * want to remove all deleted libraries, except the library that's currently being shown in the client UI.\n     * @param {Function} callback This gets called when the library removal is complete.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @see {@link AdobeLibraryComposite#deletedFromServer}\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.removeDeletedLibraries = function (options, callback) {\n        var that = this;\n\n        // Handle first argument being the callback\n        if (typeof options === 'function') {\n            callback = options;\n            options = undefined;\n        }\n\n        var librariesToIgnore = (options && options.exclude) || [];\n\n        function removeDeletedLibrary(library, finishOperation) {\n            // Note: this is the same as removeLibrary, except we don't try to delete from the server, and\n            // we don't have any analytics - since the user didn't 'delete' the library, it was already gone\n            // from the server\n            var index = that._libraries.indexOf(library);\n            if (index !== -1) {\n                that._libraries.splice(index, 1);\n                delete that._libraryIdMap[library.id];\n            }\n\n            library._deletedFromDisk = true;\n            AdobeLibraryFileUtils.deleteLibraryFromDisk(that, library.id, finishOperation);\n\n            // Unbind the library so we can't continue to use it\n            library._markDeletedLocally(true);\n        }\n\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n\n        var hasLibrariesToRemove = false;\n\n        this._libraries.forEach(function (library) {\n            if (library.deletedFromServer) {\n                var shouldDelete = true;\n                librariesToIgnore.forEach(function (ignoreLibrary) {\n                    shouldDelete = shouldDelete && library !== ignoreLibrary;\n                });\n\n                if (shouldDelete) {\n                    hasLibrariesToRemove = true;\n                    asyncJoin.addOperation(removeDeletedLibrary, [library]);\n                }\n            }\n        });\n\n        asyncJoin.run(function (err) {\n            if (hasLibrariesToRemove) {\n                that._notifyChange(true);\n            }\n\n            callback(err);\n        });\n    };\n\n\n    /**\n        Syncing\n    **/\n\n    /**\n     * Manually sync the library collection with Creative Cloud. This checks for any new, or deleted libraries on the server,\n     * and pulls them down. Important things to note:\n     *\n     * 1. Syncing is throttled to at most once every 10s - if you call this function faster than that, they will be\n     * delayed by the API.\n     * 2. You don't have to call this to push changes to the server - this happens automatically (in the background) after any change.\n     *\n     * @param {Function} callback This gets called when the sync completes. Note that no parameters are passed back:\n     * you need to check the state of the library collection (e.g. {@link AdobeLibraryCollection#syncState} to see what happened.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.sync = function (_callback) {\n        this._syncWithParameters(false, false, _callback);\n    };\n\n    // Private: sync with specific parameters for polling and retrying\n    AdobeLibraryCollection.prototype._syncWithParameters = function (isPollSync, noRetry, _callback) {\n        var that = this;\n\n        var callback = function () {\n            if (_callback) {\n                _callback(null);\n            }\n        };\n\n        // Disable syncing if we have shared local storage - that service will do the syncing for us\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            AdobeLibraryServices.storageInterface.sync(this);\n\n            callback();\n            return;\n        }\n\n        // If syncing is disabled, don't do anything!\n        if (!AdobeLibraryConfig.SYNCING_ENABLED) {\n            callback();\n            return;\n        }\n\n        // If we have a retry pending, we block any other syncs until then\n        if (this._retryTimeoutId) {\n            callback();\n            return;\n        }\n\n        if (!isPollSync) {\n            // Reset backoff when there's a deliberate sync\n            this._resetPollBackoff();\n        }\n\n        // For now, only throttle if we're polling - maybe need to do something for notifications\n        if (this.isPolling) {\n\n            if (this._syncing) {\n                // We're already syncing, so no need to do it again\n                callback();\n                return;\n            }\n\n        } else {\n            // If we're not polling, we ensure that any manual sync will actually happen\n            // So.. even if we're already syncing, we need to schedule another one after we're finished\n\n            if (this._syncing) {\n                that._pendingSyncs.push(callback);\n                return;\n            }\n        }\n\n        var currentTime = new Date().valueOf();\n        if (currentTime < this._lastSyncTime + AdobeLibraryConfig.MAX_SYNC_INTERVAL) {\n            // If it's not that long since we last synced, wait a bit before retrying\n            // We only retry once, because if the next time fails, it means somebody synced for us!\n            if (!noRetry) {\n                setTimeout(function () {\n                    that._syncWithParameters(isPollSync, true, callback);\n                }, AdobeLibraryConfig.MAX_SYNC_INTERVAL);\n                return;\n            }\n\n            callback();\n            return;\n        }\n\n        AdobeLibraryServices.log('Start Sync ' + (isPollSync ? '[polling]' : ''));\n\n        this._syncing = true;\n        this._lastSyncTime = new Date().valueOf();\n\n        this._dosync(function (err, didPushOrPull) {\n            that._syncing = false;\n            that._updateSyncState();\n\n            AdobeLibraryServices.log('End Sync');\n\n            if (didPushOrPull) {\n                // Reset backoff when we detect that something changed on the server\n                that._backoffTicks = 0;\n                that._numBackoffs = 0;\n            }\n\n            // If we have syncs scheduled, do them now\n            if (that._pendingSyncs.length > 0) {\n                var callbacks = that._pendingSyncs;\n                that._pendingSyncs = [];\n\n                that.sync(function () {\n                    callbacks.forEach(function (cb) {\n                        cb();\n                    });\n                });\n            }\n\n            callback();\n        });\n    };\n\n    /**\n     * Register a listener for changes in the sync state and sync progress.\n     * See {@link AdobeLibraryCollection#syncState} and {@link AdobeLibraryCollection#syncProgress} for the actual state and\n     * progress information.\n     *\n     * @param {Function} callback This gets called whenever the sync state or sync progress changes.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.addSyncListener = function (callback) {\n        this._listenerManager.add('sync', callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the sync state and sync progress.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryCollection#addSyncListener}.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.removeSyncListener = function (callback) {\n        this._listenerManager.remove('sync', callback);\n    };\n\n    /**\n     * When {@link AdobeLibraryCollection#syncState} is `'error'`, this returns the highest-priority error that\n     * occurred. This saves you from having to iterate through {@link AdobeLibraryCollection#syncErrors} to determine\n     * the cause of the sync failure.\n     *\n     * @returns {AdobeLibraryError} The primary sync error, or `undefined` if no error.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.getPrimarySyncError = function () {\n        var primaryError = this._syncErrors[0];\n        this._syncErrors.forEach(function (err) {\n            var priority = AdobeLibraryErrorUtils.getErrorPriority(err);\n            var lastPriority = AdobeLibraryErrorUtils.getErrorPriority(primaryError);\n\n            if (priority > lastPriority) {\n                // Higher priority error takes precedence\n                primaryError = err;\n\n            } else if (priority === lastPriority && primaryError.code === err.code && primaryError.libraryId !== err.libraryId) {\n                // Same error code, but different libraries\n                primaryError = new AdobeLibraryError(primaryError.code, 'multiple errors (see libraryCollection.syncErrors)', undefined);\n            }\n        });\n\n        return primaryError;\n    };\n\n    /**\n     * When {@link AdobeLibraryCollection#syncState} is `'syncing'`, this returns data about any new libraries that have\n     * been discovered on the server, and are in the process of being downloaded. Since the libraries don't appear in\n     * {@link AdobeLibraryCollection#libraries} until they've finished downloading, this gives a way to view how many\n     * libraries are downloading, and what the progress of each is.\n     *\n     * This doesn't currently provide the names of the new libraries, but hopefully we can provide this information soon.\n     *\n     * @returns {Array.<Object>} An array of objects, with an `id` and `progress` field, describing the progress of\n     * the new libraries that are currently being synced.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.getNewLibrarySyncProgress = function () {\n        var that = this;\n\n        if (this._newLibraryProgress) {\n            // Shared local storage case: this gets set by a 'syncstate' message\n            return this._newLibraryProgress;\n        }\n\n        var newLibrarySyncProgress = [];\n\n        Object.keys(this._libraryIdMap).forEach(function (id) {\n            if (that._libraryIdMap[id] === 'pending') {\n                newLibrarySyncProgress.push({\n                    id: id,\n                    progress: that._syncProgressMap[id] && that._syncProgressMap[id].progress\n                });\n            }\n        });\n\n        return newLibrarySyncProgress;\n    };\n\n\n    /**\n        Register for errors on commit operations (i.e. local filesystem errors)\n    **/\n\n    /**\n     * Register a listener for errors during commit operations (i.e. reading and writing libraries from disk).\n     * See {@link AdobeLibraryCollection#commitError} for the actual error.\n     *\n     * @param {Function} callback This gets called whenever a commit error occurs.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.addCommitErrorListener = function (callback) {\n        this._listenerManager.add('commitError', callback);\n    };\n\n    /**\n     * Unregister a listener for errors during commit operations.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryCollection#addCommitErrorListener}.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.removeCommitErrorListener = function (callback) {\n        this._listenerManager.remove('commitError', callback);\n    };\n\n\n    /**\n        Manage starting and stopping of polling\n    **/\n\n    /**\n     * Start polling for library changes. This will call the server at periodic intervals, and automatically pull down any changes\n     * if they're discovered. The default polling interval is every 1 minute, but this can be configured via the `POLL_INTERVAL` option\n     * for {@link CCLibraries.configure}.\n     *\n     * Once polling, if there are no changes on the server, the polling interval gradually backs off, following a Fibonacci decay,\n     * up to a maximum of once every 55 minutes. If anything changes on the server, or any changes are made locally, or\n     * {@link AdobeLibraryCollection#sync} is called to force a manual sync, then the polling interval is reset to the default.\n     *\n     * It is expected that you call {@link AdobeLibraryCollection#sync}, even when polling, when the user is interacting with the\n     * library, to improve responsiveness. You shouldn't manually sync if the user is idle, to save server resources.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is disabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.startPolling = function () {\n\n        // If we're using shared local storage, we shouldn't be able to start and stop polling\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'startPolling() not supported with shared local storage');\n        }\n\n        if (!this.isPolling) {\n            var that = this;\n\n            // poll interval is in minutes\n            var interval = AdobeLibraryConfig.POLL_INTERVAL * 60000;\n            this._pollTimerId = setInterval(function () {\n\n                // If we're retrying, pause the polling\n                if (that._retryTime === 'never') {\n                    return;\n                }\n\n                // If we're backing off, need to wait before trying to sync again\n                if (that._backoffTicks > 0) {\n                    that._backoffTicks--;\n                    return;\n                }\n\n                // If we've reached the backoff time, we'll do a sync, but schedule the next sync\n                if (that._backoffTicks === 0) {\n                    that._numBackoffs++;\n                    that._backoffTicks = AdobeLibrarySyncUtils.getBackoffTicks(that._numBackoffs);\n                }\n\n                // Do the actual sync (this doesn't reset the backoff)\n                that._syncWithParameters(true);\n            }, interval);\n        }\n    };\n\n    /**\n     * Stop polling for library changes. After calling this, library changes will never be pulled down from the server unless\n     * you manually call {@link AdobeLibraryCollection#sync}, or make a change to a library to cause a push.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is disabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.stopPolling = function () {\n\n        // If we're using shared local storage, we shouldn't be able to start and stop polling\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'stopPolling() not supported with shared local storage');\n        }\n\n        if (this.isPolling) {\n            clearInterval(this._pollTimerId);\n            delete this._pollTimerId;\n        }\n\n        // Also, clear the retry timeout if there is one\n        if (this._retryTimeoutId) {\n            clearTimeout(this._retryTimeoutId);\n            delete this._retryTimeoutId;\n        }\n    };\n\n    /**\n        Finding libraries\n    **/\n\n    /**\n     * Get the default library - this is the oldest library that belongs to you. An incoming shared library can never\n     * be the default library, so it's possible to have a non-zero number of libraries, but no default library.\n     *\n     * @returns {AdobeLibraryComposite} The default library, or `undefined` if there is no default library\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.getDefaultLibrary = function () {\n        var defaultLibrary;\n\n        this.libraries.forEach(function (library) {\n            if (library.collaboration !== 'incoming') {\n                if (!defaultLibrary || (defaultLibrary.created || 0) > (library.created || 0)) {\n                    defaultLibrary = library;\n                }\n            }\n        });\n\n        return defaultLibrary;\n    };\n\n    /**\n     * Find a library by id, in the library collection.\n     *\n     * @param {Uuid} id A library id.\n     * @returns {AdobeLibraryComposite} The library with the given id, or `undefined` if no such library exists.\n     *\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.getLibraryById = function (id) {\n        var foundLibrary;\n\n        this.libraries.forEach(function (library) {\n            if (library.id === id) {\n                foundLibrary = library;\n            }\n        });\n\n        return foundLibrary;\n    };\n\n    /**\n     * Explicitly updates the access token used by the library collection.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is disabled.\n     *\n     * @param {String} accessToken The new access token (or `undefined` to clear the current access token without setting a new one).\n     * @see {@link AdobeLibraryCollection#isLoggedIn}\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.updateAccessToken = function (accessToken) {\n\n        // If we're using shared local storage, we shouldn't be able to set access tokens\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'updateAccessToken() not supported with shared local storage');\n        }\n\n        this._syncManager.updateAccessToken(accessToken);\n        AdobeLibraryServices.log('Update access token: ' + accessToken ? 'defined' : 'undefined');\n    };\n\n    /**\n     * Queries whether the library collection is in a logged-in state, meaning that it has a valid access token. If this returns `false`,\n     * you need to manually call {@link AdobeLibraryCollection#isLoggedIn} to set a new access token, before syncing can continue.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is disabled.\n     *\n     * @returns {Boolean} `true` if and only if we have a valid access token.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.isLoggedIn = function () {\n\n        // If we're using shared local storage, we shouldn't be able to set access tokens\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'isLoggedIn() not supported with shared local storage');\n        }\n\n        return this._syncManager.isLoggedIn();\n    };\n\n    /**\n     * Get a temp directory for the library collection. You can use this to\n     *\n     * This requires a filesystem (otherwise, you'll get a {@link AdobeLibraryError.REQUIRES_FILESYSTEM} error).\n     *\n     * @param {Function} callback This gets called with the path of the temp directory, ensuring that the directory exists.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {String} callback.path The path of the temp directory.\n     * @memberof AdobeLibraryCollection\n     * @instance\n     */\n    AdobeLibraryCollection.prototype.getTempDir = function (callback) {\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            callback(new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'getTempDir only supported when you have a filesystem'));\n            return;\n        }\n\n        var tempPath = this._getTempDir();\n        AdobeLibraryFileUtils.ensurePathExists(tempPath, function (err) {\n            callback(err, tempPath);\n        });\n    };\n\n    return AdobeLibraryCollection;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define */\n\n/**\n * @class AdobeLibraryPublicCollection\n * @classdesc\n * A collection of publically-accessible Creative Cloud Libraries. This has similar methods to {@link AdobeLibraryCollection},\n * except that you can't add or remove libraries - you can only load and unload them.\n *\n * The libraries in a public collection are read-only.\n *\n * @description\n * This class has a private constructor. The only way to obtain an instance of AdobeLibraryCollection\n * is by calling {@link CCLibraries.loadPublicLibraryCollection}.\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryPublicCollection',['require','exports','module','./AdobeLibraryCollection','./AdobeLibraryError','./AdobeLibraryConfig','./AdobeLibraryServices','./utils/AdobeLibraryAsyncJoin','./utils/AdobeLibraryFileUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryCollection = require('./AdobeLibraryCollection');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n\n    var AdobeLibraryAsyncJoin = require('./utils/AdobeLibraryAsyncJoin');\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n\n\n    // Private constructor\n    function AdobeLibraryPublicCollection(options) {\n        options.IS_PUBLIC = true;\n        options.USER_ID = AdobeLibraryConfig.PUBLIC_USER_ID;\n\n        // Private data\n        this._newLibrariesLoading = {};\n\n        // Call the super-class constructor\n        AdobeLibraryCollection.call(this, options);\n    }\n\n    // We automatically inherit all the private methods (some will be overridden by us, to change functionality),\n    // but pubic methods and properties are selectively picked. This is because (a) we want to not include certain\n    // methods (e.g. for creating new libraries), and (b) we need the jsdoc comments anyway, so we can document this class.\n\n    // Inherit all the private methods\n    Object.keys(AdobeLibraryCollection.prototype).forEach(function (method) {\n        if (method.indexOf('_') === 0) {\n            AdobeLibraryPublicCollection.prototype[method] = AdobeLibraryCollection.prototype[method];\n        }\n    });\n\n    // Override _dosync, because we don't have a sync group!\n    AdobeLibraryPublicCollection.prototype._dosync = function (callback) {\n        var that = this;\n\n        // Clear any error state before the sync\n        this._clearSyncErrors();\n\n        // All we need to do is sync any existing libraries - we don't auto-pull any libraries other than\n        // through loadLibrary, and there are no pending deletes!\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n        this._libraries.forEach(function (library) {\n            asyncJoin.addOperation(function (finishedSync) {\n                that._syncManager.hasCompositeChangedOnServer(library._dcxComposite, function (hasChanged) {\n                    // We'll do a pull if we discover the library had changed on the server\n                    library._sync(!hasChanged, finishedSync);\n                });\n            });\n        });\n\n        // Sync the libraries in parallel\n        asyncJoin.run(function (err, didSomething) {\n            // Don't pass on the error, because we're specifying a report error callback\n            callback(null, didSomething);\n\n        }, function (err) {\n            that._reportSyncError(err);\n        });\n    };\n\n\n    /**\n        Public API\n    **/\n\n    // Getters/setters for properties\n    Object.defineProperties(AdobeLibraryPublicCollection.prototype, {\n        /**\n         * An array of all the libraries belonging to the collection.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Array.<AdobeLibraryComposite>}\n         * @instance\n         */\n        libraries: {\n            get: function () {\n                return this._libraries;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'Cannot modify libraries list directly');\n            }\n        },\n        /**\n         * The most recent commit error, if any - this is an error that occured while writing the library data to disk, and is most\n         * likely due to a filesystem error, or corrupt library data.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {AdobeLibraryError|undefined}\n         * @instance\n         */\n        commitError: {\n            get: function () {\n                return this._lastCommitError;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'commitError is a read-only property');\n            }\n        },\n        /**\n         * The state of syncing to/from Creative Cloud - either `'ok'`, `'syncing'`, or `'error'`. In the case of `'error'`, you can call\n         * look at the {@link AdobeLibraryPublicCollection#getPrimarySyncError} to get the primary reason for failing to sync. There may be multiple\n         * reasons, in which case you can look at {@link AdobeLibraryPublicCollection#syncErrors} to get the entire list.\n         *\n         * Use {@link AdobeLibraryPublicCollection#addSyncListener} to register for notifications when this value changes.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {String}\n         * @instance\n         */\n        syncState: {\n            get: function () {\n                return this._syncState;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncState is a read-only property');\n            }\n        },\n        /**\n         * If {@link AdobeLibraryPublicCollection#syncState} has a value of `'error'`, this array contains all the errors that happened during\n         * the latest attempt to sync. This is reset every time we sync, so it only shows you the most recent failures.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Array.<AdobeLibraryError>}\n         * @instance\n         */\n        syncErrors: {\n            get: function () {\n                return this._syncErrors;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncErrors is a read-only property');\n            }\n        },\n        /**\n         * If {@link AdobeLibraryPublicCollection#syncState} has a value of `'syncing'`, this is an integer in the interval [0, 100],\n         * indicating the overall sync progress as a percentage. Note that this is an approximation, since information about the\n         * sizes of individual libraries come in at different times. However, it's guaranteed to monotonically increase during\n         * the course of a sync.\n         *\n         * Use {@link AdobeLibraryPublicCollection#addSyncListener} to register for notifications when this value changes.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Number|undefined}\n         * @instance\n         */\n        syncProgress: {\n            get: function () {\n                return this._syncProgress;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'syncProgress is a read-only property');\n            }\n        },\n        /**\n         * This is set to `true` if and only if polling is enabled. Use {@link AdobeLibraryPublicCollection#startPolling}, and\n         * {@link AdobeLibraryPublicCollection#stopPolling} to control whether polling is enabled.\n         *\n         * Note that if polling is disabled, it's the responsibility of the client to manually call {@link AdobeLibraryPublicCollection#sync} -\n         * for example, in response to a notification of a change on the server.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Boolean}\n         * @instance\n         */\n        isPolling: {\n            get: function () {\n                return this._pollTimerId !== undefined;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'isPolling is a read-only property');\n            }\n        },\n        /**\n         * A number representing the time that the next sync attempt will occur, in response to a temporary server error\n         * ({AdobeLibraryError.RETRYABLE_SERVER_ERROR}), or `undefined` if no retry is scheduled.\n         *\n         * This follows the primitive value of a `Date` object (see [`Date.valueOf`](http://www.w3schools.com/jsref/jsref_valueof_date.asp))\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Number|undefined}\n         * @instance\n         */\n        retryTime: {\n            get: function () {\n                if (this._retryTime !== 'never') {\n                    return this._retryTime;\n                }\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'retryTime is a read-only property');\n            }\n        },\n        /**\n         * The ID of the cloud that the collection belongs to. This is the value passed in as the `CLOUD_ID` option to\n         * {@link CCLibraries.loadPublicLibraryCollection}. The default is `'creative_cloud'`. It's used when saving state\n         * to disk, so we store data for different clouds in different directories. Not required when in-browser, since\n         * we don't write anything to disk.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {String}\n         * @instance\n         */\n        cloudId: {\n            get: function () {\n                return this._cloudId;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'cloudId is a read-only property');\n            }\n        },\n        /**\n         * Information about the cloud that the collection belongs to, including the name, any endpoint information, whether it is a\n         * private cloud, etc. This is the object passed in as the `CLOUD_INFO` option to {@link CCLibraries.loadPublicLibraryCollection}.\n         * If the `CLOUD_INFO` option was not specified, this will return `{}`.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryCollection\n         * @type {Object}\n         * @instance\n         */\n        cloudInfo: {\n            get: function () {\n                return this._cloudInfo;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'cloudInfo is a read-only property');\n            }\n        },\n        /**\n         * A flag to indicate that the collection is a public collection (i.e. an instance of {@link AdobeLibraryPublicCollection},\n         * rather than {@link AdobeLibraryCollection}). Always returns `true`.\n         *\n         * Read-only.\n         *\n         * @memberof AdobeLibraryPublicCollection\n         * @type {Boolean}\n         * @instance\n         */\n        isPublic: {\n            get: function () {\n                return true;\n            },\n            set: function () {\n                throw new AdobeLibraryError(AdobeLibraryError.READ_ONLY, 'isPublic is a read-only property');\n            }\n        }\n    });\n\n    /**\n        Change notifications\n    **/\n\n    /**\n     * Register a listener for changes in the library collection - i.e. libraries being added or removed. Note that\n     * this doesn't get called if an individual library changes - if you want library-level change events, you need to\n     * register with {@link AdobeLibraryComposite.addChangeListener}.\n     *\n     * @param {Function} callback This gets called whenever the library collection changes.\n     * @memberof AdobeLibraryPublicCollection\n     */\n    AdobeLibraryPublicCollection.prototype.addChangeListener = function (callback) {\n        AdobeLibraryCollection.prototype.addChangeListener.call(this, callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the library collection.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryPublicCollection#addChangeListener}.\n     * @memberof AdobeLibraryPublicCollection\n     */\n    AdobeLibraryPublicCollection.prototype.removeChangeListener = function (callback) {\n        AdobeLibraryCollection.prototype.removeChangeListener.call(this, callback);\n    };\n\n    /**\n        Library operations: loading and unloading\n    **/\n\n    /**\n     * Load a public library from the cloud, with the given id. This will download the specified library (saving a cache to\n     * disk if you have a filesystem).\n     *\n     * @param {String} id The globally-unique id of the public library.\n     * @param {Function} callback This gets called when the library is successfully downloaded (or immediately if it already is loaded).\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     * @param {AdobeLibraryComposite} callback.library The loaded library, or `undefined` if there was an error loading it, or the library doesn't\n     * exist on the server (which indicates that either the public link was never created, or it's been revoked).\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.loadLibrary = function (id, callback) {\n        var that = this;\n\n        // If the library already is loaded, just return it\n        if (this.getLibraryById(id)) {\n            callback(null, this.getLibraryById(id));\n            return;\n        }\n\n        // We keep an array of callbacks for everyone who called us, for this library id\n        var loadingCallbacks = this._newLibrariesLoading[id];\n        if (loadingCallbacks) {\n            // If we're already loading, we just\n            loadingCallbacks.push(callback);\n            return;\n        }\n        this._newLibrariesLoading[id] = [callback];\n\n        function _callback(err, library) {\n            var callbacks = that._newLibrariesLoading[id];\n            delete that._newLibrariesLoading[id];\n\n            callbacks.forEach(function (cb) {\n                cb(err, library);\n            });\n        }\n\n        // If we have shared local storage, need the service to load the library\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            AdobeLibraryServices.storageInterface.loadPublicLibrary(this, id, _callback);\n            return;\n        }\n\n        // Otherwise, we need to pull down the new library\n        this._syncNewLibrary(id, undefined, function (err) {\n            if (err) { _callback(err); return; }\n\n            _callback(null, that.getLibraryById(id));\n        });\n    };\n\n    /**\n     * Unload the given public library. This just deletes the local copy of the data - it doesn't affect the library in the cloud\n     * in any way.\n     *\n     * @param {AdobeLibraryComposite} library The library to unload.\n     * @param {Function} callback This gets called when the library has finished unloading.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.unloadLibrary = function (library, callback) {\n\n        var index = this._libraries.indexOf(library);\n        if (index !== -1) {\n            this._libraries.splice(index, 1);\n            delete this._libraryIdMap[library.id];\n        } else {\n            callback(null);\n            return;\n        }\n        library._markDeletedLocally(true);\n\n        // Delete the data from disk\n        if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            library._deletedFromDisk = true;\n            AdobeLibraryFileUtils.deleteLibraryFromDisk(this, library.id, callback);\n        } else {\n            // Need to get the shared local storage service to delete the library\n            AdobeLibraryServices.storageInterface.unloadPublicLibrary(library, callback);\n        }\n\n        this._listenerManager.notify('change');\n    };\n\n    /**\n     * Utility to unload all loaded public libraries that are marked as deleted from the server (i.e. the owner of the public\n     * library deleted it).\n     *\n     * @param {Object} [options] Options to configure the call.\n     * @param {Array.<String>} [options.exclude] An array of library IDs to ignore, even if they are deleted. For example, if you\n     * want to unload all deleted libraries, except the library that's currently being shown in the client UI.\n     * @param {Function} callback This gets called when the library has finished unloading.\n     * @param {AdobeLibraryError} callback.err The error that occurred, or `null` if success.\n     *\n     * @see {@link AdobeLibraryComposite#deletedFromServer}\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.unloadDeletedLibraries = function (options, callback) {\n        AdobeLibraryCollection.prototype.removeDeletedLibraries.call(this, options, callback);\n    };\n\n\n    /**\n        Syncing\n    **/\n\n    /**\n     * Manually sync the library collection with Creative Cloud. This checks for any new, or deleted libraries on the server,\n     * and pulls them down. Syncing is throttled to at most once every 10s - if you call this function faster than that, they will be\n     * delayed by the API.\n     *\n     * @param {Function} callback This gets called when the sync completes. Note that no parameters are passed back:\n     * you need to check the state of the library collection (e.g. {@link AdobeLibraryPublicCollection#syncState} to see what happened.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.sync = function (callback) {\n        AdobeLibraryCollection.prototype.sync.call(this, callback);\n    };\n\n    /**\n     * Register a listener for changes in the sync state and sync progress.\n     * See {@link AdobeLibraryPublicCollection#syncState} and {@link AdobeLibraryPublicCollection#syncProgress} for the actual state and\n     * progress information.\n     *\n     * @param {Function} callback This gets called whenever the sync state or sync progress changes.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.addSyncListener = function (callback) {\n        AdobeLibraryCollection.prototype.addSyncListener.call(this, callback);\n    };\n\n    /**\n     * Unregister a listener for changes in the sync state and sync progress.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryPublicCollection#addSyncListener}.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.removeSyncListener = function (callback) {\n        AdobeLibraryCollection.prototype.removeSyncListener.call(this, callback);\n    };\n\n    /**\n     * When {@link AdobeLibraryPublicCollection#syncState} is `'error'`, this returns the highest-priority error that\n     * occurred. This saves you from having to iterate through {@link AdobeLibraryPublicCollection#syncErrors} to determine\n     * the cause of the sync failure.\n     *\n     * @returns {AdobeLibraryError} The primary sync error, or `undefined` if no error.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.getPrimarySyncError = function () {\n        return AdobeLibraryCollection.prototype.getPrimarySyncError.call(this);\n    };\n\n    /**\n     * When {@link AdobeLibraryPublicCollection#syncState} is `'syncing'`, this returns data about any new libraries that have\n     * been discovered on the server, and are in the process of being downloaded. Since the libraries don't appear in\n     * {@link AdobeLibraryPublicCollection#libraries} until they've finished downloading, this gives a way to view how many\n     * libraries are downloading, and what the progress of each is.\n     *\n     * This doesn't currently provide the names of the new libraries, but hopefully we can provide this information soon.\n     *\n     * @returns {Array.<Object>} An array of objects, with an `id` and `progress` field, describing the progress of\n     * the new libraries that are currently being synced.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.getNewLibrarySyncProgress = function () {\n        return AdobeLibraryCollection.prototype.getNewLibrarySyncProgress.call(this);\n    };\n\n\n    /**\n        Register for errors on commit operations (i.e. local filesystem errors)\n    **/\n\n    /**\n     * Register a listener for errors during commit operations (i.e. reading and writing libraries from disk).\n     * See {@link AdobeLibraryPublicCollection#commitError} for the actual error.\n     *\n     * @param {Function} callback This gets called whenever a commit error occurs.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.addCommitErrorListener = function (callback) {\n        AdobeLibraryCollection.prototype.addCommitErrorListener.call(this, callback);\n    };\n\n    /**\n     * Unregister a listener for errors during commit operations.\n     *\n     * @param {Function} callback The callback function that was passed to {@link AdobeLibraryPublicCollection#addCommitErrorListener}.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.removeCommitErrorListener = function (callback) {\n        AdobeLibraryCollection.prototype.removeCommitErrorListener.call(this, callback);\n    };\n\n\n    /**\n        Manage starting and stopping of polling\n    **/\n\n    /**\n     * Start polling for library changes. This will call the server at periodic intervals, and automatically pull down any changes\n     * if they're discovered. The default polling interval is every 1 minute, but this can be configured via the `POLL_INTERVAL` option\n     * for {@link CCLibraries.configure}.\n     *\n     * Once polling, if there are no changes on the server, the polling interval gradually backs off, following a Fibonacci decay,\n     * up to a maximum of once every 55 minutes. If anything changes on the server, or any changes are made locally, or\n     * {@link AdobeLibraryPublicCollection#sync} is called to force a manual sync, then the polling interval is reset to the default.\n     *\n     * It is expected that you call {@link AdobeLibraryPublicCollection#sync}, even when polling, when the user is interacting with the\n     * library, to improve responsiveness. You shouldn't manually sync if the user is idle, to save server resources.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is disabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.startPolling = function () {\n        AdobeLibraryCollection.prototype.startPolling.call(this);\n    };\n\n    /**\n     * Stop polling for library changes. After calling this, library changes will never be pulled down from the server unless\n     * you manually call {@link AdobeLibraryPublicCollection#sync}.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is disabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.stopPolling = function () {\n        AdobeLibraryCollection.prototype.stopPolling.call(this);\n    };\n\n    /**\n        Finding libraries\n    **/\n\n    /**\n     * Find a library by id, in the library collection.\n     *\n     * @param {Uuid} id A library id.\n     * @returns {AdobeLibraryComposite} The library with the given id, or `undefined` if no such library exists.\n     *\n     * @memberof AdobeLibraryPublicCollection\n     * @instance\n     */\n    AdobeLibraryPublicCollection.prototype.getLibraryById = function (id) {\n        return AdobeLibraryCollection.prototype.getLibraryById.call(this, id);\n    };\n\n\n    return AdobeLibraryPublicCollection;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node:true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryCollectionManager\n * @classdesc\n * Managing the set of loaded collections\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryCollectionManager',['require','exports','module','./utils/AdobeLibraryListenerManager'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryListenerManager = require('./utils/AdobeLibraryListenerManager');\n\n    // Constructor\n    // Note: this is for internal use by the design library\n    function AdobeLibraryCollectionManager() {\n        this._collections = [];\n        this._listenerManager = new AdobeLibraryListenerManager(['change']);\n    }\n\n\n    /**\n        Public APIs for Library collections\n    **/\n\n    AdobeLibraryCollectionManager.prototype.getLibraryCollection = function (userId, cloudId) {\n        var _collection;\n        this._collections.forEach(function (collection) {\n            if (!collection.isPublic && collection.userId === userId && collection.cloudId === cloudId) {\n                _collection = collection;\n            }\n        });\n        return _collection;\n    };\n\n    AdobeLibraryCollectionManager.prototype.getPublicLibraryCollection = function (cloudId) {\n        var _collection;\n        this._collections.forEach(function (collection) {\n            if (collection.isPublic && collection.cloudId === cloudId) {\n                _collection = collection;\n            }\n        });\n        return _collection;\n    };\n\n    AdobeLibraryCollectionManager.prototype.addLibraryCollection = function (collection) {\n        this._collections.push(collection);\n        this._listenerManager.notify('change');\n    };\n\n    AdobeLibraryCollectionManager.prototype.removeLibraryCollection = function (collection) {\n        var index = this._collections.indexOf(collection);\n        if (index !== -1) {\n            this._collections.splice(index, 1);\n            this._listenerManager.notify('change');\n        }\n    };\n\n    AdobeLibraryCollectionManager.prototype.removeAllLibraryCollections = function () {\n        this._collections = [];\n        this._listenerManager.notify('change');\n    };\n\n    AdobeLibraryCollectionManager.prototype.getLoadedCollections = function () {\n        return this._collections;\n    };\n\n\n    /**\n        Public APIs for change listeners\n    **/\n\n    AdobeLibraryCollectionManager.prototype.addLoadedCollectionsListener = function (callback) {\n        this._listenerManager.add('change', callback);\n    };\n\n    AdobeLibraryCollectionManager.prototype.removeLoadedCollectionsListener = function (callback) {\n        this._listenerManager.remove('change', callback);\n    };\n\n\n    return AdobeLibraryCollectionManager;\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, ArrayBuffer, Uint8Array */\n\n/**\n * @class AdobeLibraryMessageChannel\n * @classdesc\n * Interface for messaging between client/server components\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryMessageChannel',['require','exports','module','./AdobeLibraryServices','./utils/AdobeLibraryListenerManager'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryListenerManager = require('./utils/AdobeLibraryListenerManager');\n\n    // Constructor\n    // Note: this is for internal use by the design library\n    function AdobeLibraryMessageChannel(socket) {\n        this._socket = socket;\n        this._listenerManager = new AdobeLibraryListenerManager();\n        this._socketListenerManager = new AdobeLibraryListenerManager();\n\n        this._pendingWriteState = {};\n        this._pendingWriteDependencyMap = {};\n\n        this._init();\n    }\n\n    /**\n        Utility\n    **/\n\n    function getRequestType(type) {\n        return type + '_req';\n    }\n\n    function getResponseType(type) {\n        return type + '_res';\n    }\n\n    function getPendingWriteKey(userId, cloudId, libraryId) {\n        return userId + '#' + cloudId + '#' + libraryId;\n    }\n\n\n    /**\n        Initialisation\n    **/\n\n    AdobeLibraryMessageChannel.prototype._init = function () {\n        var that = this;\n\n        this._addSocketListener('message', function (data) {\n            var message = JSON.parse(data);\n            that._logReceive(message.type);\n\n            that._listenerManager.notify(message.type, [message.data]);\n        });\n    };\n\n    // Keep track of callbacks\n    AdobeLibraryMessageChannel.prototype._addSocketListener = function (event, callback) {\n        this._socketListenerManager.add(event, callback);\n        this._socket.addListener(event, callback);\n    };\n\n    AdobeLibraryMessageChannel.prototype._removeSocketListeners = function () {\n        var that = this;\n        this._socketListenerManager.forEach(function (event, callback) {\n            that._socket.removeListener(event, callback);\n        });\n        this._socketListenerManager.removeAll();\n    };\n\n    AdobeLibraryMessageChannel.prototype._logSend = function (type) {\n        if (this._logCallback) {\n            this._logCallback('SEND ' + type);\n        }\n    };\n\n    AdobeLibraryMessageChannel.prototype._logReceive = function (type) {\n        if (this._logCallback) {\n            this._logCallback('RECEIVE ' + type);\n        }\n    };\n\n\n    /**\n        Public API\n    **/\n\n    // Associate wite state with a channel - we use this to track writes\n    AdobeLibraryMessageChannel.prototype.setPendingWriteState = function (userId, cloudId, libraryId) {\n        var key = getPendingWriteKey(userId, cloudId, libraryId);\n        this._pendingWriteState[key] = true;\n    };\n\n    AdobeLibraryMessageChannel.prototype.setPendingWriteDependency = function (userId1, cloudId1, libraryId1, userId2, cloudId2, libraryId2) {\n        var key1 = getPendingWriteKey(userId1, cloudId1, libraryId1);\n        var key2 = getPendingWriteKey(userId2, cloudId2, libraryId2);\n        if (key1 !== key2) {\n            // It doesn't make sense for a library to depend on itself...\n            this._pendingWriteDependencyMap[key1] = this._pendingWriteDependencyMap[key1] || {};\n            this._pendingWriteDependencyMap[key1][key2] = {userId: userId2, cloudId: cloudId2, id: libraryId2};\n        }\n    };\n\n    AdobeLibraryMessageChannel.prototype.clearPendingWriteState = function (userId, cloudId, libraryId) {\n        var key = getPendingWriteKey(userId, cloudId, libraryId);\n\n        var clearedDependencies = [];\n        Object.keys(this._pendingWriteDependencyMap[key] || {}).forEach(function (depKey) {\n            clearedDependencies.push(this._pendingWriteDependencyMap[key][depKey]);\n        }, this);\n\n        delete this._pendingWriteState[key];\n        delete this._pendingWriteDependencyMap[key];\n\n        return clearedDependencies;\n    };\n\n    // If excludeSelfState is false, we look at whether the library is a pending write, or any pending write libraries depend on it\n    // If excludeSelfState is true, we just look at whether any other pending write libraries depend on it\n    AdobeLibraryMessageChannel.prototype.getPendingWriteState = function (userId, cloudId, libraryId, excludeSelfState) {\n        var key = getPendingWriteKey(userId, cloudId, libraryId);\n\n        var isPending = false;\n        if (!excludeSelfState && this._pendingWriteState[key]) {\n            isPending = this._pendingWriteState[key];\n        }\n\n        // Search through all the dependencies, and see if there are any other libraries that are\n        // depending on us, with a pending write - if so, we should also act as though we're a pending write\n        // (to turn off GC).\n        Object.keys(this._pendingWriteDependencyMap).forEach(function (depKey) {\n            var map = this._pendingWriteDependencyMap[depKey];\n            if (map[key]) {\n                isPending = this._pendingWriteState[depKey] || isPending;\n            }\n        }, this);\n        return isPending;\n    };\n\n    AdobeLibraryMessageChannel.prototype.setLogCallback = function (callback) {\n        this._logCallback = callback;\n    };\n\n\n    // Listen for an event\n    AdobeLibraryMessageChannel.prototype.addListener = function (type, callback) {\n        this._listenerManager.add(type, callback);\n    };\n\n    AdobeLibraryMessageChannel.prototype.removeListener = function (type, callback) {\n        this._listenerManager.remove(type, callback);\n    };\n\n    // Send an event\n    AdobeLibraryMessageChannel.prototype.send = function (type, data) {\n        try {\n            this._logSend(type);\n            this._socket.send(JSON.stringify({\n                type: type,\n                data: data\n            }));\n\n        } catch (error) {\n            this._socketListenerManager.notify('error', [error]);\n        }\n    };\n\n    // Listen for a call (listening for a request event, and sending a response event)\n    AdobeLibraryMessageChannel.prototype.addCallListener = function (type, callback) {\n        var that = this;\n\n        this.addListener(getRequestType(type), function (request) {\n            var id = request.id;\n\n            callback(request.data, function (responseData) {\n                that.send(getResponseType(type), {\n                    id: id,\n                    data: responseData\n                });\n            });\n        });\n    };\n\n    AdobeLibraryMessageChannel.prototype.removeCallListener = function (type, callback) {\n        this.removeListener(getRequestType(type));\n    };\n\n    // Make a call (sending a request event, and listening for a response event)\n    AdobeLibraryMessageChannel.prototype.call = function (type, data, callback) {\n        var that = this;\n\n        var requestID = AdobeLibraryServices.uuid();\n\n        // Listen for the response\n        var onResponse = function (response) {\n            if (response.id === requestID) {\n                that.removeListener(getResponseType(type), onResponse);\n                callback(response.data);\n            }\n        };\n        this.addListener(getResponseType(type), onResponse);\n\n        // Send the request\n        this.send(getRequestType(type), {\n            id: requestID,\n            data: data\n        });\n    };\n\n    AdobeLibraryMessageChannel.prototype.onOpen = function (callback) {\n        this._addSocketListener('open', callback);\n    };\n\n    AdobeLibraryMessageChannel.prototype.onClose = function (callback) {\n        this._addSocketListener('close', callback);\n    };\n\n    AdobeLibraryMessageChannel.prototype.onError = function (callback) {\n        this._addSocketListener('error', callback);\n    };\n\n    // Shutdown: remove all listeners\n    AdobeLibraryMessageChannel.prototype.shutdown = function () {\n        var that = this;\n\n        // Need to wait for the socket to actually close before shutting down all the sockets\n        this._addSocketListener('close', function () {\n            that._removeSocketListeners();\n            that._listenerManager.removeAll();\n        });\n\n        this._socket.close();\n    };\n\n    return AdobeLibraryMessageChannel;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, WebSocket */\n\n/**\n * @class AdobeLibraryWebSocket\n * @classdesc\n * Wrapper for a client side WebSocket. This gives the same interface as the node.js ws package.\n *\n * @ignore\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryWebSocket',['require','exports','module','./AdobeLibraryConfig','./utils/AdobeLibraryListenerManager'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryListenerManager = require('./utils/AdobeLibraryListenerManager');\n\n    // Constructor\n    // Note: this is for internal use by the design library\n    function AdobeLibraryWebSocket(port) {\n        this._socket = new WebSocket('ws://127.0.0.1:' + port + '/?version=' + AdobeLibraryConfig.SHARED_LOCAL_STORAGE_VERSION);\n        this._socket.onopen = this._onSocketOpen.bind(this);\n        this._socket.onclose = this._onSocketClose.bind(this);\n        this._socket.onmessage = this._onSocketMessage.bind(this);\n        this._socket.onerror = this._onSocketError.bind(this);\n\n        this._listenerManager = new AdobeLibraryListenerManager(['open', 'close', 'message', 'error']);\n    }\n\n    /**\n        WebSockets for notifications\n    **/\n\n    AdobeLibraryWebSocket.prototype._onSocketOpen = function (evt) {\n        this._listenerManager.notify('open');\n    };\n\n    AdobeLibraryWebSocket.prototype._onSocketClose = function (evt) {\n        this._listenerManager.notify('close');\n    };\n\n    AdobeLibraryWebSocket.prototype._onSocketMessage = function (evt) {\n        this._listenerManager.notify('message', [evt.data]);\n    };\n\n    AdobeLibraryWebSocket.prototype._onSocketError = function (evt) {\n        this._listenerManager.notify('error', [evt]);\n    };\n\n    /**\n        Public API\n    **/\n\n    AdobeLibraryWebSocket.prototype.send = function (data) {\n        this._socket.send(data);\n    };\n\n    AdobeLibraryWebSocket.prototype.addListener = function (event, callback) {\n        this._listenerManager.add(event, callback);\n    };\n\n    AdobeLibraryWebSocket.prototype.removeListener = function (event, callback) {\n        this._listenerManager.remove(event, callback);\n    };\n\n    AdobeLibraryWebSocket.prototype.close = function () {\n        // Close the underlying socket\n        this._socket.close();\n\n        // Clear notifications\n        this._socket.onopen = undefined;\n        this._socket.onclose = undefined;\n        this._socket.onmessage = undefined;\n        this._socket.onerror = undefined;\n        this._listenerManager.removeAll();\n    };\n\n    return AdobeLibraryWebSocket;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, nodeRequire, GLOBAL, WebSocket */\n\n/**\n    AdobeLibraryStorageInterfaceFS: an implementation of the node.js FS interface, that\n**/\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryStorageInterfaceFS',['require','exports','module','./AdobeLibraryError'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryError = require('./AdobeLibraryError');\n\n    // Node.js FS API, along with whether we support it via this interface\n    var FS_API = {\n        rename:            true,\n        renameSync:        false,\n        ftruncate:         false,\n        ftruncateSync:     false,\n        truncate:          false,\n        truncateSync:      false,\n        chown:             false,\n        chownSync:         false,\n        fchown:            false,\n        fchownSync:        false,\n        lchown:            false,\n        lchownSync:        false,\n        chmod:             false,\n        chmodSync:         false,\n        fchmod:            false,\n        fchmodSync:        false,\n        lchmod:            false,\n        lchmodSync:        false,\n        stat:              true,\n        lstat:             false,\n        fstat:             false,\n        statSync:          false,\n        lstatSync:         false,\n        fstatSync:         false,\n        link:              false,\n        linkSync:          false,\n        symlink:           false,\n        symlinkSync:       false,\n        readlink:          false,\n        readlinkSync:      false,\n        realpath:          false,\n        realpathSync:      false,\n        unlink:            true,\n        unlinkSync:        false,\n        rmdir:             true,\n        rmdirSync:         false,\n        mkdir:             true,\n        mkdirSync:         false,\n        readdir:           true,\n        readdirSync:       false,\n        close:             false,\n        closeSync:         false,\n        open:              false,\n        openSync:          false,\n        utimes:            true,\n        utimesSync:        false,\n        futimes:           false,\n        futimesSync:       false,\n        fsync:             false,\n        fsyncSync:         false,\n        write:             false,\n        writeSync:         false,\n        read:              false,\n        readSync:          false,\n        readFile:          true,\n        readFileSync:      false,\n        writeFile:         true,\n        writeFileSync:     false,\n        appendFile:        false,\n        appendFileSync:    false,\n        watchFile:         false,\n        unwatchFile:       false,\n        watch:             false,\n        exists:            true,\n        existsSync:        false,\n        createReadStream:  false,\n        createWriteStream: false\n    };\n\n    // Utility\n    function wrapCallback(callback) {\n        return function (err, data) {\n            if (callback) {\n                callback(err, data);\n            }\n        };\n    }\n\n\n    /**\n        FS Interface\n    **/\n\n    function AdobeLibraryStorageInterfaceFS(storageInterface) {\n        this._storageInterface = storageInterface;\n    }\n\n    AdobeLibraryStorageInterfaceFS.prototype._fsCall = function (method, args, _callback) {\n        var callback = wrapCallback(_callback);\n\n        var requestData = {\n            method: method,\n            args: args\n        };\n\n        this._storageInterface._channel.call('fscall', requestData, function (responseData) {\n            callback.apply(null, responseData);\n        });\n    };\n\n    AdobeLibraryStorageInterfaceFS.prototype._pipeCall = function (path, options, writeStream, _callback) {\n        var callback = wrapCallback(_callback);\n\n        var requestData = {\n            readStream: {\n                path: path,\n                options: options\n            },\n            writeStream: writeStream\n        };\n\n        this._storageInterface._channel.call('fspipe', requestData, callback);\n    };\n\n\n\n    /**\n        Public APIs\n    **/\n\n    // Wrapping allowed FS API calls\n    Object.keys(FS_API).forEach(function (method) {\n        if (FS_API[method]) {\n            // Allowed\n\n            AdobeLibraryStorageInterfaceFS.prototype[method] = function () {\n                var args = Array.prototype.slice.call(arguments);\n                var callback;\n                if (typeof args[args.length - 1] === 'function') {\n                    callback = args.pop();\n                }\n                this._fsCall(method, args, callback);\n            };\n\n        } else {\n            // Not Allowed\n\n            AdobeLibraryStorageInterfaceFS.prototype[method] = function () {\n                var error = new AdobeLibraryError(AdobeLibraryError.NOT_IMPLEMENTED, method + ' is not implemented in shared local storage');\n\n                var callback = arguments[arguments.length - 1];\n                if (typeof callback === 'function') {\n                    callback(error);\n                    return;\n                }\n\n                throw error;\n            };\n        }\n    });\n\n    // IMPORTANT: We only support a limited subset of the read/write stream operations, so we can support\n    // file copying. This is not supposed to be a generic implementation - only in the context of the specific\n    // libraries API and DCX code.\n\n    // Read stream: This assumes the only thing you'll do is add some event listeners, and call pipe()\n    AdobeLibraryStorageInterfaceFS.prototype.createReadStream = function (path, options) {\n        var that = this;\n\n        var readStream = {};\n        readStream.on = function (event, callback) {\n            readStream[event] = callback;\n        };\n        readStream.pipe = function (writeStream, options) {\n            that._pipeCall(path, options, writeStream, function (responseData) {\n                if (readStream[responseData.event]) {\n                    readStream[responseData.event].apply(null, responseData.args);\n                }\n            });\n        };\n\n        return readStream;\n    };\n\n    // Write stream: This only supports being passed in as a parameter to readStream\n    AdobeLibraryStorageInterfaceFS.prototype.createWriteStream = function (path, options) {\n        return {\n            path: path,\n            options: options\n        };\n    };\n\n\n    return AdobeLibraryStorageInterfaceFS;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console, nodeRequire, GLOBAL, WebSocket */\n\n/**\n    AdobeLibraryStorageInterface: connecting to local server for shared local storage, if configured for this\n**/\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryStorageInterface',['require','exports','module','./components/dcx-js/src/AdobeDCXComposite','./components/dcx-js/src/AdobeDCXBranch','./AdobeLibraryCollection','./AdobeLibraryPublicCollection','./AdobeLibraryComposite','./AdobeLibraryError','./AdobeLibraryConfig','./AdobeLibraryServices','./AdobeLibraryMessageChannel','./AdobeLibraryWebSocket','./AdobeLibraryStorageInterfaceFS','./utils/AdobeLibraryAsyncJoin','./utils/AdobeLibraryManifestUtils','./utils/AdobeLibraryRenditionUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeDCXComposite = require('./components/dcx-js/src/AdobeDCXComposite');\n    var AdobeDCXBranch = require('./components/dcx-js/src/AdobeDCXBranch');\n\n    var AdobeLibraryCollection = require('./AdobeLibraryCollection');\n    var AdobeLibraryPublicCollection = require('./AdobeLibraryPublicCollection');\n    var AdobeLibraryComposite = require('./AdobeLibraryComposite');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n\n    var AdobeLibraryMessageChannel = require('./AdobeLibraryMessageChannel');\n    var AdobeLibraryWebSocket = require('./AdobeLibraryWebSocket');\n    var AdobeLibraryStorageInterfaceFS = require('./AdobeLibraryStorageInterfaceFS');\n    var AdobeLibraryAsyncJoin = require('./utils/AdobeLibraryAsyncJoin');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n    var AdobeLibraryRenditionUtils = require('./utils/AdobeLibraryRenditionUtils');\n\n    // Constructor\n    function AdobeLibraryStorageInterface(collectionManager) {\n        this._collectionManager = collectionManager;\n\n        this._acceptPushedBranchListeners = [];\n        this._downloadRenditionListeners = [];\n        this._rootListeners = [];\n\n        this._baseBranches = {};\n        this._pendingSetRenditionCache = {};\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            this._connect();\n\n            // If we're not in a node.js environment, set our own version of the filesystem\n            this.fs = new AdobeLibraryStorageInterfaceFS(this);\n            if (!AdobeLibraryServices.hasFileSystem()) {\n                AdobeLibraryServices.setFileSystem(this.fs);\n            }\n        }\n    }\n\n    // Utility\n    function wrapCallback(callback) {\n        return function (err, data) {\n            if (callback) {\n                callback(err, data);\n            }\n        };\n    }\n\n    /**\n        Utilities\n    **/\n\n    AdobeLibraryStorageInterface.prototype._getBase = function (id) {\n        var info = this._baseBranches[id];\n        return info && info.base;\n    };\n\n    AdobeLibraryStorageInterface.prototype._setBase = function (id, base) {\n        this._baseBranches[id] = this._baseBranches[id] || {};\n        this._baseBranches[id].base = base;\n    };\n\n    /**\n        Connecting to the storage service\n    **/\n\n    AdobeLibraryStorageInterface.prototype._getServicePort = function (callback) {\n        var requestType = AdobeLibraryConfig.VULCAN_PREFIX + AdobeLibraryConfig.VULCAN_QUERY_REQUEST;\n        var responseType = AdobeLibraryConfig.VULCAN_PREFIX + AdobeLibraryConfig.VULCAN_QUERY_RESPONSE;\n\n        function onResponse(responsePayload) {\n            var data;\n            try {\n                data = JSON.parse(responsePayload);\n            } catch (ignore) {\n            }\n\n            if (!data) { callback(); return; }\n\n            callback(data.port);\n        }\n\n        if (AdobeLibraryServices.hasCEPVulcan()) {\n            var VulcanInterface = AdobeLibraryServices.getVulcanInterface();\n            var VulcanMessage = AdobeLibraryServices.getVulcanMessage();\n\n            // Listen for the response\n            var timeout;\n            var responseHandler = function (message) {\n                VulcanInterface.removeMessageListener(responseType, responseHandler);\n                clearTimeout(timeout);\n\n                if (!message) { callback(); return; }\n\n                onResponse(VulcanInterface.getPayload(message));\n            };\n            VulcanInterface.addMessageListener(responseType, responseHandler);\n            timeout = setTimeout(responseHandler, 3000);\n\n            // Send the request\n            var request = new VulcanMessage(requestType);\n            request.setPayload('');\n            VulcanInterface.dispatchMessage(request);\n\n        } else if (AdobeLibraryServices.vulcanCall) {\n            AdobeLibraryServices.vulcanCall(requestType, '', responseType, onResponse);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype._connectToPort = function (port) {\n        if (this._isConnected || !port) {\n            // Don't reconnect if already connected, or the port is invalid\n            return;\n        }\n\n        try {\n            var socket = new AdobeLibraryWebSocket(port);\n            this._channel = new AdobeLibraryMessageChannel(socket);\n            this._isConnected = true;\n        } catch (ignore) {\n        }\n\n        if (!this._isConnected) {\n            // Something went wrong connecting\n            return;\n        }\n\n        // Register listeners\n        this._channel.addListener('environmentinfo',      this._onEnvironmentInfo.bind(this));\n        this._channel.addListener('collectionadded',      this._onCollectionAdded.bind(this));\n        this._channel.addListener('collectionremoved',    this._onCollectionRemoved.bind(this));\n        this._channel.addListener('syncstate',            this._onSyncState.bind(this));\n        this._channel.addListener('librarychange',        this._onLibraryChange.bind(this));\n        this._channel.addListener('renditioncachechange', this._onRenditionCacheChange.bind(this));\n        this._channel.addListener('librarydeleted',       this._onLibraryDeleted.bind(this));\n\n        // Send configuration options when the channel connects\n        this._channel.onOpen(this._sendConfiguration.bind(this));\n\n        // Handle broken connection\n        this._channel.onClose(this._onDisconnect.bind(this));\n    };\n\n    AdobeLibraryStorageInterface.prototype._connect = function () {\n        this._getServicePort(this._connectToPort.bind(this));\n    };\n\n    AdobeLibraryStorageInterface.prototype.shutdown = function () {\n        this._collectionManager.removeAllLibraryCollections();\n        if (this._isConnected) {\n            this._onDisconnect();\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype._onDisconnect = function () {\n        this._isConnected = false;\n        this._collectionManager.removeAllLibraryCollections();\n\n        // Shutdown the channel\n        this._channel.shutdown();\n        this._channel = undefined;\n    };\n\n    AdobeLibraryStorageInterface.prototype._sendConfiguration = function () {\n        this._channel.send('configure', {\n            CLIENT_DESCRIPTION: AdobeLibraryConfig.CLIENT_DESCRIPTION,\n            RENDITION_SIZES: AdobeLibraryConfig.RENDITION_SIZES,\n            FULL_RENDITION_CONFIG: AdobeLibraryConfig.FULL_RENDITION_CONFIG,\n            DEFAULT_LIBRARY_NAME: AdobeLibraryConfig.DEFAULT_LIBRARY_NAME,\n            SHARED_LOCAL_STORAGE_ANALYTICS: AdobeLibraryConfig.SHARED_LOCAL_STORAGE_ANALYTICS\n        });\n    };\n\n    /**\n        Listening for events from the storage service\n    **/\n\n    AdobeLibraryStorageInterface.prototype._onEnvironmentInfo = function (message) {\n        this._serviceInfo = message;\n\n        if (message.whitelistedDomains) {\n            AdobeLibraryConfig.WHITELISTED_DOMAINS = message.whitelistedDomains;\n        }\n\n        // We need to notify the sync listeners of all the collections, because syncing may have been turned on/off\n        this._collectionManager._collections.forEach(function (libraryCollection) {\n            libraryCollection._listenerManager.notify('sync');\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype._onCollectionAdded = function (message) {\n        var that = this;\n\n        // Set the root directory (this clears the library collection if there is one)\n        AdobeLibraryConfig.ROOT_DIR = message.rootDir;\n\n        // Load the collections and libraries\n        var asyncJoin = new AdobeLibraryAsyncJoin();\n        var libraryCollection;\n        var options = {\n            CLOUD_ID: message.cloudId,\n            CLOUD_INFO: message.cloudInfo,\n            STORAGE_HOSTNAME: message.storageHost\n        };\n        if (message.isPublic) {\n            libraryCollection = new AdobeLibraryPublicCollection(options);\n        } else {\n            options.USER_ID = message.userId;\n            libraryCollection = new AdobeLibraryCollection(options);\n        }\n\n        message.libraries.forEach(function (library) {\n            asyncJoin.addOperation(that.loadExistingLibrary, [libraryCollection, library.id, library.path, library.manifest, library.deletedFromServer, library.renditionCache], that);\n        });\n\n        asyncJoin.run(function () {\n            that._collectionManager.addLibraryCollection(libraryCollection);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype._getLibraryCollection = function (message) {\n        if (message.isPublic) {\n            return this._collectionManager.getPublicLibraryCollection(message.cloudId);\n        }\n\n        // Private cloud\n        return this._collectionManager.getLibraryCollection(message.userId, message.cloudId);\n    };\n\n    AdobeLibraryStorageInterface.prototype._onCollectionRemoved = function (message) {\n        var libraryCollection = this._getLibraryCollection(message);\n        if (libraryCollection) {\n            this._collectionManager.removeLibraryCollection(libraryCollection);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype._onSyncState = function (message) {\n        var libraryCollection = this._getLibraryCollection(message);\n\n        if (!libraryCollection) {\n            return;\n        }\n\n        libraryCollection._syncState = message.state;\n        libraryCollection._syncProgress = message.progress;\n        libraryCollection._syncProgressMap = message.progressMap;\n        libraryCollection._newLibraryProgress = message.newLibraryProgress;\n        libraryCollection._initialSyncInProgress = message.initialSyncInProgress;\n        libraryCollection._syncErrors = [];\n        message.errors.forEach(function (data) {\n            libraryCollection._syncErrors.push(new AdobeLibraryError(data.code, data.message, data.libraryId));\n        });\n        message.libraryStates.forEach(function (data) {\n            var library = libraryCollection.getLibraryById(data.id);\n            if (library) {\n                library._syncState = data.state;\n            }\n        });\n        libraryCollection._listenerManager.notify('sync');\n    };\n\n    AdobeLibraryStorageInterface.prototype._onLibraryChange = function (message) {\n        var libraryCollection = this._getLibraryCollection(message);\n\n        if (!libraryCollection) {\n            return;\n        }\n\n        var library = libraryCollection.getLibraryById(message.id);\n        if (library) {\n            library._deletedFromServer = message.deletedFromServer;\n\n            // Set the rendition cache both before and after updating the library - that's so that we\n            // set it for any new elements that don't exist before we do the merge\n            message.renditionCache = message.renditionCache || {};\n            library._setRenditionCache(message.renditionCache);\n            this.updateExistingLibrary(libraryCollection, library, message.manifest, undefined, function () {\n                library._setRenditionCache(message.renditionCache);\n            });\n        } else {\n            this.loadExistingLibrary(libraryCollection, message.id, message.path, message.manifest, message.deletedFromServer, message.renditionCache);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype._onRenditionCacheChange = function (message) {\n        var libraryCollection = this._getLibraryCollection(message);\n        var library = libraryCollection && libraryCollection.getLibraryById(message.id);\n        var element = library && library.getElementById(message.elementId);\n\n        if (element && message.renditionCache) {\n            element._renditionCache = message.renditionCache;\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype._onLibraryDeleted = function (message) {\n        var libraryCollection = this._getLibraryCollection(message);\n\n        if (!libraryCollection) {\n            return;\n        }\n\n        this._deleteLibrary(libraryCollection, message.id);\n    };\n\n\n    /**\n        Public APIs\n    **/\n\n    /**\n        Initialisation and connection management\n    **/\n\n    AdobeLibraryStorageInterface.prototype.isConnected = function () {\n        return this._isConnected;\n    };\n\n    AdobeLibraryStorageInterface.prototype.reconnect = function () {\n        if (!this._isConnected) {\n            this._connect();\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype.getServiceInfo = function () {\n        if (this._serviceInfo) {\n            return {\n                updateRequired: this._serviceInfo.updateRequired,\n                version: this._serviceInfo.codeVersion,\n                buildNumber: this._serviceInfo.buildNumber,\n                apiVersion: this._serviceInfo.version,\n                environment: this._serviceInfo.environment,\n                syncingEnabled: this._serviceInfo.syncingEnabled\n            };\n        }\n\n        return undefined;\n    };\n\n    AdobeLibraryStorageInterface.prototype.updateConfiguration = function () {\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE && this._isConnected && this._channel) {\n            this._sendConfiguration();\n        }\n    };\n\n    /**\n        Sync-related messages\n    **/\n\n    AdobeLibraryStorageInterface.prototype.sync = function (libraryCollection) {\n        this._channel.send('sync', {\n            isPublic: libraryCollection.isPublic,\n            userId: libraryCollection.userId,\n            cloudId: libraryCollection.cloudId\n        });\n    };\n\n\n    /**\n        Committing manifest\n    **/\n\n    AdobeLibraryStorageInterface.prototype.commitManifest = function (library, callback) {\n        var that = this;\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n\n            var currentManifest = library._dcxBranch.localData;\n\n            var pendingSetRenditionCache = this._pendingSetRenditionCache[library.id] || {data: [], callbacks: []};\n            delete this._pendingSetRenditionCache[library.id];\n\n            var requestData = {\n                isPublic: library.collection.isPublic,\n                userId: library.collection.userId,\n                cloudId: library.collection.cloudId,\n                id: library.id,\n                current: currentManifest,\n                base: this._getBase(library.id),\n                renditions: pendingSetRenditionCache.data\n            };\n\n            AdobeLibraryServices.log('Start commit');\n            this._channel.call('commit', requestData, function (responseData) {\n                AdobeLibraryServices.log('Finish commit: ' + (responseData.success ? 'success' : 'fail'));\n\n                if (responseData.success) {\n                    // The new base should be the data we just sent (since the library localData could have changed in the meantime)\n                    AdobeLibraryServices.log('Update base after commit');\n                    that._setBase(library.id, currentManifest);\n\n                    if (responseData.renditions) {\n                        responseData.renditions.forEach(function (newPath, index) {\n                            if (!newPath) {\n                                return;\n                            }\n\n                            var newFile = newPath.split('/').pop();\n\n                            // Update the rendition cache with the new path, so we don't need to call getRendition next time!\n                            var data = pendingSetRenditionCache.data[index];\n                            var element = library.getElementById(data.element);\n                            if (element) {\n                                element._renditionCache = element._renditionCache || {};\n                                element._renditionCache[data.size] = newFile;\n                            }\n\n                            var setRenditionCallback = pendingSetRenditionCache.callbacks[index];\n                            if (setRenditionCallback) {\n                                setRenditionCallback(null, newPath);\n                            }\n                        });\n                    }\n\n                } else {\n                    // The commit failed: because there were changed we haven't yet integrated\n                    // Restore the pending set renditions since they didn't get applied\n                    that._pendingSetRenditionCache[library.id] = pendingSetRenditionCache;\n\n                    // Schedule up a library update, with the new data\n                    library._waitForCommit(function () {\n                        // Since the merge code may have to do some copying, we need to notify the storage process as though we're going to write\n                        // some components. This is so that the storage process turns off GC, just to be on the same side - otherwise it may end up\n                        // deleting some components that we copy during the merge.\n                        that.notifyStartWrite(library, [], function () {\n                            library._deletedFromServer = responseData.deletedFromServer;\n                            that.updateExistingLibrary(library.collection, library, responseData.manifest, undefined, function () {\n                                // Try the commit again, after merging in the new data from the storage service\n                                library._commit(true, true);\n                            });\n                        });\n                    });\n                }\n\n                callback();\n            });\n\n        } else {\n            // Default behaviour if no shared storage - write directly to disk\n            library._dcxComposite.commitChanges(callback);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype.resolvePullWithBranch = function (library, branch, originalPulledBranchData, isLocalMerge, callback) {\n        AdobeLibraryServices.log('resolvePullWithBranch');\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            // In a client, this means we just merged changes from the library service. The base should be\n            // whatever we pulled from the service.\n            library._dcxComposite._current = branch;\n            this._setBase(library.id, originalPulledBranchData);\n            callback();\n\n        } else if (isLocalMerge) {\n            library._dcxComposite._current = branch;\n            callback();\n\n        } else {\n            library._dcxComposite.resolvePullWithBranch(branch, callback);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype.acceptPush = function (library, callback) {\n        var that = this;\n\n        library._dcxComposite.acceptPush(function (err) {\n\n            // Notify listeners of the pushed branch being accepted. This is used by the server, so it can\n            // send the etag data to the clients\n            that._acceptPushedBranchListeners.forEach(function (callback) {\n                callback(library);\n            });\n\n            callback(err);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype.onAcceptPushedBranch = function (callback) {\n        this._acceptPushedBranchListeners.push(callback);\n    };\n\n    AdobeLibraryStorageInterface.prototype.removeOnAcceptPushedBranchListeners = function () {\n        this._acceptPushedBranchListeners = [];\n    };\n\n    /**\n        Handling notification of deleted library\n    **/\n\n    AdobeLibraryStorageInterface.prototype._deleteLibrary = function (libraryCollection, id, callback) {\n        AdobeLibraryServices.log('deleteLibrary');\n\n        var library = libraryCollection.getLibraryById(id);\n        if (library) {\n            var index = libraryCollection._libraries.indexOf(library);\n            if (index !== -1) {\n                libraryCollection._libraries.splice(index, 1);\n                delete libraryCollection._libraryIdMap[library.id];\n            }\n            library._markDeletedLocally(true);\n\n            libraryCollection._notifyChange(true);\n        }\n    };\n\n    /**\n        Loading/updating manifest\n    **/\n\n    AdobeLibraryStorageInterface.prototype._loadBranch = function (composite, manifestData, readOnly) {\n        var branch;\n\n        try {\n            // Hack: looking at DCX internals to load a branch from data\n            branch = new AdobeDCXBranch(undefined, readOnly).parse(manifestData);\n            branch._localStorage = composite._localStorage;\n        } catch (ignore) {\n        }\n\n        return branch;\n    };\n\n    AdobeLibraryStorageInterface.prototype._addLibrary = function (libraryCollection, id, path, manifest, callback) {\n        path = path || libraryCollection._getCompositeDir(id);\n\n        var composite = new AdobeDCXComposite(null, null, path, null, null, {preserveFileExtensions: true});\n\n        var branch = this._loadBranch(composite, manifest, false);\n\n        if (!branch) {\n            callback(new AdobeLibraryError(AdobeLibraryError.CORRUPTED_LIBRARY, 'Library corrupted in local storage', id));\n            return;\n        }\n\n        if (branch.compositeState === 'pendingDelete') {\n            // Abort, since trying to add a library that was already deleted\n            callback(null);\n            return;\n        }\n\n        composite._current = branch;\n\n        // Set the original manifest as base, so we can use it when merging\n        this._setBase(id, manifest);\n\n        // Create the library and add it to the collection\n        var library = new AdobeLibraryComposite(libraryCollection, composite);\n        if (libraryCollection.isPublic) {\n            // Fake out the library id to be the public id;\n            library._publicId = id;\n            library._writable = false;\n        }\n        libraryCollection._libraries.push(library);\n        libraryCollection._libraryIdMap[library.id] = library;\n\n        // Notify listeners\n        libraryCollection._notifyChange(true);\n\n        callback(null, library);\n    };\n\n    AdobeLibraryStorageInterface.prototype.createNewLibrary = function (libraryCollection, id, manifest, _callback) {\n        var callback = wrapCallback(_callback);\n\n        AdobeLibraryServices.log('createNewLibrary');\n        this._addLibrary(libraryCollection, id, undefined, manifest, function (err, library) {\n            if (err || !library) { callback(err); return; }\n\n            // Save to disk, and push to server\n            library._commit(false, true);\n            library._waitForCommit(callback);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype.loadExistingLibrary = function (libraryCollection, id, path, manifest, deletedFromServer, renditionCache, _callback) {\n        var callback = wrapCallback(_callback);\n\n        AdobeLibraryServices.log('loadExistingLibrary');\n        this._addLibrary(libraryCollection, id, undefined, manifest, function (err, library) {\n            if (err || !library) { callback(err); return; }\n\n            // Set additional state\n            library._deletedFromServer = deletedFromServer;\n            if (renditionCache) {\n                library._setRenditionCache(renditionCache);\n            }\n            callback(null, library);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype.updateExistingLibrary = function (libraryCollection, library, currentManifest, baseManifest, _callback) {\n        var that = this;\n        var callback = wrapCallback(_callback);\n\n        // Don't do anything if nothing really changed\n        if (AdobeLibraryManifestUtils.areManifestsEqual(library._dcxBranch.localData, currentManifest)) {\n            AdobeLibraryServices.log('updateExistingLibrary: already up-to-date');\n            callback();\n            return;\n        }\n\n        AdobeLibraryServices.log('updateExistingLibrary: changes to update');\n        var current = this._loadBranch(library._dcxComposite, currentManifest, false);\n\n        if (!current) {\n            callback(new AdobeLibraryError(AdobeLibraryError.CORRUPTED_LIBRARY, 'Invalid manifest', library.id));\n            return;\n        }\n\n        if (current.compositeState === 'pendingDelete') {\n            // Special case for delete - need to remove the library\n            // Note: call _doRemoveLibrary so we don't send analytics\n            libraryCollection._doRemoveLibrary(library);\n            callback();\n\n        } else {\n            library._waitForCommit(function () {\n\n                if (baseManifest) {\n                    // Check again that it's still a fast-forward merge. There's a small chance of a race condition where we could have\n                    // been in the middle of merging a pull at the time.\n                    if (!AdobeLibraryManifestUtils.areManifestsEqual(library._dcxBranch.localData, baseManifest)) {\n                        AdobeLibraryServices.log('Commit aborting: something changed and it\\'s no longer a fast-forward');\n                        callback(true); // An error: causes commit to fail\n                        return;\n                    }\n                } else {\n                    baseManifest = that._getBase(library.id);\n                }\n                var base = that._loadBranch(library._dcxComposite, baseManifest, true) || current;\n\n                AdobeLibraryServices.log('updateExistingLibrary: base ' + base.changeCount + ' -> updated ' + current.changeCount);\n                library._mergeAndSwitchToBranch(current, base, function () {\n                    AdobeLibraryServices.log('updateExistingLibrary: finished merge');\n\n                    if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n                        // Save to disk and push to server\n                        library._commit(false, true);\n                        library._waitForCommit(callback);\n\n                    } else {\n                        callback(null);\n                    }\n                });\n            });\n        }\n    };\n\n    /**\n        Rendition Cache\n    **/\n\n    AdobeLibraryStorageInterface.prototype.setRenditionCache = function (element, size, path, callback) {\n        var pendingSetRenditionCache = this._pendingSetRenditionCache[element.library.id];\n        var updated = AdobeLibraryRenditionUtils.addToPendingSetRenditionCache(pendingSetRenditionCache, element, size, path, callback);\n        this._pendingSetRenditionCache[element.library.id] = updated;\n    };\n\n    AdobeLibraryStorageInterface.prototype.getRenditionPath = function (element, size, _callback, numRetries) {\n        numRetries = numRetries || 0;\n\n        var that = this;\n        var callback = wrapCallback(_callback);\n\n        // First, see if we have a rendition that's already cached\n        var renditionCachePath = element._lookupRenditionPath(size || 'full');\n        if (renditionCachePath) {\n            callback(null, renditionCachePath);\n            return;\n        }\n\n        // Otherwise, we need to ask the CCLibrary process for the rendition\n        var requestData = {\n            isPublic: element.library.collection.isPublic,\n            userId: element.library.collection.userId,\n            cloudId: element.library.collection.cloudId,\n            id: element.library.id,\n            element: element.id,\n            size: size\n        };\n\n        AdobeLibraryServices.log('Get rendition path from CCLibrary process');\n        this._channel.call('getrenditionpath', requestData, function (responseData) {\n            if (!responseData && numRetries < AdobeLibraryConfig.LOCAL_RENDITION_MAX_RETRIES) {\n                AdobeLibraryServices.log('getrenditionpath: rendition not found');\n\n                // There's a possible race condition that we could ask for a rendition when adding a new\n                // element, before the commit succeeds - in this case, we allow ourselves to retry\n                setTimeout(function () {\n                    that.getRenditionPath(element, size, _callback, numRetries + 1);\n                }, AdobeLibraryConfig.LOCAL_RENDITION_RETRY_INTERVAL);\n                return;\n            }\n\n            callback(null, responseData);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype.notifyDownloadRendition = function (element) {\n        this._downloadRenditionListeners.forEach(function (callback) {\n            callback(element);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype.onDownloadRendition = function (callback) {\n        this._downloadRenditionListeners.push(callback);\n    };\n\n    AdobeLibraryStorageInterface.prototype.removeOnDownloadRenditionListeners = function () {\n        this._downloadRenditionCacheListeners = [];\n    };\n\n\n    /**\n        GC Control\n    **/\n\n    AdobeLibraryStorageInterface.prototype.notifyStartWrite = function (library, dependentLibraries, _callback) {\n        var callback = wrapCallback(_callback);\n\n        if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            callback(null);\n            return;\n        }\n\n        var requestData = {\n            userId: library.collection.userId,\n            cloudId: library.collection.cloudId,\n            id: library.id,\n            dependencies: []\n        };\n\n        dependentLibraries.forEach(function (depLibrary) {\n            requestData.dependencies.push({\n                userId: depLibrary.collection.userId,\n                cloudId: depLibrary.collection.cloudId,\n                id: depLibrary.id\n            });\n        });\n\n        this._channel.call('startcomponentwrite', requestData, function () {\n            callback(null);\n        });\n    };\n\n\n    /**\n        Public Libraries\n    **/\n\n    AdobeLibraryStorageInterface.prototype.loadPublicLibrary = function (libraryCollection, id, _callback) {\n        var callback = wrapCallback(_callback);\n\n        var requestData = {\n            isPublic: libraryCollection.isPublic,\n            cloudId: libraryCollection.cloudId,\n            id: id\n        };\n\n        this._channel.call('loadpubliclibrary', requestData, function () {\n            callback(null);\n        });\n    };\n\n    AdobeLibraryStorageInterface.prototype.unloadPublicLibrary = function (library, _callback) {\n        var callback = wrapCallback(_callback);\n\n        var requestData = {\n            isPublic: library.collection.isPublic,\n            cloudId: library.collection.cloudId,\n            id: library.id\n        };\n\n        this._channel.call('unloadpubliclibrary', requestData, function () {\n            callback(null);\n        });\n    };\n\n\n    /**\n        Downloading assets\n    **/\n\n    AdobeLibraryStorageInterface.prototype.getAssetFromURL = function (collection, url, headers, tempDir, callback) {\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n\n            var requestData = {\n                isPublic: collection.isPublic,\n                userId: collection.userId,\n                cloudId: collection.cloudId,\n                url: url,\n                headers: headers,\n                tempDir: tempDir\n            };\n\n            this._channel.call('downloadfile', requestData, function (data) {\n                callback(data.err, data.tempFilePath, data.etag, {headers: data.responseHeaders});\n            });\n\n        } else {\n            collection._syncManager.getAssetFromURL(url, headers, tempDir, callback);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype.doHeadRequestOfURL = function (collection, url, callback) {\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            // Shared local storage isn't supported for now\n            callback(null);\n        } else {\n            collection._syncManager.doHeadRequestOfURL(url, callback);\n        }\n    };\n\n    AdobeLibraryStorageInterface.prototype.downloadExternalLink = function (representation, callback) {\n\n        var requestData = {\n            isPublic: representation.element.library.collection.isPublic,\n            userId: representation.element.library.collection.userId,\n            cloudId: representation.element.library.collection.cloudId,\n            id: representation.element.library.id,\n            element: representation.element.id,\n            representation: representation.id\n        };\n\n        AdobeLibraryServices.log('Download external link from CCLibrary process');\n        this._channel.call('downloadexternallink', requestData, function (data) {\n            callback(data.err, data.path);\n        });\n    };\n\n\n    return AdobeLibraryStorageInterface;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryExternalUtils\n * @classdesc\n * External type utilities for CCLibraries users. This exposes some APIs for converting between file extensions and mime types,\n * finding out what rendition conversions are available, and generating UUIDs.\n *\n * @description\n * This class has only static methods\n *\n * @private\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryExternalUtils',['require','exports','module','./AdobeLibraryServices','./utils/AdobeLibraryMimeTypeUtils','./utils/AdobeLibraryRenditionUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryMimeTypeUtils = require('./utils/AdobeLibraryMimeTypeUtils');\n    var AdobeLibraryRenditionUtils = require('./utils/AdobeLibraryRenditionUtils');\n\n\n    var AdobeLibraryExternalUtils = {};\n\n\n    /**\n     * Get all the file extensions associated with a given mime type.\n     *\n     * @param {String} mimeType A mime type.\n     * @returns {Array.<String>} An array of all the file extensions that could be associated with that mime type.\n     * @memberof AdobeLibraryExternalUtils\n     */\n    AdobeLibraryExternalUtils.mimeTypeToExtensions = function (mimeType) {\n        return AdobeLibraryMimeTypeUtils.getExtensions(mimeType);\n    };\n\n    /**\n     * Get all the mime types associated with a given file extension.\n     *\n     * @param {String} extension A file extension. This should not include the `'.'` (e.g. use `'png'` rather than `'.png'`).\n     * @returns {Array.<String>} An array of all the mime types that could be associated with that extension.\n     * @memberof AdobeLibraryExternalUtils\n     */\n    AdobeLibraryExternalUtils.extensionToMimeTypes = function (extension) {\n        return AdobeLibraryMimeTypeUtils.getMimeTypes(extension);\n    };\n\n    /**\n     * Determine whether we can compute, via the cloud, a PNG rendition from content with the given mime type. This\n     * can be useful when adding a library element, to decide whether you need to add a separate {@link AdobeLibraryRepresentation}\n     * as a thumbnail, or whether it can be automatically generated from the primary representation.\n     *\n     * @param {String} mimeType A mime type.\n     * @returns {Boolean} Whether or not renditions of the given type are supported by shared cloud.\n     * @memberof AdobeLibraryExternalUtils\n     * @see {@link AdobeLibraryElement#getRenditionPath}\n     */\n    AdobeLibraryExternalUtils.canGenerateRenditionFromMimeType = function (mimeType) {\n        return AdobeLibraryRenditionUtils.canComputeRenditionFromMimeType(mimeType);\n    };\n\n    /**\n     * Generate a globally unique identifier.\n     *\n     * @returns {String} A UUID.\n     * @memberof AdobeLibraryExternalUtils\n     */\n    AdobeLibraryExternalUtils.generateUuid = function () {\n        return AdobeLibraryServices.uuid();\n    };\n\n\n    return AdobeLibraryExternalUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint node: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global define, console*/\n\n/**\n * @class AdobeLibraryExternalAnalyticsUtils\n * @classdesc\n * External analytics utilities for CCLibraries users. This allows you to report events involving libraries that occur\n * outside of the CC Libraries API.\n *\n * See {@tutorial analytics_example} for more information.\n *\n * @description\n * This class has only static methods\n *\n * @private\n */\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('AdobeLibraryExternalAnalyticsUtils',['require','exports','module','./AdobeLibraryAnalytics'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryAnalytics = require('./AdobeLibraryAnalytics');\n\n\n    var AdobeLibraryExternalAnalyticsUtils = {};\n\n    /**\n     * Report that a library element is used in some way.\n     *\n     * @param {AdobeLibraryRepresentation} representation The representation being used.\n     * @param {String} opType The type of the operation.\n     * @param {String} details Additional details about the operation.\n     * @memberof AdobeLibraryExternalAnalyticsUtils\n     */\n    AdobeLibraryExternalAnalyticsUtils.reportUseElement = function (representation, opType, details) {\n        AdobeLibraryAnalytics.reportUseElement(representation, opType, details);\n    };\n\n    /**\n     * Report checkout-related analytics for a library element - e.g. licensing/purchasing an Adobe Stock element.\n     *\n     * @param {AdobeLibraryElement} element The element being licensed/purchased.\n     * @param {String} details Additional details about the license/purchase event.\n     * @memberof AdobeLibraryExternalAnalyticsUtils\n     */\n    AdobeLibraryExternalAnalyticsUtils.reportCheckoutElement = function (element, details) {\n        AdobeLibraryAnalytics.reportCheckoutElement(element, details);\n    };\n\n    /**\n     * Report that a Link was created for an element. This is for analytics purposes, the link exists only in the app.\n     *\n     * @param {AdobeLibraryElement} element The element being linked to.\n     * @param {String} opType The type of the operation.\n     * @memberof AdobeLibraryExternalAnalyticsUtils\n     */\n    AdobeLibraryExternalAnalyticsUtils.reportCreateLink = function (element, opType) {\n        AdobeLibraryAnalytics.reportCreateLink(element, opType);\n    };\n\n   /**\n     * Report that the Creative Cloud website has been launched, in order to initialize the sharing of a public link to an element.\n     *\n     * @param {AdobeLibraryElement} element The element being shared.\n     * @memberof AdobeLibraryExternalAnalyticsUtils\n     */\n    AdobeLibraryExternalAnalyticsUtils.reportShareElementLink = function (element) {\n        AdobeLibraryAnalytics.reportShareElementLink(element);\n    };\n\n    /**\n     * Report that the Creative Cloud website has been launched, in order to initialize the sharing of a public link to a library.\n     *\n     * @param {AdobeLibraryComposite} library The library being shared.\n     * @memberof AdobeLibraryExternalAnalyticsUtils\n     */\n    AdobeLibraryExternalAnalyticsUtils.reportShareLibraryLink = function (library) {\n        AdobeLibraryAnalytics.reportShareLibraryLink(library);\n    };\n\n\n    return AdobeLibraryExternalAnalyticsUtils;\n\n});\n\n","/*************************************************************************\n*\n* ADOBE CONFIDENTIAL\n* ___________________\n*\n*  Copyright 2014 Adobe Systems Incorporated\n*  All Rights Reserved.\n*\n* NOTICE:  All information contained herein is, and remains\n* the property of Adobe Systems Incorporated and its suppliers,\n* if any.  The intellectual and technical concepts contained\n* herein are proprietary to Adobe Systems Incorporated and its\n* suppliers and are protected by trade secret or copyright law.\n* Dissemination of this information or reproduction of this material\n* is strictly forbidden unless prior written permission is obtained\n* from Adobe Systems Incorporated.\n**************************************************************************/\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, unparam: true */\n/*global node: true, define, require, module, console */\n\n/**\n * The main entry point for the Creative Cloud Libraries API. This module is exported\n * as a requireJS module by the library, or can be included in a node.js environment\n * with `require('/path/to/main.js')`.\n *\n * This module provides methods for configuring and initialising the API, and for\n * getting hold of an {@link AdobeLibraryCollection} object for the logged-in user.\n *\n * @namespace CCLibraries\n */\n\n/**\n    AdobePatentID=\"P5086-US\"\n    AdobePatentID=\"P5087-US\"\n**/\n\n// Support either node.js or in the browser\n/* istanbul ignore else */\nif (typeof define !== 'function') { var define = require('amdefine')(module); }\n\ndefine('main',['require','exports','module','./AdobeLibraryServices','./AdobeLibraryConfig','./AdobeLibraryCollection','./AdobeLibraryPublicCollection','./AdobeLibraryCollectionManager','./AdobeLibraryError','./AdobeLibraryStorageInterface','./AdobeLibraryExternalUtils','./AdobeLibraryExternalAnalyticsUtils','./utils/AdobeLibraryFileUtils','./utils/AdobeLibraryManifestUtils'],function (require, exports, module) {\n    'use strict';\n\n    var AdobeLibraryServices = require('./AdobeLibraryServices');\n    var AdobeLibraryConfig = require('./AdobeLibraryConfig');\n    var AdobeLibraryCollection = require('./AdobeLibraryCollection');\n    var AdobeLibraryPublicCollection = require('./AdobeLibraryPublicCollection');\n    var AdobeLibraryCollectionManager = require('./AdobeLibraryCollectionManager');\n    var AdobeLibraryError = require('./AdobeLibraryError');\n    var AdobeLibraryStorageInterface = require('./AdobeLibraryStorageInterface');\n    var AdobeLibraryExternalUtils = require('./AdobeLibraryExternalUtils');\n    var AdobeLibraryExternalAnalyticsUtils = require('./AdobeLibraryExternalAnalyticsUtils');\n\n    var AdobeLibraryFileUtils = require('./utils/AdobeLibraryFileUtils');\n    var AdobeLibraryManifestUtils = require('./utils/AdobeLibraryManifestUtils');\n\n\n    /**\n        Collection manager state\n    **/\n\n    var collectionManager = new AdobeLibraryCollectionManager();\n\n\n    /**\n        Loading state\n    **/\n\n    var loadingState = {};\n\n    // Private:\n    function addLoadCallback(userId, cloudId, callback) {\n        var key = userId + '/' + cloudId;\n        var isLoading = loadingState[key] !== undefined;\n        loadingState[key] = loadingState[key] || [];\n        loadingState[key].push(callback);\n        return isLoading;\n    }\n\n    // Private:\n    function notifyLoadCallbacks(userId, cloudId) {\n        var collection;\n        if (userId === AdobeLibraryConfig.PUBLIC_USER_ID) {\n            collection = collectionManager.getPublicLibraryCollection(cloudId);\n        } else {\n            collection = collectionManager.getLibraryCollection(userId, cloudId);\n        }\n\n        var key = userId + '/' + cloudId;\n        var state = loadingState[key];\n        if (state) {\n            delete loadingState[key]; // Need to do this first\n            state.forEach(function (callback) {\n                callback(null, collection);\n            });\n        }\n    }\n\n\n    /**\n        Global functions\n    **/\n\n    var CCLibraries = {};\n\n    /**\n     * Initialise the Creative Cloud Libraries API\n     *\n     * @param {Object} dependencies\n     *     External services that the API depends on.\n     * @param {Object} [dependencies.analytics]\n     *     An interface for logging analytics about the design library. If provided, we expect `dependencies.analytics.reportEvent` to be a\n     *     function, taking two parameters: an event name, and an properties object (key-value pairs). See {@tutorial analytics_example}.\n     * @param {Function} [dependencies.log]\n     *     A function that we will call with a single string parameter whenever we have something to log. Provide this if you want to get log\n     *     messages from the API, e.g. to log them to a file, or print in the console.\n     * @param {Function} [dependencies.getDisplayName]\n     *     A callback function - we pass you an element and you return the name you're going to display. We attach this to the element as its displayName\n     *     property. This is an optimisation, since we only need to regenerate the display name when something changed.\n     *     See {@link AdobeLibraryElement#displayName}.\n     * @param {Function} [dependencies.vulcanCall]\n     *     A function for performing Vulcan calls. You only need to provide this if (a) you're running in a filesystem environment with the shared\n     *     local storage service, and (b) you don't have the CEP VulcanInterface/VulcanMessage available as global variables. Your function should\n     *     accept 4 parameters: `requestType` (the type of the Vulcan message to send), `requestPayload` (the payload to send with the message),\n     *     `responseType` (the Vulcan message type to listen for, as a response), and `callback` (which you should call with the payload of the response).\n     *\n     * @param {Object} options\n     *     Options to configure the API\n     * @param {Boolean} [options.SHARED_LOCAL_STORAGE]\n     *     Configures the API to connect to a local storage service, rather than storing its own copy of the data on disk. If you have a filesystem, this\n     *     is enabled by default, but you can explicitly turn it off. If you're running in the browser (i.e. you don't have direct filesystem access), then\n     *     the option is false by default, however you can turn it on. Note that because it requires a Websocket connection to localhost, this will only\n     *     work if the web application is hosted locally, because of browser security settings.\n     * @param {String} [options.CLIENT_DESCRIPTION]\n     *     A string describing the client - this will be sent the CCLibrary process if you're using shared local storage, so the process knows which\n     *     clients are connected. This is optional but recommended - you should include the name and version of the product.\n     *     Example for the CC Library panel: `'Libraries Panel (v2.1.9) - ILST 19.0.0 en-US'`\n     * @param {String} [options.ROOT_DIR]\n     *     **fs-only** The root directory to store the design libraries on disk. This should not include the userID - you pass that into\n     *     {@link CCLibraries.loadLibraryCollection}. Note that you should not set this option if the `SHARED_LOCAL_STORAGE` option is enabled.\n     * @param {Array} [options.ELEMENT_TYPE_FILTERS]\n     *     If you want to call {@link AdobeLibraryComposite#getFilteredElements}, you need to specify which element types you want us to explicitly filter.\n     *     If you pass in the parameter `type`, then `type` must be in this list: you can get a filtered array of all the elements whose\n     *     types are not in this list by passing in `'*'`.\n     * @param {Number} [options.POLL_INTERVAL]\n     *     The base interval for polling the server for changes (in minutes). Default is 1 minute. Only applies if you start polling on a library\n     *     collection, by calling {@link AdobeLibraryCollection#startPolling}. This is ignored if the `SHARED_LOCAL_STORAGE` option is enabled.\n     * @param {Boolean} [options.AUTO_START_POLLING=false]\n     *     Set to `true`, if you want to automatically start polling after calling {@link CCLibraries.loadLibraryCollection}. Otherwise, you have to\n     *     manually call {@link AdobeLibraryCollection#startPolling} to turn on polling. This is ignored if the `SHARED_LOCAL_STORAGE` option is enabled.\n     * @param {String} [options.STORAGE_API_KEY]\n     *     This should be the same as the client ID, and it's used by the storage service to identify your app as a client. This is only required if\n     *     the `SHARED_LOCAL_STORAGE` option is disabled.\n     * @param {String} [options.USER_AGENT_HEADER]\n     *     The value of this option is sent as the User-Agent header on all requests made by the API. This is only needed if\n     *     the `SHARED_LOCAL_STORAGE` option is disabled, and you're not running in the browser (which will automatically set the User-Agent header itself).\n     * @param {String} [options.SYNC_POLICY=\"manifestAndComponents\"]\n     *     **fs-only** You can specify `'manifestOnly'` (only download the manifest on a pull), or `'manifestAndComponents'` (download both\n     *     the manifest and all components - i.e. the actual files for element representations). Default is `'manifestAndComponents'`, unless you're\n     *     running in-browser, in which case the only possible sync policy is `'manifestOnly'` (if you set something different, it will be ignored).\n     *     This is ignored if the `SHARED_LOCAL_STORAGE` option is enabled (the shared local storage service will sync everything).\n     * @param {Object} [options.RENDITION_SIZES]\n     *     **fs-only** An object mapping element types to an array of sizes of renditions that will be auto-generated when we sync the library.\n     *     To provide default rendition sizes for element types that are not matched, use the key `'*'`. This is just a performance optimisation to\n     *     ensure that thumbnails are available offline - we can generate any size dynamically, but this requires connectivity.\n     * @param {Object} [options.FULL_RENDITION_CONFIG]\n     *     **fs-only** An object mapping element types to an array of configuration objects that are used to determine whether we prefetch a\n     *     full-size rendition of the element. Each configuration must have an id, and it will override any existing condition with the same id\n     *     (for example, this allows applications to update their own configuration, while not modifying the configuration of other apps).\n     *     Currently, the only supported configuration object is of the form\n     *     `{id: id, condition: 'IF_NO_MATCHING_REPRESENTATION', types: supportedType}`, where `supportedTypes` is an array of mime types. This\n     *     configuration means that a full size rendition of an element will be prefetched if it does not have a representation whose type is\n     *     in the array of supported types. If you don't specify this option, no full-size renditions will be prefetched. Note that regardless\n     *     of this option, you can always fetch full size renditions on demand, by calling {@link AdobeLibraryElement#getRenditionPath} with\n     *     an `undefined` size parameter.\n     * @param {Object} [options.EXTERNAL_LINK_PREFETCH]\n     *     **fs-only** An object mapping element types to a Boolean, that determines whether we should pre-fetch any external links belonging\n     *     to an element of that type. By default, the external links will not be pre-fetched.\n     * @param {String} [options.DEFAULT_LIBRARY_NAME]\n     *     A localised string, to be used as the name of the default library. If you provide this option, the libraries API will automatically\n     *     create a default library with this name, if the user doesn't have any libraries. It attempts this only after a successful sync, so\n     *     it won't create a default library in the case of an error (since we can't know whether the user already has libraries on the server).\n     *     If you don't specify this option, the API will not automatically generate any libraries.\n     * @param {String} [options.PROXY_AUTH]\n     *     Set this to provide username and password for proxy authentication. Should be in the form username:password.\n     *\n     * @throws {AdobeLibraryError.INVALID_PARAMETER|AdobeLibraryError.REQUIRES_FILESYSTEM}\n     * @memberof CCLibraries\n     */\n    CCLibraries.configure = function (dependencies, options) {\n\n        // In-browser environment should not use shared local storage by default (although you can turn it on)\n        if (!AdobeLibraryServices.hasFileSystem() && options.SHARED_LOCAL_STORAGE === undefined) {\n            options.SHARED_LOCAL_STORAGE = false;\n        }\n\n        if (AdobeLibraryServices.hasFileSystem() && !options.ROOT_DIR && options.SHARED_LOCAL_STORAGE === false) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Missing ROOT_DIR option');\n        }\n        if (AdobeLibraryServices.hasFileSystem() && options.ROOT_DIR && options.SHARED_LOCAL_STORAGE !== false) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'ROOT_DIR option doesn\\'t apply when using shared local storage');\n        }\n        if (!AdobeLibraryServices.hasFileSystem() && options.ROOT_DIR) {\n            throw new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'ROOT_DIR option only applies when you have a filesystem');\n        }\n        if (options.SHARED_LOCAL_STORAGE === false && !options.STORAGE_API_KEY) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Missing STORAGE_API_KEY option');\n        }\n        if (options.SHARED_LOCAL_STORAGE !== false && !AdobeLibraryServices.hasCEPVulcan() && !dependencies.vulcanCall) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Shared local storage requires either the CEP VulcanInterface/VulcanMessage as globals, or for you to pass in the vulcanCall dependency');\n        }\n\n        // Strip any trailing slashes from ROOT_DIR\n        if (options.ROOT_DIR) {\n            while (['/', '\\\\'].indexOf(options.ROOT_DIR.substr(-1)) !== -1) {\n                options.ROOT_DIR = options.ROOT_DIR.slice(0, -1);\n            }\n        }\n\n        // Initialise the options\n        // Options must be defined at this point, otherwise we'd have thrown an exception\n        Object.keys(options).forEach(function (key) {\n            AdobeLibraryConfig.setParameter(key, options[key]);\n        });\n\n        // Initialise the services\n        AdobeLibraryServices.analytics = dependencies.analytics;\n        AdobeLibraryServices.vulcanCall = dependencies.vulcanCall;\n        AdobeLibraryServices._log = dependencies.log;\n        AdobeLibraryServices._getDisplayName = dependencies.getDisplayName;\n\n        // Create the storage interface (shutting down an existing one if there is one)\n        if (AdobeLibraryServices.storageInterface) {\n            AdobeLibraryServices.storageInterface.shutdown();\n        }\n        AdobeLibraryServices.storageInterface = new AdobeLibraryStorageInterface(collectionManager);\n\n        // Finished setup\n        AdobeLibraryServices.log('Configure: ' + (AdobeLibraryConfig.SHARED_LOCAL_STORAGE ? '<shared local storage>' : AdobeLibraryConfig.ROOT_DIR));\n    };\n\n    /**\n     * Set a configuration option - this can be called after {@link CCLibraries.configure}, to allow you to reconfigure\n     * the API. See {@link CCLibraries.configure} for a list of all the API options.\n     *\n     * The options `'ROOT_DIR'`, `'SHARED_LOCAL_STORAGE'`, `'ELEMENT_TYPE_FILTERS'`, and `'STORAGE_API_KEY'` cannot be\n     * reconfigured - they can only be specified when calling {@link CCLibraries.configure}.\n     *\n     * @param {String} option The name of the option.\n     * @param {Object} value The value of the option to set (the exact type depends on the option).\n     * @throws {AdobeLibraryError.INVALID_PARAMETER}\n     * @memberof CCLibraries\n     */\n    CCLibraries.setOption = function (option, value) {\n\n        // Certain keys cannot be reconfigured\n        var disallowedKeys = ['ROOT_DIR', 'SHARED_LOCAL_STORAGE', 'ELEMENT_TYPE_FILTERS', 'STORAGE_API_KEY'];\n        if (disallowedKeys.indexOf(option) !== -1) {\n            throw new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Cannot reconfigure ' + option);\n        }\n\n        AdobeLibraryConfig.setParameter(option, value);\n\n        // If we're in a shared local storage environment, we need the configuration to be sent to the service again\n        // Note that if we didn't yet connect to the service, it won't get sent now, because we send the config anyway\n        // when we connect.\n        AdobeLibraryServices.storageInterface.updateConfiguration();\n    };\n\n    /**\n     * Get the currently-loaded library collections.\n     *\n     * @returns {Array.<AdobeLibraryCollection>} The loaded library collections\n     * @memberof CCLibraries\n     */\n    CCLibraries.getLoadedCollections = function () {\n        // Make a copy of the collections array, so users can't modify it\n        return collectionManager.getLoadedCollections().slice(0);\n    };\n\n    /**\n     * Get a loaded library collection with a given user and cloud ID.\n     *\n     * @param {String} userId The user that owns the library collection you're looking for.\n     * This is the value passed in as the `USER_ID` option to {@link CCLibraries.loadLibraryCollection}.\n     * @param {String} cloudId The cloud identifier of the library collection you're looking for.\n     * This is the value passed in as the `CLOUD_ID` option to {@link CCLibraries.loadLibraryCollection}.\n     * @returns {AdobeLibraryCollection} The library collection matching `userId` and `cloudId` (or `undefined` if there is no matching library collection).\n     * @memberof CCLibraries\n     */\n    CCLibraries.getLoadedCollectionById = function (userId, cloudId) {\n        return collectionManager.getLibraryCollection(userId, cloudId);\n    };\n\n    /**\n     * Get a loaded public library collection with a given cloud ID.\n     *\n     * @param {String} cloudId The cloud identifier of the library collection you're looking for.\n     * This is the value passed in as the `CLOUD_ID` option to {@link CCLibraries.loadLibraryCollection}.\n     * @returns {AdobeLibraryPublicCollection} The public library collection matching `cloudId` (or `undefined` if there is no matching public library collection).\n     * @memberof CCLibraries\n     */\n    CCLibraries.getLoadedPublicCollectionById = function (cloudId) {\n        return collectionManager.getPublicLibraryCollection(cloudId);\n    };\n\n    /**\n     * Register a listener for loading and unloading of library collections. The listener gets called whenever the\n     * result of {@link CCLibraries.getLoadedCollections} changes.\n     *\n     * @param {Function} callback This gets called whenever the set of loaded library collections changes.\n     * @memberof CCLibraries\n     */\n    CCLibraries.addLoadedCollectionsListener = function (callback) {\n        collectionManager.addLoadedCollectionsListener(callback);\n    };\n\n    /**\n     * Unregister a listener for changes to the set of loaded library collections.\n     *\n     * @param {Function} callback The callback function that was passed to {@link CCLibraries.addLoadedCollectionsListener}.\n     * @memberof CCLibraries\n     */\n    CCLibraries.removeLoadedCollectionsListener = function (callback) {\n        collectionManager.removeLoadedCollectionsListener(callback);\n    };\n\n    /**\n     * **fs-only** Get the current root directory that the API is using.\n     *\n     * @returns {String} The current root directory being used to store libraries.\n     * @throws {AdobeLibraryError.REQUIRES_FILESYSTEM}\n     * @memberof CCLibraries\n     */\n    CCLibraries.getRootDir = function () {\n        if (!AdobeLibraryServices.hasFileSystem()) {\n            throw new AdobeLibraryError(AdobeLibraryError.REQUIRES_FILESYSTEM, 'ROOT_DIR option only applies when you have a filesystem');\n        }\n\n        return AdobeLibraryConfig.ROOT_DIR;\n    };\n\n    /**\n     * Unload the given {@link AdobeLibraryCollection}. This removes the library collection from the list of loaded collections, and\n     * clears any state from memory (including stopping any syncing/polling).\n     *\n     * You need to call {@link CCLibraries.loadLibraryCollection} again, after calling this.\n     *\n     * @param {AdobeLibraryCollection} libraryCollection The library collection to unload.\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof CCLibraries\n     */\n    CCLibraries.unloadLibraryCollection = function (libraryCollection) {\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'unloadLibraryCollection() not supported with shared local storage');\n        }\n\n        libraryCollection.stopPolling();\n        libraryCollection._removeAllListeners();\n        collectionManager.removeLibraryCollection(libraryCollection);\n    };\n\n    /**\n     * Load the library collection for the given user and SAO (determined by the user id and cloud id you provide). If the user changes, you need\n     * to call {@link CCLibraries.unloadLibraryCollection} to unload the collection, and then call {@link CCLibraries.unloadLibraryCollection} again\n     * for the new user.\n     *\n     * @param {Object} options Options for fetching the library collection.\n     * @param {Function} options.getAccessToken\n     *     A function that we will call when we need to get the access token for the current user, for access to the storage service. This is\n     *     passed a callback, and it should call us back with two parameters - an error (null if no errors), and the access token.\n     * @param {String} options.USER_ID\n     *     **fs-only** The ID of the user whose library collection you wish to load (this should be of the form <guid>@AdobeID). This is used\n     *     to ensure we write state for different users to different directories on disk, so it's not needed in-browser.\n     * @param {String} [options.CLOUD_ID=\"creative_cloud\"]\n     *     **fs-only** The ID of the cloud that the library collection belongs to. By default, this is creative cloud, but it can be a\n     *     different ID in an enterprise environment. This is used to ensure we write state for different SAOs to different directories on\n     *     disk, so it's not needed in-browser.\n     * @param {String} options.STORAGE_HOSTNAME\n     *     The hostname of the storage service. Most of the time, you'll want to set this to the production `'cc-api-storage.adobe.io'`,\n     *     but you can use this parameter to test against the staging environment, or to point at a different cloud (e.g. for CCE).\n     *     Note: Don't include the protocol or port.\n     * @param {Object} [options.CLOUD_INFO]\n     *     Information about the cloud that the collection belongs to, including the name, any endpoint information, whether it is a\n     *     private cloud, etc. This information is just attached to the collection, and will be returned on calling\n     *     {@link AdobeLibraryCollection#cloudInfo}.\n     * @param {String} [options.WAIT_FOR]\n     *     This only applies when running in-browser. It allows you to specify when the library collection is returned. If `WAIT_FOR` isn't\n     *     specified, `loadLibraryCollection` will immediately return an empty library collection, while it syncs the libraries from the server.\n     *     If you specify a library id, the library collection will not be returned until the specified library is downloaded from the\n     *     server, or it's determined that the library doesn't exist on the server. If you specify `'all'`, the library collection will\n     *     not be returned until all libraries have been downloaded from the server.\n     * @param {Function} callback\n     *     This gets called after the library collection is loaded, depending on the `waitFor` criteria.\n     * @param {AdobeLibraryError} callback.err\n     *     The error that occurred, or `null` if success.\n     * @param {AdobeLibraryCollection} callback.libraryCollection\n     *     The library collection object.\n     *\n     * @memberof CCLibraries\n     */\n    CCLibraries.loadLibraryCollection = function (options, callback) {\n\n        if (typeof options === 'function') {\n            callback = options;\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'options argument not specified'));\n            return;\n        }\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'loadLibraryCollection() not supported with shared local storage'));\n            return;\n        }\n\n        if (AdobeLibraryServices.hasFileSystem() && !AdobeLibraryConfig.SHARED_LOCAL_STORAGE && !AdobeLibraryConfig.ROOT_DIR) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'ROOT_DIR not configured. Make sure you call CCLibraries.configure()'));\n            return;\n        }\n\n        // Validate options\n        options = options || {};\n        if (AdobeLibraryServices.hasFileSystem() && !options.USER_ID) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Missing USER_ID option'));\n            return;\n        }\n        options.CLOUD_ID = options.CLOUD_ID || AdobeLibraryConfig.DEFAULT_CLOUD_ID;\n        if (!options.STORAGE_HOSTNAME) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Missing STORAGE_HOSTNAME option'));\n            return;\n        }\n\n        var libraryCollection = collectionManager.getLibraryCollection(options.USER_ID, options.CLOUD_ID);\n\n        var isLoading = addLoadCallback(options.USER_ID, options.CLOUD_ID, callback);\n\n        if (libraryCollection && !isLoading) {\n            notifyLoadCallbacks(options.USER_ID, options.CLOUD_ID);\n            return;\n        }\n\n        if (isLoading) {\n            return;\n        }\n\n        libraryCollection = new AdobeLibraryCollection(options);\n\n        function finishedLoading() {\n            collectionManager.addLibraryCollection(libraryCollection);\n\n            // Start polling if we requested it in the startup options\n            if (AdobeLibraryConfig.AUTO_START_POLLING) {\n                libraryCollection.startPolling();\n            }\n\n            notifyLoadCallbacks(options.USER_ID, options.CLOUD_ID);\n        }\n\n        if (AdobeLibraryServices.hasFileSystem()) {\n            AdobeLibraryFileUtils.doesRootDirExist(libraryCollection, function (err, rootDirExists) {\n                // Should never be an error\n\n                libraryCollection._load(function () {\n                    if (!rootDirExists) {\n                        libraryCollection._setInitialSyncState(true);\n                    }\n                    libraryCollection.sync(function () {\n                        libraryCollection._setInitialSyncState(false);\n                    });\n                    finishedLoading();\n                });\n            });\n\n        } else {\n            // In-browser mode: here we respect the waitFor parameter\n\n            if (options.WAIT_FOR === 'all') {\n                // Wait for all the libraries\n                libraryCollection._setInitialSyncState(true);\n                libraryCollection.sync(function () {\n                    libraryCollection._setInitialSyncState(false);\n                    finishedLoading();\n                });\n\n            } else if (AdobeLibraryManifestUtils.validateLibraryId(options.WAIT_FOR, false)) {\n                // Wait for a particular library to load before returning\n                // (we pass a hint to setInitialSyncState, so that this library gets loaded first)\n                libraryCollection._setInitialSyncState(true, [options.WAIT_FOR]);\n                libraryCollection.sync(function () {\n                    libraryCollection._setInitialSyncState(false);\n                });\n\n                // Let the syncing happen in the background, but return as soon as we find the library we're looking for\n                // (or we finished syncing)\n                var onChange = function () {\n                    if (libraryCollection.syncState !== 'syncing' || libraryCollection._libraryIdMap[options.WAIT_FOR] !== 'pending') {\n                        libraryCollection.removeChangeListener(onChange);\n                        libraryCollection.removeSyncListener(onChange);\n                        finishedLoading();\n                    }\n                };\n\n                libraryCollection.addChangeListener(onChange);\n                libraryCollection.addSyncListener(onChange);\n\n            } else {\n                // Return immediately (syncing in the background - the libraries will gradually come in)\n                libraryCollection._setInitialSyncState(true);\n                libraryCollection.sync(function () {\n                    libraryCollection._setInitialSyncState(false);\n                });\n                finishedLoading();\n            }\n        }\n    };\n\n    /**\n     * Load the public library collection for the given SAO (determined by the cloud id you provide). Unlike {@link CCLibraries.loadLibraryCollection},\n     * this does not require a user ID. A public library collection is a container for libraries that are publicly accessible (i.e. anybody has read-only\n     * access), but you have to explicitly load and unload the public libraries you're interested in. See {@link AdobeLibraryPublicCollection#loadLibrary}\n     * and {@link AdobeLibraryPublicCollection#unloadLibrary}.\n     *\n     * @param {Object} options Options for fetching the library collection.\n     * @param {String} [options.CLOUD_ID=\"creative_cloud\"]\n     *     **fs-only** The ID of the cloud that the library collection belongs to. By default, this is creative cloud, but it can be a\n     *     different ID in an enterprise environment. This is used to ensure we write state for different SAOs to different directories on\n     *     disk, so it's not needed in-browser.\n     * @param {String} options.STORAGE_HOSTNAME\n     *     The hostname of the storage service. Most of the time, you'll want to set this to the production `'cc-api-storage.adobe.io'`,\n     *     but you can use this parameter to test against the staging environment, or to point at a different cloud (e.g. for CCE).\n     *     This can also include a prefix, which is useful in a CCE environment - for example, you can specify `'my.host.com/ccstorage'`,\n     *     and all calls will be made to that host, including the prefix.\n     *     Note: Don't include the protocol or port.\n     * @param {Object} [options.CLOUD_INFO]\n     *     Information about the cloud that the collection belongs to, including the name, any endpoint information, whether it is a\n     *     private cloud, etc. This information is just attached to the collection, and will be returned on calling\n     *     {@link AdobeLibraryPublicCollection#cloudInfo}.\n     * @param {Function} callback\n     *     This gets called after the library collection is loaded.\n     * @param {AdobeLibraryError} callback.err\n     *     The error that occurred, or `null` if success.\n     * @param {AdobeLibraryPublicCollection} callback.libraryCollection\n     *     The public library collection object.\n     *\n     * @memberof CCLibraries\n     */\n    CCLibraries.loadPublicLibraryCollection = function (options, callback) {\n\n        if (typeof options === 'function') {\n            callback = options;\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'options argument not specified'));\n            return;\n        }\n\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            callback(new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'loadPublicLibraryCollection() not supported with shared local storage'));\n            return;\n        }\n\n        if (AdobeLibraryServices.hasFileSystem() && !AdobeLibraryConfig.SHARED_LOCAL_STORAGE && !AdobeLibraryConfig.ROOT_DIR) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'ROOT_DIR not configured. Make sure you call CCLibraries.configure()'));\n            return;\n        }\n\n        // Validate options\n        options = options || {};\n        if (options.USER_ID) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'USER_ID not configurable for a public library collection'));\n            return;\n        }\n        options.CLOUD_ID = options.CLOUD_ID || AdobeLibraryConfig.DEFAULT_CLOUD_ID;\n        if (!options.STORAGE_HOSTNAME) {\n            callback(new AdobeLibraryError(AdobeLibraryError.INVALID_PARAMETER, 'Missing STORAGE_HOSTNAME option'));\n            return;\n        }\n\n        var publicLibraryCollection = collectionManager.getPublicLibraryCollection(options.CLOUD_ID);\n\n        var isLoading = addLoadCallback(AdobeLibraryConfig.PUBLIC_USER_ID, options.CLOUD_ID, callback);\n\n        if (publicLibraryCollection && !isLoading) {\n            notifyLoadCallbacks(AdobeLibraryConfig.PUBLIC_USER_ID, options.CLOUD_ID);\n            return;\n        }\n\n        if (isLoading) {\n            return;\n        }\n\n        publicLibraryCollection = new AdobeLibraryPublicCollection(options);\n\n        function finishedLoading() {\n            collectionManager.addLibraryCollection(publicLibraryCollection);\n\n            // Start polling if we requested it in the startup options\n            if (AdobeLibraryConfig.AUTO_START_POLLING) {\n                publicLibraryCollection.startPolling();\n            }\n\n            notifyLoadCallbacks(AdobeLibraryConfig.PUBLIC_USER_ID, options.CLOUD_ID);\n        }\n\n        if (AdobeLibraryServices.hasFileSystem()) {\n            // We might have some public libraries cached locally, so load them\n            publicLibraryCollection._load(function () {\n                publicLibraryCollection.sync();\n                finishedLoading();\n            });\n\n        } else {\n            // In-browser mode: there's no cached data on disk, so we know that there are no libraries - return immediately\n            finishedLoading();\n        }\n    };\n\n    /**\n     * Test whether the API is connected to the shared local storage service.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is enabled.\n     *\n     * @returns {Boolean} Whether or not the API is connected to the shared local storage service.\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof CCLibraries\n     */\n    CCLibraries.isConnected = function () {\n        if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'isConnected() is only applicable if using shared local storage');\n        }\n\n        return AdobeLibraryServices.storageInterface && AdobeLibraryServices.storageInterface.isConnected();\n    };\n\n    /**\n     * Try to reconnect to the shared local storage service, if the connection was broken.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is enabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof CCLibraries\n     */\n    CCLibraries.reconnect = function () {\n        if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'reconnect() is only applicable if using shared local storage');\n        }\n\n        if (AdobeLibraryServices.storageInterface) {\n            AdobeLibraryServices.storageInterface.reconnect();\n        }\n    };\n\n    /**\n     * Get information about the shared local storage service. This includes the service version, the code version, and the environment\n     * (production/staging).\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is enabled.\n     *\n     * @returns {Object} Key-value properties about the shared local storage service. If we have not yet connected, this will be `undefined`.\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof CCLibraries\n     */\n    CCLibraries.getServiceInfo = function () {\n        if (!AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'getServiceInfo() is only applicable if using shared local storage');\n        }\n\n        return AdobeLibraryServices.storageInterface && AdobeLibraryServices.storageInterface.getServiceInfo();\n    };\n\n    /**\n     * Returns `true` if library syncing is enabled. If syncing is disabled, libraries will not be automatically pushed\n     * when modified, and calling {@link AdobeLibraryCollection#sync} will not do anything.\n     *\n     * @returns {Boolean} Whether or not syncing is enabled.\n     * @memberof CCLibraries\n     */\n    CCLibraries.isSyncingEnabled = function () {\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            var serviceInfo = CCLibraries.getServiceInfo();\n            if (serviceInfo && serviceInfo.syncingEnabled) {\n                return true;\n            }\n            return false;\n        }\n\n        return AdobeLibraryConfig.SYNCING_ENABLED;\n    };\n\n    /**\n     * Turn on library syncing, if it's not already enabled. This causes all loaded library collections to sync.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is not enabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof CCLibraries\n     */\n    CCLibraries.enableSyncing = function () {\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'enableSyncing() not supported with shared local storage');\n        }\n\n        AdobeLibraryConfig.SYNCING_ENABLED = true;\n        CCLibraries.getLoadedCollections().forEach(function (collection) {\n            collection.sync();\n        });\n    };\n\n    /**\n     * Turn off library syncing. Note that if libraries are currently syncing, this will wait for the sync to\n     * complete. No further changes to libraries will be automatically pushed, and no changes will be pulled down\n     * from the server.\n     *\n     * This is only supported if the `SHARED_LOCAL_STORAGE` option is not enabled.\n     *\n     * @throws {AdobeLibraryError.NOT_SUPPORTED}\n     * @memberof CCLibraries\n     */\n    CCLibraries.disableSyncing = function () {\n        if (AdobeLibraryConfig.SHARED_LOCAL_STORAGE) {\n            throw new AdobeLibraryError(AdobeLibraryError.NOT_SUPPORTED, 'disableSyncing() not supported with shared local storage');\n        }\n\n        AdobeLibraryConfig.SYNCING_ENABLED = false;\n    };\n\n    /**\n     * Resolve the given element reference to an element object if exists.\n     * A reference for an element can be retrieved using {@link AdobeLibraryElement#getReference}.\n     *\n     * @param {String} reference of an element that is requested to be resolved.\n     * @returns {AdobeLibraryElement} The element object that is represented with the given element reference (or `undefined` if element cannnot be found).\n     * @memberof CCLibraries\n     */\n    CCLibraries.resolveElementReference = function (elementRef) {\n        var regex = new RegExp(\"cloud-asset://(.+)\" + AdobeLibraryConfig.STORAGE_ASSETS_PATH +\n            AdobeLibraryConfig.LIBRARY_SYNC_GROUP + \"/([A-Za-z0-9-]+);node=([A-Za-z0-9-]+)\");\n        var matches = elementRef.match(regex);\n        var element;\n\n        if (matches) {\n            var storageHost = matches[1];\n            var libraryId = matches[2];\n            var elementId = matches[3];\n\n            CCLibraries.getLoadedCollections().every(function (collection) {\n                if (collection._syncManager._storageHost === storageHost) {\n                    var library = collection.getLibraryById(libraryId);\n                    if (library) {\n                        element = library.getElementById(elementId);\n                    }\n                    return false;\n                }\n                return true;\n            });\n        }\n\n        return element;\n    };\n\n    /**\n     * The {@link AdobeLibraryError} class, which gives you access to all the error codes.\n     *\n     * @type {AdobeLibraryError}\n     * @memberof CCLibraries\n     */\n    CCLibraries.errors = AdobeLibraryError;\n\n    /**\n     * The {@link AdobeLibraryExternalUtils} class, which provides some utility methods for users of the\n     * the Creative Cloud Libraries API.\n     *\n     * @type {AdobeLibraryExternalUtils}\n     * @memberof CCLibraries\n     */\n    CCLibraries.utils = AdobeLibraryExternalUtils;\n\n    /**\n     * The {@link AdobeLibraryExternalAnalyticsUtils} class, which provides an API for reporting client events to Creative Cloud Libraries analytics.\n     *\n     * See {@tutorial analytics_example} for more information.\n     *\n     * @type {AdobeLibraryExternalAnalyticsUtils}\n     * @memberof CCLibraries\n     */\n    CCLibraries.analyticsUtils = AdobeLibraryExternalAnalyticsUtils;\n\n\n    return CCLibraries;\n\n});\n\n"]}